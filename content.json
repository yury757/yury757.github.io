{"meta":{"title":"Yury's Blog","subtitle":"","description":"blog of usual study","author":"Yury","url":"https://yury757.github.io","root":"/"},"pages":[{"title":"About me","date":"2021-08-23T14:45:11.000Z","updated":"2021-08-24T08:02:02.783Z","comments":true,"path":"about/index.html","permalink":"https://yury757.github.io/about/index.html","excerpt":"","text":"这个人很懒，什么都没留下。"},{"title":"tags","date":"2021-08-24T08:08:13.000Z","updated":"2021-08-24T08:09:38.655Z","comments":true,"path":"tags/index.html","permalink":"https://yury757.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-08-24T08:03:04.000Z","updated":"2021-08-24T08:03:37.908Z","comments":true,"path":"categories/index.html","permalink":"https://yury757.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-24T07:57:53.356Z","comments":true,"path":"/hello-world","link":"","permalink":"https://yury757.github.io/hello-world","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"SSM-Build","slug":"java/SSM-Build/SSM-Build","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-24T09:04:06.151Z","comments":true,"path":"/java/SSM-Build/SSM-Build","link":"","permalink":"https://yury757.github.io/java/SSM-Build/SSM-Build","excerpt":"","text":"SSM框架整合1、web.xml中配置DispatcherServlet时的初始化参数要连接所有的spring配置文件。先当与配置文件从web.xml是一个顶点，然后依次往下细分。 2、排错方法： 使用IDEA查看bean和MVC的细节 Junit单元测试 3、即使类上面加了@RestController，springmvc不会自动帮你把对象转字符串再返回给前端，这时若方法返回的是对象或List接口或其他则会报错No converter found for return value of type: class java.util.ArrayList。若导入了jackson-databind包，则会自动帮你把对象或列表转字符串，就可以直接返回一个对象了。 123456789@RequestMapping(&quot;/a2&quot;)public List&lt;User&gt; a2()&#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(&quot;yury757&quot;, 18, &quot;男&quot;)); userList.add(new User(&quot;name1&quot;, 28, &quot;男&quot;)); userList.add(new User(&quot;name2&quot;, 38, &quot;女&quot;)); userList.add(new User(&quot;name3&quot;, 48, &quot;男&quot;)); return userList;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yury757.github.io/tags/spring/"}]},{"title":"Java_NIO-study","slug":"java/java_NIO/Java_NIO-study","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-27T09:34:32.842Z","comments":true,"path":"/java/java_NIO/Java_NIO-study","link":"","permalink":"https://yury757.github.io/java/java_NIO/Java_NIO-study","excerpt":"","text":"一、NIO和IO的区别 传统IO面向流，而NIO面向管道（channel）和缓冲区（buffer）。传统IO只能单向传输数据，而NIO可以双向传输数据。传统IO就像单向水管，而NIO中channel像列车轨道，buffer就像火车，可以双向传输数据。 传统IO是阻塞（blocking）的，而NIO就是非阻塞（Non blocking）的。 NIO多了一个选择器（Selector），是针对网络编程用的。 二、缓冲区（Buffer）缓冲区（Buffer）是基于数组来做管理的，负责存取数据。java NIO有七种xxxBuffer类，都继承了Buffer类，即八种基本数据类型中，除了boolean以外都提供了对应的xxxBuffer。 1234567ByteBufferCharBufferShortBufferIntBufferLongBufferFloatBufferDoubleBuffer 每种xxxBuffer类还不是最终实现类，最终的实现类有两种，以下以ByteBuffer为例： 12345// 属于下面说的直接缓冲区，不懂操作系统的人最好不要使用，有风险class DirectByteBufferR extends DirectByteBuffer implements DirectBuffer&#123;&#125;// 常用这个实现类class HeapByteBuffer extends ByteBuffer&#123;&#125; 1、四个核心属性12345678910111213// 容量，缓冲区总的最大容量int capacity;// 最大可读写的容量int limit;// 位置，表示缓冲区中正在操作的数据的下标。当position&lt;limit，可以做写入操作，当position=limit时，写入操作会报错。int position;// 标记位置，默认为-1int mark = -1;// mark &lt; position &lt; limit &lt; capacity 2、主要方法下面以ByteBuffer为例： 123456789101112131415161718192021222324252627282930313233343536// 分配缓冲区public static ByteBuffer allocate(int capacity);// 存入数据到缓冲区中public abstract ByteBuffer put(byte b);// 读取数据public abstract byte get(int index);// 将缓冲区的数据读取到另外一个数组中public ByteBuffer get(byte[] dst, int offset, int length);// 切换到读取数据的模式。将limit的值置为当前position的值，再把position归0public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125;// 恢复到初始状态，注意数据还在，只是被遗忘了public final Buffer clear() &#123; position = 0; limit = capacity; mark = -1; return this;&#125;// 将position恢复到上一次mark标记的位置public final Buffer reset() &#123; int m = mark; if (m &lt; 0) throw new InvalidMarkException(); position = m; return this;&#125; 注意：public ByteBufferget(byte[] dst, int offset, int length)方法参数中的offset和length不是针对源buffer，而是针对新数组dst的！！ 3、非直接缓冲区 4、直接缓冲区 优点：效率更高！ 缺点：消耗资源大，数据写入到物理内存中后不受java控制，垃圾回收也有一定的问题。 三、通道（Channel）之前进行IO操作，是通过CPU授权给DMA（Direct Memory Access）总线，然后在DMA总线的管理下进行IO操作。而Channel则是一种独立的专门处理IO操作的特殊的（协）处理器，具有自己的IO指令，进行IO操作时不需要CPU授权。 1、接口和实现类接口： java.nio.Channels.Channel 实现类： FileChannel：本地数据IO SocketChannel：TCP连接用 ServerSocketChannel：TCP连接用 DatagramChannel：UDP连接用 2、获取通道的三种方式（1）各个支持通道的IO类提供了相应的getChannel方法1234567891011121314151617181920212223242526272829303132333435@Testpublic void test02() &#123; try(// 获取流 FileInputStream fis = new FileInputStream(filename1); FileOutputStream fos = new FileOutputStream(filename2); // 获取对应的通道 FileChannel fisChannel = fis.getChannel(); FileChannel fosChannel = fos.getChannel();) &#123; // 通过非直接缓冲区方式 ByteBuffer buffer = ByteBuffer.allocate(1024); // 将源数据通道的数据写入缓冲区 while (fisChannel.read(buffer) != -1)&#123; // 切换成读取模式 buffer.flip(); // 读取缓冲区中的数据，写入目标数据通道 fosChannel.write(buffer); // 清空缓冲区 buffer.clear(); &#125; &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; // 使用try()&#123;&#125;的方式就可以不用关闭，否则就要关闭所有的流和通道 // fosChannel.close(); // fisChannel.close(); // fis.close(); // fos.close();&#125; （2）使用open函数123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void test03() &#123; Date startTime = new Date(); // 通过open的方式获取通道 // CREATE_NEW：当文件存在时会报错 // CREATE：当文件存在时，会在原文件上从头开始覆盖写入。 // 但是很奇怪，当使用CREATE和直接缓冲区结合的方式时，当source文件的字节数小于destination文件的字节数时，并不会发生写入操作。 // 即一般使用CREATE_NEW就行 try(FileChannel fisChannel = FileChannel.open(Paths.get(filename1), StandardOpenOption.READ); FileChannel fosChannel = FileChannel.open(Paths.get(filename2), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW)) &#123; // 使用非直接缓冲区 ByteBuffer buffer = ByteBuffer.allocate(8 * 1024 * 1024); while (fisChannel.read(buffer) != -1)&#123; buffer.flip(); fosChannel.write(buffer); buffer.clear(); &#125; /* // 通过直接缓冲区方式 MappedByteBuffer inMappedBuffer = fisChannel.map(FileChannel.MapMode.READ_ONLY, 0, fisChannel.size()); MappedByteBuffer outMappedBuffer = fosChannel.map(FileChannel.MapMode.READ_WRITE, 0, fisChannel.size()); // 对直接缓冲区中的数据进行读写，因此省略了从OS地址空间到JVM地址空间的copy操作 // 使用内存映射文件时，就是将一个硬盘上的文件通过通道映射到物理内存的缓冲区中，当缓冲区有put操作，则会直接将对应的数据写入硬盘 byte[] dst = new byte[inMappedBuffer.limit()]; inMappedBuffer.get(dst); outMappedBuffer.put(dst); */ // 关闭通道，同样如果使用了try()&#123;&#125;则不用关闭 // fisChannel.close(); // fosChannel.close(); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; Date endTime = new Date(); System.out.println(&quot;time: &quot; + (endTime.getTime() - startTime.getTime()) / 1000 + &quot;秒&quot;);&#125; 注意！！使用Channel.transferTo方法时，一次传输最大传输支持2G，如果文件超过2G，则要断点传输！如下： 1234567891011121314151617181920212223@Testpublic void test04()&#123; Date startTime = new Date(); try(FileChannel fisChannel = FileChannel.open(Paths.get(filename1), StandardOpenOption.READ); FileChannel fosChannel = FileChannel.open(Paths.get(filename2), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW)) &#123; // 通过transferTo，也是通过直接缓冲区的方式 // transferTo一次传输最大2G，因此无论文件大小的化，最好使用以下方式 long position = 0; long len = fisChannel.size(); while (0 &lt; len)&#123; long l = fisChannel.transferTo(position, len, fosChannel); if (l &gt; 0)&#123; position = l; len -= l; &#125; &#125; &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; Date endTime = new Date(); System.out.println(&quot;time: &quot; + (endTime.getTime() - startTime.getTime()) / 1000 + &quot;秒&quot;);&#125; （3）通过Files创建1Files.newByteChannel(); 3、聚集和分散分散读取（Scattering Reads）：读取文件时按顺序填入多个缓冲区中，前面的缓冲区填满了，再填后面的缓冲区 聚集写入（Gathering Writes）：将多个缓冲区中的数据按顺序写入到通道中 即就是将channel写入一个bytebuffer数组中，或者从一个bytebuffer数组中读取数据到channel。 1234567891011121314151617181920212223242526272829@Testpublic void test05()&#123; try(RandomAccessFile raf = new RandomAccessFile(filename1, &quot;r&quot;); FileChannel channel = raf.getChannel(); RandomAccessFile raf2 = new RandomAccessFile(filename2, &quot;rw&quot;); FileChannel channel2 = raf2.getChannel(); ) &#123; System.out.println(&quot;=======分散读取======&quot;); ByteBuffer buffer1 = ByteBuffer.allocate(10); ByteBuffer buffer2 = ByteBuffer.allocate(1024); // 写入缓冲区 ByteBuffer[] buffers = &#123;buffer1, buffer2&#125;; channel.read(buffers); // 将缓冲区切换成读取模式 for (ByteBuffer buffer : buffers) &#123; buffer.flip(); &#125; // 将缓冲区中的内容打印出来 System.out.println(new String(buffers[0].array(), 0, buffers[0].limit())); System.out.println(&quot;=============&quot;); System.out.println(new String(buffers[1].array(), 0, buffers[1].limit())); System.out.println(&quot;=======聚集写入======&quot;); channel2.write(buffers); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125;&#125; 四、字符集（Charset）编码：字符串 =&gt; 字节数组 解码：字节数组 =&gt; 字符串 123456789@Testpublic void test01()&#123; final SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets(); stringCharsetSortedMap.forEach((key, value) -&gt; &#123; System.out.println(key.getClass().getName()); System.out.println(value.getClass().getName()); System.out.println(key + &quot;: &quot; + value); &#125;);&#125; 获取一个字符集的类，并得到他们的编码器和解码器： 123Charset gbk = Charset.forName(&quot;GBK&quot;);CharsetEncoder charsetEncoder = gbk.newEncoder();CharsetDecoder charsetDecoder = gbk.newDecoder(); encode方法得到一个ByteBuffer，而decode方法得到一个CharBuffer： 123456789101112131415161718192021222324252627@Testpublic void test02() throws Exception&#123; final Charset gbk = Charset.forName(&quot;GBK&quot;); final CharsetEncoder charsetEncoder = gbk.newEncoder(); final CharsetDecoder charsetDecoder = gbk.newDecoder(); CharBuffer charBuffer = CharBuffer.allocate(1024); charBuffer.put(&quot;你好，世界！hello, world!!&quot;); charBuffer.flip(); ByteBuffer byteBuffer = charsetEncoder.encode(charBuffer); for (int i = 0; i &lt; byteBuffer.limit(); i++) &#123; System.out.print(byteBuffer.get() + &quot; &quot;); &#125; System.out.println(); byteBuffer.flip(); CharBuffer charBuffer2 = charsetDecoder.decode(byteBuffer); for (int i = 0; i &lt; charBuffer2.limit(); i++) &#123; System.out.print(charBuffer2.get() + &quot; &quot;); &#125; System.out.println(); charBuffer2.flip(); System.out.println(charBuffer2.toString());&#125; 五、阻塞和非阻塞（重点！！）这里所说的阻塞和非阻塞主要针对网络编程。在客户端连接服务器时，客户端要向服务器发送数据包请求，双方都会打开一个通道，但是当服务器读取一段数据后，不清楚客户端通道中的数据是否读取完，则这个线程会被阻塞。 而非阻塞网络IO就是在客户端和服务器之间加一个选择器（Selector），所有客户端发送过来的数据包都先通过选择器，由选择器来判断该数据包是否准备完毕，将准备完毕的数据包发送给服务器去处理，而没准备完毕的数据包留在这里。 因此，使用NIO完成网络通信的三个核心： Channel，负责连接 Buffer，负责传输数据 Selector，是SelectableChannel的多路复用器，用于监控SelectableChannel的IO状况。 这部分笔者还不是很清楚。 六、NIO实战项目用NIO写一个非阻塞式http服务器：yury757/httpserver (github.com)","categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"}]},{"title":"mybatis-study","slug":"java/mybatis/mybatis-study","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-24T08:20:43.448Z","comments":true,"path":"/java/mybatis/mybatis-study","link":"","permalink":"https://yury757.github.io/java/mybatis/mybatis-study","excerpt":"","text":"练习用代码：yury757/Mybatis-Study (github.com) 一、Mybatis问题Mybatis遇到的问题大部分有以下五类： 1、配置文件没有注册 2、绑定接口错误 3、方法名不对 4、返回类型不对 5、Maven导出资源问题 二、Mybatis实现方式 写一个实体类和对应的查询接口 本来我们应该手写实现这个查询接口的类，并在对应的方法里面写sql语句、使用SqlSession执行SQL语句，再把结果集强转成我们自己的实体类。 Mybatis则不需要我们手写这个实现类，而是弄了一个mapper的xml文件，里面定义了某个接口的某个方法的实现，我们只需要在xml中定义这个方法的SQL语句、参数类型、参数集、结果类型、结果集等标签。 再将对应的mapper注册到Mybatis的配置文件中。 然后项目启动时，Mybatis框架去配置文件的注册中心中把注册过的类提前实现好，生成.class字节码文件（猜测），我们只需要通过getMapper(UserDao.class)方法（这个方法里面肯定封装了newInstance或类似的方法）就可以拿到对应类的实例，然后直接调用相应的方法就行。而且会自动帮我们把结果集封装到mapper定义的结果类型中。 三、Mybatis中的三个核心类（1）SqlSessionFactoryBuilder这个类是用于创建SqlSessionFactory对象的，SqlSessionFactory对象一旦创建就不再需要SqlSessionFactoryBuilder了。 1234567891011// 使用mybatis第一步，获取SqlSessionFactory对象static&#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; （2）SqlSessionFactorySqlSessionFactory一旦被创建，应该在程序运行期间一直存在，因为它是创建SqlSession对象的工厂。默认为单例模式。 （3）SqlSessionSqlSession是用于访问数据库的一个会话。 SqlSession实例不是线程安全的，因此避免被共享，最佳的使用域是请求或非静态方法作用域。 使用完一个SqlSession后一定一定一定要关闭它，为避免关闭资源时异常，最好使用以下方式使用SqlSession 123456789// 获取SqlSession对象的方法public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession();&#125;// 重载方法，选择是否自动提交public static SqlSession getSqlSession(boolean autoCommit)&#123; return sqlSessionFactory.openSession(autoCommit);&#125; 1234567try(SqlSession sqlSession = MybatisUtils.getSqlSession())&#123; UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.println(user.toString()); &#125;&#125; 四、Mapper标签属性注意事项 id：对应接口的方法名 resultType：结果集类型，要写全限定类名，或别名 parameterType：参数类型 当接口方法只有一个参数时，#&#123;&#125;中有以下几种填法 若传入参数类型是一个实体类或其他类，#&#123;&#125;可直接填入相应属性名 若传入参数类型是Map接口类（可以用别名map代表Map），#&#123;&#125;可直接填入相应的键值 若传入参数是String、int等其他类型，#&#123;&#125;填任意值数字或字母的组合都行，建议使用param1 当接口方法只有多个参数时，parameterType可不填，#&#123;&#125;按接口方法的参数顺序填入#&#123;param1&#125;、#&#123;param2&#125;。或者在接口处使用@param注解，给参数起一个别名。 12345678910111213141516171819&lt;!-- 有两个类型相同的参数的查询 --&gt;&lt;select id=&quot;getTwoUserById&quot; parameterType=&quot;int&quot; resultType=&quot;org.xxxx.pojo.User&quot;&gt; select * from user where id = #&#123;param1&#125; or id = #&#123;param2&#125;&lt;/select&gt;&lt;!-- 有两个类型不同的参数的查询2 --&gt;&lt;select id=&quot;getTwoUserById2&quot; parameterType=&quot;Object&quot; resultType=&quot;org.xxxx.pojo.User&quot;&gt; select * from user where id = #&#123;param1&#125; or name = #&#123;param2&#125;&lt;/select&gt;&lt;!-- 有两个类型不同的参数的查询3 --&gt;&lt;select id=&quot;getTwoUserById3&quot; resultType=&quot;org.xxxx.pojo.User&quot;&gt; select * from user where id = #&#123;param1&#125; or id = #&#123;param2.id&#125;&lt;/select&gt;&lt;!-- 有两个类型不同的参数的查询4 --&gt;&lt;select id=&quot;getTwoUserById4&quot; resultType=&quot;org.xxxx.pojo.User&quot;&gt; select * from user where id = #&#123;id&#125; or id = #&#123;user.id&#125;&lt;/select&gt; 1234/** * 有两个类型不同的参数的查询4，使用@Param注解 */public List&lt;User&gt; getTwoUserById4(@Param(&quot;id&quot;) int id,@Param(&quot;user&quot;) User user); 、模糊查询有两种方式 在mapper中这样用来拼接%：like &quot;%&quot;#&#123;param1&#125;&quot;%&quot; mapper中仍然使用like #&#123;param1&#125;，而在调用方式时手动在传入参数两边加上% 推荐使用第一种，因为在参数里面加%可能面临被转义的风险。 1234567&lt;select id=&quot;getUserLike1&quot; parameterType=&quot;string&quot; resultType=&quot;org.xxxx.pojo.User&quot;&gt; select * from user where name like &quot;%&quot;#&#123;param1&#125;&quot;%&quot;&lt;/select&gt;&lt;select id=&quot;getUserLike2&quot; parameterType=&quot;string&quot; resultType=&quot;org.xxxx.pojo.User&quot;&gt; select * from user where name like #&#123;param1&#125;&lt;/select&gt; resultMap：结果集映射，将从数据库中取出来的字段和类中的属性做一个映射关系，为解决数据库字段名和类属性名不一致的问题。column为数据库字段名，property为类的属性名。 12345&lt;resultMap id=&quot;UserMap&quot; type=&quot;user&quot;&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;pwd&quot;/&gt;&lt;/resultMap&gt; 五、mybatis-config.xml配置解析（1）properties标签可以引入其他某个.properties文件，作为参数值在本配置文件中使用。 1&lt;properties resource=&quot;db.properties&quot;/&gt; 也可以可以加入property标签加入自定义参数。 对于有重复的参数，参数调用顺序是，先生成property标签中的参数，再读取引入的配置文件中的参数，对于有重复的参数会被覆盖掉，理解成一个HashMap即可。 （2）settings标签有以下属性：https://mybatis.org/mybatis-3/zh/configuration.html#settings 主要用的有： cacheEnabled：缓存 useGeneratedKeys：自动生成主键 mapUnderscoreToCamelCase：数据库字段名转java属性名时自动重命名 logImpl：日志实现类 官网也给了一个建议的设置如下： 1234567891011121314151617&lt;settings&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; （3）typeAliases标签为类型设置别名，这样避免了写全限定类型或全限定接口名。 当为一整个包的类设置别名时，若类型带有@Alias注解时，别名为注解值；否则别名为对应类的类型，首字母小写。 1234&lt;typeAliases&gt; &lt;!-- &lt;typeAlias type=&quot;org.yuyr757.pojo.User&quot; alias=&quot;UserAlias&quot;/&gt; --&gt; &lt;package name=&quot;org.xxxxx.pojo&quot;/&gt;&lt;/typeAliases&gt; Mybatis有一些默认别名，如下：https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases （4）mappers映射器官网有四种写法，使用完全限定资源定位符（URL）不推荐使用。 12345&lt;mappers&gt; &lt;!-- &lt;mapper resource=&quot;org/xxxx/Dao/UserMapper.xml&quot;/&gt;--&gt; &lt;!-- &lt;mapper class=&quot;org.xxxx.Dao.UserMapper&quot;/&gt;--&gt; &lt;package name=&quot;org.xxxx.Dao&quot;/&gt;&lt;/mappers&gt; 最推荐使用第四种，将包内的映射器接口实现全部注册为映射器。使用条件： 接口和mapper必须放在同一个包下，建议包名为Dao，同一个包下是指编译后同一个包下，可以在resources目录下也新建一个org.xxxx.Dao目录，这样接口和mapper配置就会编译到同一个包下了。 接口和mapper两个文件名必须相同（文件类型后缀不管） 使用这种方式必须在pom.xml中把src/java/main下的xml文件作为配置文件添加到build.resources.resource中 123456java.org.xxxx.Dao UserMapper.java（接口） Department.javaresources.org.xxxx.Dao UserMapper.xml（mapper） Department.xml 六、分页1、在mapper的sql语句中把startIndex和endIndex作为参数传入进去 2、分页插件PageHelper：https://pagehelper.github.io/ 七、使用注解开发实现方式：反射、动态代理 123456789101112131415/** * 对于这种很简单的sql，可以不用写mapper，直接写一个Select注解，里面传入sql值即可 * 注意点： * 1、数据库字段名和类属性名要相同 * 2、returnType为接口的返回类型 * 3、parameterType为接口的参数类型 */@Select(&quot;select * from user where id = #&#123;param1&#125;&quot;)public List&lt;User&gt; getUserByIdUsingAnnotation(int id);@Select(&quot;select * from user where id = #&#123;param1&#125; or name = #&#123;param2&#125;&quot;)public List&lt;User&gt; getUserByIdUsingAnnotation2(int id, String name);@Insert(&quot;insert into user(id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)&quot;)public void addUserUsingAnnotation(User user); 八、连表查询1在数据库设计时，为降低数据的冗余，一般都会做到三范式。比如学生老师信息表可能会做成以下这种方式： 比如一个学生表如下： ID NAME TEACHER_ID 1 小明 1 2 小五 1 3 小华 3 4 小石 2 5 李笑 3 6 孙武 2 7 黄铭 2 一个老师表如下： ID NAME 1 李老师 2 黄老师 3 钱老师 因此我们的java对象应该是这样的： 12345678910public class Student &#123; private int id; private String name; private Teacher teacher; // 引用了一个老师&#125;public class Teacher &#123; private int id; private String name;&#125; 这样我们在配置mapper时有两种方法： 1、通过子查询方式1234567891011121314&lt;select id=&quot;getStudent&quot; resultMap=&quot;studentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;studentTeacher&quot; type=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!-- 对象使用association，集合使用collection --&gt; &lt;association property=&quot;teacher&quot; column=&quot;teacher_id&quot; javaType=&quot;teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;teacher&quot;&gt; select * from teacher where id = #&#123;id&#125;&lt;/select&gt; 其中association标签的属性解释： property：属性名 column：该属性要用数据库中的某个字段名去关联查询 javaType：该属性的类型 select：从数据库拿到这个类的数据的select语句 这种方式实际上就是把查询出来的关联字段去重，去重后再去数据库里面查相应的数据，再封装到对象中。 如打开日志后可以发现这种方式实际上查了四次数据库。 12345678910111213141516171819202122232021-02-22 17:40:11[ DEBUG ]Opening JDBC Connection2021-02-22 17:40:12[ DEBUG ]Created connection 202125197.2021-02-22 17:40:12[ DEBUG ]==&gt; Preparing: select * from student 2021-02-22 17:40:12[ DEBUG ]==&gt; Parameters: 2021-02-22 17:40:12[ DEBUG ]====&gt; Preparing: select * from teacher where id = ? 2021-02-22 17:40:12[ DEBUG ]====&gt; Parameters: 1(Integer)2021-02-22 17:40:12[ DEBUG ]&lt;==== Total: 12021-02-22 17:40:12[ DEBUG ]====&gt; Preparing: select * from teacher where id = ? 2021-02-22 17:40:12[ DEBUG ]====&gt; Parameters: 3(Integer)2021-02-22 17:40:12[ DEBUG ]&lt;==== Total: 12021-02-22 17:40:12[ DEBUG ]====&gt; Preparing: select * from teacher where id = ? 2021-02-22 17:40:12[ DEBUG ]====&gt; Parameters: 2(Integer)2021-02-22 17:40:12[ DEBUG ]&lt;==== Total: 12021-02-22 17:40:12[ DEBUG ]&lt;== Total: 7Student&#123;id=1, name=&#x27;小明&#x27;, teacher=Teacher&#123;id=1, name=&#x27;李老师&#x27;&#125;&#125;Student&#123;id=2, name=&#x27;小五&#x27;, teacher=Teacher&#123;id=1, name=&#x27;李老师&#x27;&#125;&#125;Student&#123;id=3, name=&#x27;小华&#x27;, teacher=Teacher&#123;id=3, name=&#x27;钱老师&#x27;&#125;&#125;Student&#123;id=4, name=&#x27;小石&#x27;, teacher=Teacher&#123;id=2, name=&#x27;黄老师&#x27;&#125;&#125;Student&#123;id=5, name=&#x27;李笑&#x27;, teacher=Teacher&#123;id=3, name=&#x27;钱老师&#x27;&#125;&#125;Student&#123;id=6, name=&#x27;孙武&#x27;, teacher=Teacher&#123;id=2, name=&#x27;黄老师&#x27;&#125;&#125;Student&#123;id=7, name=&#x27;黄铭&#x27;, teacher=Teacher&#123;id=2, name=&#x27;黄老师&#x27;&#125;&#125;2021-02-22 17:40:12[ DEBUG ]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c0c2f8d]2021-02-22 17:40:12[ DEBUG ]Returned connection 202125197 to pool. 2、通过连表查询方式12345678910111213&lt;select id=&quot;getStudent2&quot; resultMap=&quot;studentTeacher2&quot;&gt; select s.id, s.name, s.teacher_id, t.name as teacher_name from student s left join teacher t on s.teacher_id = t.id&lt;/select&gt;&lt;resultMap id=&quot;studentTeacher2&quot; type=&quot;student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;teacher_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;teacher_name&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 同样有一个association标签，而下面还有封装这个teacher类的子标签，子标签定义了初始化这个类所需要的字段映射。 property：属性名 javaType：该属性的类型 这种方式只需要查一次数据库： 12345678910111213142021-02-22 17:41:58[ DEBUG ]Opening JDBC Connection2021-02-22 17:41:59[ DEBUG ]Created connection 202125197.2021-02-22 17:41:59[ DEBUG ]==&gt; Preparing: select s.id, s.name, s.teacher_id, t.name as teacher_name from student s left join teacher t on s.teacher_id = t.id 2021-02-22 17:41:59[ DEBUG ]==&gt; Parameters: 2021-02-22 17:41:59[ DEBUG ]&lt;== Total: 7Student&#123;id=1, name=&#x27;小明&#x27;, teacher=Teacher&#123;id=1, name=&#x27;李老师&#x27;&#125;&#125;Student&#123;id=2, name=&#x27;小五&#x27;, teacher=Teacher&#123;id=1, name=&#x27;李老师&#x27;&#125;&#125;Student&#123;id=4, name=&#x27;小石&#x27;, teacher=Teacher&#123;id=2, name=&#x27;黄老师&#x27;&#125;&#125;Student&#123;id=6, name=&#x27;孙武&#x27;, teacher=Teacher&#123;id=2, name=&#x27;黄老师&#x27;&#125;&#125;Student&#123;id=7, name=&#x27;黄铭&#x27;, teacher=Teacher&#123;id=2, name=&#x27;黄老师&#x27;&#125;&#125;Student&#123;id=3, name=&#x27;小华&#x27;, teacher=Teacher&#123;id=3, name=&#x27;钱老师&#x27;&#125;&#125;Student&#123;id=5, name=&#x27;李笑&#x27;, teacher=Teacher&#123;id=3, name=&#x27;钱老师&#x27;&#125;&#125;2021-02-22 17:41:59[ DEBUG ]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c0c2f8d]2021-02-22 17:41:59[ DEBUG ]Returned connection 202125197 to pool. 具体使用哪种方式视情况而定，简单的连表可以使用第二种。当连表查询的sql特别复杂，以致于难以在sql层面去优化时，可以使用第一种，主查询把其他需要连的表的主键查询来，子查询再用主键去查，可能会提高效率。 九、连表查询2对于以上的学生老师表，我们的java类还可能是这样的： 1234567891011public class Student2 &#123; private int id; private String name; private int teacherId;&#125;public class Teacher2 &#123; private int id; private String name; private List&lt;Student&gt; students; // 老师这里有多个学生对象的引用&#125; 同样有子查询和连表查询两种方式： 1、通过子查询方式123456789101112131415161718&lt;!-- 子查询 --&gt;&lt;select id=&quot;getTeacherById2&quot; resultMap=&quot;teacher2Student2&quot;&gt; select t.id, t.name from teacher t where t.id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;teacher2Student2&quot; type=&quot;teacher2&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;collection property=&quot;students&quot; column=&quot;id&quot; javaType=&quot;ArrayList&quot; ofType=&quot;student2&quot; select=&quot;getStudent&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;student2Map&quot;&gt; select * from student where teacher_id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;student2Map&quot; type=&quot;student2&quot;&gt; &lt;result property=&quot;teacherId&quot; column=&quot;teacher_id&quot;/&gt;&lt;/resultMap&gt; 2、通过连表查询方式1234567891011121314151617&lt;!-- 连表查询 --&gt;&lt;select id=&quot;getTeacherById&quot; resultMap=&quot;teacher2Student&quot;&gt; select t.id, t.name, s.id as student_id, s.name as student_name from teacher t left join student s on t.id = s.teacher_id where t.id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=&quot;teacher2Student&quot; type=&quot;teacher2&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!-- 这里要用ofType，即集合的元素类型 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student2&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;student_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;student_name&quot;/&gt; &lt;result property=&quot;teacherId&quot; column=&quot;id&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 十、缓存1、本地缓存。作用域为SqlSession，默认开启。 在一个session中查两次相同的sql，只会执行一次sql，第二次拿到的对象，和第一次拿到的对象的地址都是一样的。本地缓存将会在做出修改、事务提交或回滚，以及关闭session时清空。默认情况下，本地缓存数据的生命周期等同于整个session的周期。 2、二级缓存。作用域为mapper的namespace，当sqlsession作出修改、事务提交、回滚或关闭时，会把本地缓存扔到二级缓存中。即一级缓存失效时，会把其缓存的数据扔到二级缓存中。 需要在mapper中加入&lt;cache/&gt;就可以为这个mapper开启二级缓存。 12345&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 在mybatis-config.xml配置中，设置cacheEnabled为true可以为所有mapper开启二级缓存。 缓存清除策略： LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。 WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。 3、缓存顺序二级缓存 =&gt; 本地缓存 =&gt; 数据库 N、注意事项 insert、update、delete要手动提交事务： 1sqlSession.commit();","categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"}]},{"title":"hbase-study","slug":"hbase/HBase-study","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-24T09:15:05.464Z","comments":true,"path":"/hbase/HBase-study","link":"","permalink":"https://yury757.github.io/hbase/HBase-study","excerpt":"","text":"Linux：ubuntu18.04.5 hbase：2.3.5 官方文档：Apache HBase ™ Reference Guide 一、HBase介绍1、Hadoop的局限性 hadoop主要是实现批量数据的处理，并通过顺序方式访问数据。比如批量处理一天的数据。 要查找数据必须搜索整个数据集，即不具备随即读取数据的能力。 2、HBase简介 HBase是一个分布式的、面向列的开源数据库，该技术来源于Fay Chang所撰写的Google论文《Bigtable：一个结构化数据的分布式存储系统》。 HBase一开始是Hadoop下的一个子项目，因为也是基于HDFS文件系统的，后成为Apache的顶级项目。 HBase是Google Bigtable的开源实现，类似Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapReduce来处理Bigtable中的海量数据，HBase同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应。 HBase是一种NoSQL数据库，仅能通过主键（row key）和主键的range来检索数据，对事务的支持较弱。 HBase只支持一种数据类型：byte[] HBase是稀疏存储的，即为空的字段不占用空间，而比如MySQL的null实际上也会占空间的。 应用场景：需要存储海量数据，又要快速的写入和查询数据的场景。 3、关系型数据库（RDBMS）和HBase的比较 关系型数据库（以MySQL为例） HBase 是否以表的形式存在 是 是 支持的文件系统 FAT（windows旧）、NTFS（windows新）、EXT（Linux） HDFS文件系统 物理上的存储方式 以行的形式存储，每个字段之间用分隔符隔开 以每个单元格为一行的形式存储，即每一个单元格数据都会存储其row key、列簇名、列名和时间戳等。HBase会对行进行分割，一片行和一个列簇即形成一个region。具体见后面详解。 索引 支持主键（primary key）和二级索引 仅支持主键（row key） 事务 最常用的InnoDB引擎的事务处理满足ACID原则 对事务的支持较弱，不支持ACID 是否能使用sql查询 能 不能，NoSQL数据库 是否支持join 支持 不支持 适合存储的数据 适合存储少量的、结构化的数据 适合存储大量数据，结构化和非结构话都适合，但是如果使用HBase来存储少量数据，效率和内存消耗上都不如关系型数据库 4、HBase的逻辑结构 5、HBase的物理结构HBase的物理结构，实际上是每一个单元都对应了一行或多行数据，每行存储了其元数据信息和值。 而实际上删除操作的第一时间并不会真正删除数据，而是插入了一条type为delete的数据，timestamp则是版本控制（这就是为什么需要校正服务器时间），查数据get命令其实就是获取timestamp最大的那条数据，如果这条数据的type是delete，则不反悔数据，否则返回那条数据。而scan命令可以通过设置VERSION参数来查看之前版本的数据。 6、Hive和HBase的区别 Hive HBase 定位 Hive是一个数据仓库工具，本质相当于把HDFS中已存在的数据文件在MySQL中做一个映射关系，以方便用HQL去管理查询。 定位是一个NoSQL数据库 功能 用于数据分析和清洗 高效地存储和查询数据 使用场景 离线数据分析和清晰，因为需要时间较长，延迟较高 实时查询和存储海量数据 底层 基于HDFS，编写的HQL最终是转换为MapReduce代码执行 基于HDFS，但是在HDFS上做了进一步的处理和优化 如下面是一种数据仓库架构。 二、下载、安装和配置下载链接：HBase的清华大学镜像包 选择一个稳定版本，点进去后下载其中的二进制的压缩包，不用下载源码的压缩包，源码的压缩包可以用来看源码。 12345678# 下载wget https://mirrors.tuna.tsinghua.edu.cn/apache/hbase/stable/hbase-2.3.5-bin.tar.gz# 解压tar xzvf hbase-2.3.5-bin.tar.gz# 以这个目录为工作目录cd hbase-2.3.5 配置环境变量 1234567vi /etc/profile# 在最下面添加export HBASE_HOME=/home/yury/hbase-2.3.5export PATH=$&#123;PATH&#125;:$&#123;HBASE_HOME&#125;/bin:$&#123;HBASE_HOME&#125;/sbin# 加载环境变量source /etc/profile 修改配置文件./conf/hbase-env.sh 1234567# 修改压缩包根目录下的这个文件vi ./conf/hbase-env.sh# 添加JAVA_HOME配置export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64/# 为false时使用自己的ZOOKEEPER，即需要自己启动zookeeper服务。为true时使用hbase内置的zookeeper，如果是单机版建议为true，或者不配置export HBASE_MANAGES_ZK=false 将一个包复制到lib目录下 1cp lib/client-facing-thirdparty/htrace-core4-4.2.0-incubating.jar ./lib/ 移除一个日志jar包，这个版本和hadoop的3.3.0版本的日志包会有冲突 1rm lib/client-facing-thirdparty/slf4j-log4j12-1.7.30.jar 三、单机版使用单机版时最好将zookeeper和hadoop的环境变量注释掉，再重新加载环境变量，不然即使没启动zk和hadoop也可能会有问题（我所遇到的问题是hbase的hmaster进程启动后瞬间就没了，将zk和hadoop环境变量注释掉后就好了）。 1234567891011# 配置完了以上操作后，直接启动即可./bin/start-hbase.sh# 返回结果如下# running master, logging to /home/yury/hbase-2.3.5/bin/../logs/hbase-yury-master-myubuntu1.out# 可以在http://localhost:16010这个页面中HBase的web管理页面# jps命令可以看到有一个HMaster进程jps# 2032 Jps# 1539 HMaster 四、初步使用HBase的shellhbase的数据库结构主要以下层次： namespace（命名空间，相当于MySQL的schema） table column family（列簇） column qualifier（列名） hbase的namespace默认有两个：default和namespace，默认使用default，即在创建表时如果没有加命名空间前缀，则默认往default命名空间里面建表。 而namespace这个命名空间存储着数据库的元数据信息，这个命名空间向相当于MySQL的information这个schema。 hbase shell里面没有分号，如果敲了分号并回车了，可以通过敲一个单引号，再回车，再敲一个单引号来取消之前的命令。 对于哪个命令不熟悉，可以help &#39;create&#39;，就有这个命令的使用方法，下面只是简单介绍。 12# 启动hbase的shell命令，需要配置hbase环境变量，以下都是hbase的shell命令hbase shell 1、命名空间操作12345list_namespace # 展示所有命名空间create_namespace &#x27;myns&#x27; # 创建命名空间，相当于MySQL的创建一个schemadrop_namespace &#x27;myns&#x27; # 删除命名空间describe_namespace &#x27;myns&#x27; # 查看指定命名空间的详细信息list_namespace_tables &#x27;myns&#x27; # 查看指定命名空间下的所有表 2、表操作1234567891011121314# 对于表的操作默认是指default命名空间，要想对其他命名空间操作表，需加命名空间的前缀，如下# 在myns命名空间下创建一个表create &#x27;myns:myns_test&#x27;, &#x27;myns_cf&#x27;# 以下不加前缀则都是在default命名空间下操作create &#x27;test&#x27;, &#x27;cf&#x27; # 一个列簇cfcreate &#x27;test2&#x27;, &#x27;cf1&#x27;, &#x27;cf2&#x27; # 两个列簇cf1和cf2list &#x27;test&#x27; # 确认表是否存在describe &#x27;test&#x27; # 查看表结构disable &#x27;test&#x27; # 使表失效enable &#x27;test&#x27; # 使表生效alter &#x27;test&#x27;, &#123;NAME=&gt;&#x27;cf1&#x27;, VERSION=&gt;3&#125; # 修改表的元数据信息drop &#x27;test&#x27; # 删除表，删除之前要disable这个表scan &#x27;test&#x27;, &#123;STARTROW=&gt;&#x27;1001&#x27;, STOPROW=&gt;&#x27;1003&#x27;&#125; # 扫描查看&#x27;test&#x27;表的所有数据 3、数据操作12345678910111213141516171819202122232425# 插入数据# 参数1：命名空间+表名# 参数2：行号，row key# 参数3：列名全限定名，即列簇名+列名# 参数4：值put &#x27;&#123;namespace&#125;:&#123;tablename&#125;&#x27;, &#x27;&#123;row key&#125;&#x27;, &#x27;&#123;column family&#125;:&#123;column qualifier&#125;&#x27;, &#x27;&#123;value&#125;&#x27;, &#x27;&#123;timestamp&#125;&#x27;, &#x27;&#123;其他属性&#125;&#x27;put &#x27;test&#x27;, &#x27;row1&#x27;, &#x27;cf:a&#x27;, &#x27;value1&#x27;put &#x27;test&#x27;, &#x27;row2&#x27;, &#x27;cf:b&#x27;, &#x27;value2&#x27;put &#x27;test&#x27;, &#x27;row3&#x27;, &#x27;cf:c&#x27;, &#x27;value3&#x27;# 根据表名和row key获取值get &#x27;&#123;namespace&#125;:&#123;tablename&#125;&#x27;, &#x27;&#123;row key&#125;&#x27;, &#x27;&#123;column family&#125;:&#123;column qualifier&#125;&#x27;get &#x27;test&#x27;, &#x27;row1&#x27;# 结果如下# COLUMN CELL# cf:a timestamp=2021-05-01T17:46:15.064, value=value1# 根据表名、row key和列删除数据，一个单元格delete &#x27;&#123;namespace&#125;:&#123;tablename&#125;&#x27;, &#x27;&#123;row key&#125;&#x27;, &#x27;&#123;column family&#125;:&#123;column qualifier&#125;&#x27;# 根据表名、row key删除数据，row key对应的一整行deleteall &#x27;&#123;namespace&#125;:&#123;tablename&#125;&#x27;, &#x27;&#123;row key&#125;&#x27;# 清空表truncate &#x27;&#123;namespace&#125;:&#123;tablename&#125;&#x27; 注意： row key为字符串类型，其排序是按照字符串的大小排序，如’10010’ &gt; ‘1001’。 get命令的列参数哪里如果没有冒号，则这个参数是指column family而不是column qualifier。 scan命令如果有STARTROW和STOPROW参数，则筛选范围为左闭右开！ 数据的改操作没有update命令，其实直接put进去一个值，就会自动完成改操作，有点类似于hashmap直接put后会覆盖原来的值这种。 创建表和列簇时的VERSION属性表示这个这个列簇最终将会存几个版本的数据，如VERSION=2，则取数据时设置VERSION=3也只能拿到两条数据，并且在hbase空间时，除最新的两个版本的数据会被保留外，其余版本数据都会从磁盘中删除。 五、分布式部署1、伪分布式伪分布式：在同一个服务器中部署，但是HMaster，HRegionServer和ZooKeeper服务在不同的JVM进程中。 前提：先启动zookeeper服务（可以单机模式），再启动hadoop服务（至少伪分布式），最后才能启动hbase 配置/conf/hbase-site.xml 1vi /conf/hbase-site.xml 123456789101112&lt;!-- 为true则是分布式的，为false则是单机版 --&gt;&lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt;&lt;/property&gt;&lt;!-- 这个是指数据的根目录在哪里，可以指定hdfs文件系统，即在hadoop的etc/hadoop/core-site.xml中配置的fs.defaultFS --&gt;&lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;&lt;/property&gt;&lt;!-- 官网文档说还要删除hbase.tmp.dir配置和hbase.unsafe.stream.capability.enforce配置 --&gt; 启动 123456789101112131415# 启动hbasebin/start-hbase.sh# 在hadoop中校验是否在hdfs文件系统中创建了一个hbase的文件夹bin/hadoop fs -ls /hbase# zookeeper、hadoop和hbase全部启动成功后，运行jps命令结果应该是这样的。如果没有jps命令，linux会提示你安装一个jdk的东西jps6976 DataNode # hadoop6787 NameNode # hadoop6531 QuorumPeerMain # zookeeper7237 SecondaryNameNode # hadoop7941 Jps # jps7592 HMaster # hbase7786 HRegionServer # hbase 2、完全分布式hbase-site.xml配置文件 123456789101112131415161718192021222324&lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.tmp.dir&lt;/name&gt; &lt;value&gt;./tmp&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://192.168.0.201:9000/hbase&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;192.168.0.201,192.168.0.202,192.168.0.203&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/home/yury/zookeeper-3.6.3/zookeeper-data/hbase&lt;/value&gt;&lt;/property&gt; 3、注意点1、各个服务器之间的时间必须要同步，不然会出现不可预知的错误 六、HBase进阶1、HBase架构HMaster负责DDL操作，而HRegionServer负责DML操作，而实际操作中都会有zookeeper，zookeeper则是负责调度HRegionServer，因此当HMaster挂了，并不影响DML操作，只是不能进行DDL操作。 HLog类似于MySQL的Binlog，防止数据库奔溃时数据丢失。 2、写数据流程 收到put请求：put table/rowkey/cf/column value 前往meta-region-server这个服务器，请求查询该表的meta表所在RegioinServer 前往meta表所在服务器，请求查询该表和列簇所在的RegioinServer 将该put请求发送给对应的服务器 3、MemStore Flush即把内存中的数据刷新到HDFS中。 配置 解释 hbase.regionserver.global.memstore.size 全局配置，一个regionserver中所有memstore之和的最大值，默认为堆内存的40%，当memstore超过这个值时，就会阻塞写数据操作 hbase.regionserver.global.memstore.size.lower.limit 全局配置，一个regionserver中所有memstore之和的最大值，默认为堆内存的40%*0.95=38%，当memstore超过这个值时，就会开始flush操作，此时还不会阻塞写数据操作 hbase.regionserver.optionalcacheflushinterval 内存中的最后一次编辑的数据文件在自动刷新前能够存活的最长时间，默认1小时，当某些数据超过这个时间时，即使memstore内存没达到flush阈值，也会进行flush hbase.hregion.memstore.flush.size 单个region中memstore的缓存最大值，超过这个值时这个region就会进行flush，默认值为128M 4、读数据流程 收到get请求 前往meta-region-server查询meta表所在的RegionServer 前往meta表所在服务器，请求查询该表和列簇所在的RegioinServer 同时读memstore（内存）和storefile（磁盘），将两份数据读进block cache，取时间戳最大的那条数据。 5、StoreFile Compactionhdfs中的hfile文件的合并，compaction操作是先全部读出来，再重新合并在一起。有以下两种： Minor compaction：只选取一些小的文件进行合并，不会删除delete类型或时间戳更小的数据 Major compaction：将一个store下的所有hfile合并成一个大文件，对于相同rowkey且时间戳更小的数据会执行物理删除操作 配置： 配置 解释 hbase.hregion.majorcompaction 一个region进行自动major compaction的周期，默认为7天，即7天自动进行一次大合并。生产环境不建议开启（设置为0），因为很耗资源，而是手动进行major compaction hbase.hregion.majorcompaction.jitter 抖动比例，不管，反正都会被关掉 hbase.hstore.compactionThreshold 一个store中允许存的hfile的最大值，超过或等于这个值，就会被合并到一个新的hfile中，默认值为3 6、真正删数据发生在什么时候 进行flush时，内存中版本更老的数据会被删除，即老版本数据不会被写入hfile中 进行major compaction时会将老版本数据删除 7、Region Split 配置 解释 hbase.hregion.max.filesize 一个region的最大大小。默认值为10G。 当一个region中的某个store下的所有storefile总大小超过Min(&quot;count of region&quot;^2*&quot;hbase.hregion.memstore.flush.size&quot;, &quot;hbase.hregion.max.filesize&quot;)时，该region就会进行拆分。 数据热点问题： 第一个region的拆分的阈值为128M，拆分为两个，分别为64M rowkey是自增的，在第二个region后面新增数据 第二个region的拆分的阈值为512M（2^2*128），拆分为两个，分别为256M rowkey继续自增，在第三个region后面新增数据 第三个region的拆分阈值为1152M（3^2*128），拆分为两个，分别为576M rowkey继续自增…… 因此，这样的话第n个region的大小为：Min(n^2*64M, 5G)，即region在到达5G之前，各个regino的大小差异会比较大，即数据会集中在某几个region中，导致这几个region服务器压力很大。 官方建议，使用更少的列簇，将更多的列放进同一个列簇中，而不是创建更多的列簇，因为多个列簇flush后容易形成多个小文件 七、优化1、高可用在创建conf/backup-master这个文件，在里面写入备份的master结点的服务器，当主节点挂了之后，会选举一个备份主节点来顶替主节点的位置 12192.168.141.142192.168.141.143 2、预分区（1）手动设置预分区（更常用） 1create &quot;staff&quot;, &quot;info&quot;, &quot;partition&quot;, SPLITS =&gt; [&#x27;1000&#x27;, &#x27;2000&#x27;, &#x27;3000&#x27;, &#x27;4000&#x27;] （2）手动生成16进制预分区 1create &quot;staff2&quot;, &quot;info&quot;, &quot;partition2&quot;, &#123;NUMREGIONS =&gt; 15, SPLITALGO =&gt; &#x27;HexStringSplit&#x27;&#125; （3）按照文件中设置的分区规则预分区 123456# 在hbase根目录下touch splits.txtaaaabbbbccccdddd 12create &quot;staff3&quot;, &quot;info&quot;, &quot;partition3&quot;, SPLITS_FILE =&gt; &#x27;splits.txt&#x27;# 系统会给splits.txt这个文件进行排序 （4）使用javaAPI创建分区 略 3、rowkey的设计rowkey要保持散列性（随机性，使其可以随机落在不同的region中）、唯一性、长度足够长等原则，最好是70-100位字母或数字。 如生成随机数、hash、散列值、字符串拼接。 （1）案例1存储通话记录以及通话详情的rowkey设计。需存储的数据如下： 12phone_from phone_to time_start duration13112345678 13187654321 2021-01-01 12:12:12 45 首先根据业务对未来十年的数据的预期，需要设置300个分区，分区键分别是： 12345678000|001|002|...156|157|...298| 我们将rowkey前三位作为分区号，那么为了保证随机性，我们如何将数据散列分布在这300个分区内呢？即我们如何设计rowkey以保证数据会随机分布在300个分区中？ 此外根据业务需求，我们最好将同一拨出号码的同一个月份的通话记录放在一个分区内，以便以后做计算更快。 我们设计这样一个算法： 因此有300个分区，因此我们将rowkey的前三位作为分区号，从第4位开始，我们将拨出号码作为字符串拼接进去，再将通话开始时间拼接进去，以下划线分割，如下： 1xxx_13112345678_2021-01-01 12:12:12 那么如何将这个rowkey随机分布到300个分区中且同一拨出号码同一月份的通话记录在同一分区呢？即rowkey前面的xxx要根据后面的13112345678_2021-01-01 12:12:12来区分。 首先，不同的手机号可以随机区分开，因此可以用手机号进行hash，这样不同手机号的hashcode是随机分布的 其次，同一拨出号码的同一月份要放一起，因此可以将手机号+年月进行hash，这样同一手机号同一月份的hashcode是相同的 最后，我们只需要三位数字来存储分区号，因此我们可以通过获取hashcode除以299的余来获取分区号 1分区号=(hash(13112345678_202101))%299 技巧：我们对分区键的设计可以用一个常用符号中ascii序号最大的符号为结尾，如|，而rowkey中以一个ascii序号小点的符号为分隔符，如_。这样000|就会大于任意以000_开始的值。且我们在扫描表时，是左闭右开的原则，这样做对于rowkey的比较起来更方便，如下。 123456# 扫描001分区的数据STARTKEY =&gt; &#x27;001&#x27;, STOPKEY =&gt; &#x27;001|&#x27;# 扫描某拨出号码在4月份的数据STARTKEY =&gt; &#x27;XXX_13112345678_202103&#x27;, STOPKEY =&gt; &#x27;XXX_13112345678_202103|&#x27;# 其中xxx=(hash(13112345678_202103))%299 4、基础优化（1）允许在HDFS的文件中追加内容 hdfs-site.xml、hbase-site.xml 属性：dfs.support.append 解释：开启HDFS追加同步，可以优秀地配合HBase的数据同步和持久化。默认值为true。 （2）优化DataNode允许的最大文件打开数 hdfs-site.xml 属性：dfs.datanode.max.transfer.threads 解释：","categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"},{"name":"hbase","slug":"hbase","permalink":"https://yury757.github.io/tags/hbase/"}]},{"title":"springMVC-study","slug":"java/springMVC/SpringMVC-Study","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-24T09:02:17.989Z","comments":true,"path":"/java/springMVC/SpringMVC-Study","link":"","permalink":"https://yury757.github.io/java/springMVC/SpringMVC-Study","excerpt":"","text":"一、回顾Servlet12345// 转发，forwardrequest.getRequestDispatcher(&quot;/WEB-INF/jsp/hello.jsp&quot;).forward(request, response);// 重定向，redirectresponse.sendRedirect(&quot;/index.jsp&quot;); 1234&lt;!-- session失效时间，单位分钟 --&gt;&lt;session-config&gt; &lt;session-timeout&gt;1&lt;/session-timeout&gt;&lt;/session-config&gt; 二、SpringMVC开始1、前言约定大于配置。 最重要的一个类：DispatcherServlet 1234567891011public class DispatcherServlet extends FrameworkServlet&#123; public DispatcherServlet(WebApplicationContext webApplicationContext) &#123; super(webApplicationContext); setDispatchOptionsRequest(true); &#125; protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;&#125; protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;&#125; &#125; 这个类的作用就是就是把不同的请求分发到不同的类。 2、配置springmvc（重要！）1、web.xml123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 开始配置SpringMVC --&gt; &lt;!-- 1、注册DispatcherServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联一个springmvc配置文件，本质是一个spring配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动级别 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- / 和 /* 是有区别的，用/，不能用/* / ：匹配所有请求，不会匹配jsp /* ：匹配所有请求，包括jsp，即把返回一个.jsp页面也当作了一个请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 2、springmvc-config.xml本质是一个spring配置文件 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 处理器映射器，有多种映射器 --&gt; &lt;!-- 这种映射器是通过bean的名字查找 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot; /&gt; &lt;!-- 处理器适配器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot; /&gt; &lt;!-- 视图解析器，配置了前后缀，以后重定向到某个jsp时就可以不用写前后缀了 --&gt; &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置handler --&gt; &lt;!-- 上面那个映射器会去查找和url名字相同的bean id --&gt; &lt;!-- 找到之后上面那个适配器就会把请求交给对应bean的class去处理 --&gt; &lt;bean id=&quot;/hello2&quot; class=&quot;org.yuyr757.controller.Hello2Controller&quot;/&gt;&lt;/beans&gt; 如下图 配置处理器映射器就是为了做2、3、4三步，去找到对应的handler 配置处理器适配器就是为了做5、6、7、8四步，把对应的handler交给controller处理 配置视图解析器就是为了做9、10、11、12四步，把controller处理好的带model和view名字的MV对象交给视图解析器，先去处理对应的jsp，然后把生成好的页面返回给浏览器。 3、配置springmvc时404的问题原因之一可能是：IDEA的项目结构中的Artifacts的utput Layout要确保WEB-INF目录下有classes和lib两个目录，若没有lib目录，则新建一个，然后把所有我们的依赖包放到lib目录中。 4、使用springmvc这里是采用实现Controller接口的方式，不建议使用，建议使用下面注解开发。 12345678910111213141516171819202122232425package org.yuyr757.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;// 注意！！这个Controller是org.springframework.web.servlet.mvc.Controller，是一个接口// 而不是org.springframework.stereotype.Controller，这个Controller是注解用的public class Hello2Controller implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // 模型和视图 ModelAndView mv = new ModelAndView(); // 封装对象 mv.addObject(&quot;msg&quot;, &quot;HelloSpringMVC&quot;); // 封装要跳转的对象 mv.setViewName(&quot;hello2&quot;); System.out.println(&quot;---&quot;); return mv; &#125;&#125; 三、使用注解开发SpringMVCweb.xml中的配置不变，springmvc-config.xml中的配置如下： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效，由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;org.yuye757.controller&quot;/&gt; &lt;!-- 配置对url的检查，将一些静态资源交给默认的Servlet处理，非静态资源才让DispatcherServlet处理 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 开启注解 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器，配置了前后缀，以后重定向到某个jsp时就可以不用写前后缀了 --&gt; &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021222324package org.yuye757.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/hello&quot;) // 不写的话，就直接走方法的mapping uripublic class HelloController &#123; @RequestMapping(&quot;/h1&quot;) // 如果没有配置restful，这里一定要写，不写则找不到这个方法的uri // uil为：localhost:8080/warName/hello/h1 public String index(Model model)&#123; // 封装数据 model.addAttribute(&quot;msg&quot;, &quot;Hello, SpringMVC Annotation!&quot;); String viewName = &quot;hello&quot;; // 加了@Controller注解的类下的所有加了@RequestMapping的方法 // 若返回的类型是字符串，且能够找到对应的jsp，就会被视图解析器处理 // /WEB-INF/jsp/$&#123;viewName&#125;.jsp return viewName; &#125;&#125; 四、restful风格的urijsp不支持DELETE、PUT类型的方法，以下那两个方法看看即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package org.yuye757.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;@Controller@RequestMapping(&quot;/restful&quot;)public class RestfulController &#123; // 原来的方式：localhost:8080/warName/test?a=1&amp;b=2 @RequestMapping(&quot;/test&quot;) public String test(Model model, int a, int b)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;, res); return &quot;test&quot;; &#125; // restful方式：localhost:8080/warName/test/1/2 // @RequestMapping(value = &quot;/test2/&#123;a&#125;/&#123;b&#125;&quot;, method = RequestMethod.GET) @GetMapping(&quot;/test2/&#123;a&#125;/&#123;b&#125;&quot;) public String test2(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;, &quot;GET方法：&quot; + res); return &quot;test&quot;; &#125; // restful方式：localhost:8080/warName/test/1/2 // @RequestMapping(value = &quot;/test2/&#123;a&#125;/&#123;b&#125;&quot;, method = RequestMethod.POST) @PostMapping(&quot;/test2/&#123;a&#125;/&#123;b&#125;&quot;) public String test3(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a - b; model.addAttribute(&quot;msg&quot;, &quot;POST方法：&quot; + res); return &quot;test&quot;; &#125; // restful方式：localhost:8080/warName/test/1/2 // @RequestMapping(value = &quot;/test2/&#123;a&#125;/&#123;b&#125;&quot;, method = RequestMethod.PUT) @PutMapping(&quot;/test2/&#123;a&#125;/&#123;b&#125;&quot;) public String test4(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a * b; model.addAttribute(&quot;msg&quot;, &quot;PUT方法：&quot; + res); return &quot;test&quot;; &#125; // restful方式：localhost:8080/warName/test/1/2 // @RequestMapping(value = &quot;/test2/&#123;a&#125;/&#123;b&#125;&quot;, method = RequestMethod.DELETE) @DeleteMapping(&quot;/test2/&#123;a&#125;/&#123;b&#125;&quot;) public String test5(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a / b; model.addAttribute(&quot;msg&quot;, &quot;DELETE方法：&quot; + res); return &quot;test&quot;; &#125;&#125; 五、springmvc使用细节1、转发和重定向可以在方法中加入request、response参数，使用servlet原生的转发或重定向方式。 在springmvc中可以这样： 1234567891011121314151617181920212223package org.yuye757.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controller@RequestMapping(&quot;/modelTest&quot;)public class ModelTest1 &#123; @PostMapping(value = &quot;/test1&quot;) public ModelAndView test()&#123; ModelAndView mv = new ModelAndView(); // 重定向：redirect mv.setViewName(&quot;redirect:/restful/test2/10/5&quot;); // 转发：forward // mv.setViewName(&quot;forward:/restful/test2/10/5&quot;); return mv; &#125;&#125; 注意：通过这种方式的转发会带上方法的类型，如POST、PUT。但是重定向不会，默认是GET方法。因为重定向实际上是重新发起了一次请求，因此默认是GET。 2、参数12345678910111213141516171819202122232425262728293031323334353637383940package org.yuye757.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.yuye757.pojo.User;@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @GetMapping(&quot;/t1&quot;) // 若有@RequestParam，则前端传入的参数以注解里面的名字为准，此时变量名失效。没有的话就只能用变量名。 // 建议都加上@RequestParam，这样可以很明显的告诉别人这是要从前端接收的参数 // http://localhost:8080/user/t1?username=123456 public String test1(Model model, @RequestParam(&quot;username&quot;) String name)&#123; System.out.println(&quot;前端接收到的参数：&quot; + name); model.addAttribute(&quot;msg&quot;, name); return &quot;test&quot;; &#125; /* 1、若参数为普通类型，则通过方法的参数名字和url的参数名字匹配 2、若参数为对象，则会调用无参构造方法，再按照对象属性名和url的参数名去匹配，匹配到的就会调用其setter方法 和url参数名没匹配上的属性或没有setter方法的属性则没有值 若没有无参构造方法，则调用有参构造方法。总之把pojo类的构造方法写全是最好的。 */ // http://localhost:8080/user/t2?id=1&amp;name=我是一个名字&amp;age=12 @GetMapping(&quot;/t2&quot;) public String test2(User user, Model model)&#123; String s = user.toString(); System.out.println(s); model.addAttribute(&quot;msg&quot;, s); return &quot;test&quot;; &#125;&#125; 3、乱码配置web.xml 123456789101112131415&lt;!-- 之前我们自己写filter来解决乱码问题 --&gt;&lt;!-- 在springmvc中，他给我们写了一个过滤器来解决乱码 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;!-- 注意这里要用/*，之前上面说了/*可以把jsp资源也包括在处理范围类 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 4、返回值（1）让方法返回一个纯字符串给前端，而不是走视图解析器 在类上面加@RestController，这个注解可以使类中的所有方法都返回字符串，而不是走视图解析器 在方法上面加@ResponseBody注解 （2）返回json字符串 使用jackson包 1234567891011121314151617181920212223package org.yuyr757.controller;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import org.yuyr757.User.User;// @RestController这个注解可以使类中的所有方法都返回字符串，而不是走视图解析器@RestControllerpublic class UserController &#123; @ResponseBody // 使用这个注解，则不会走视图解析器，而是直接返回一个字符串 // produces = &quot;application/json;charset=utf-8&quot;，加上这个指明返回的页面格式和编码 @RequestMapping(value = &quot;/user/j1&quot;) public String json2() throws JsonProcessingException &#123; User user = new User(1, &quot;你好&quot;, 2); ObjectMapper objectMapper = new ObjectMapper(); // 使用jackson包 String s = objectMapper.writeValueAsString(user); return s; &#125;&#125; 使用fastjson包 123456789101112131415161718192021222324@RequestMapping(&quot;/user/j4&quot;)public String json4() throws JsonProcessingException &#123; List&lt;Object&gt; list = new ArrayList&lt;&gt;(); User user = new User(1, &quot;名字&quot;, 2); list.add(user); // 原生日期格式 Date date = new Date(); list.add(date); // 通过java.text.DateFormat的格式化 ObjectMapper objectMapper = new ObjectMapper(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); list.add(simpleDateFormat.format(date)); // 通过jackson格式化 ObjectMapper objectMapper2 = new ObjectMapper(); objectMapper2.setDateFormat(simpleDateFormat); String s2 = objectMapper2.writeValueAsString(date); list.add(s2); return JSON.toJSONString(list, &quot;yyyy-MM-dd HH:mm:ss&quot;); // 使用fastjson&#125; （3）使用jackson包返回json字符串到前端后乱码问题 在@RequestMapping注解里面加入produces参数 1@RequestMapping(value = &quot;/user/j1&quot;, produces = &quot;application/json;charset=utf-8&quot;) 在springmvc-config.xml中配置jackson独有的配置（建议使用） 123456789101112131415&lt;!--Jackson乱码解决--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; （4）在前端使用json 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var user = &#123; name: &quot;yuyr757&quot;, age: 2, sex: &quot;男&quot; &#125;; console.log(user); console.log(&quot;---------将对象解析为json----------&quot;); var value = JSON.stringify(user); console.log(value); console.log(&quot;---------将json解析为对象----------&quot;); var object = JSON.parse(value); console.log(object);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、拦截器和过滤器拦截器：拦截器只会拦截访问的控制器方法，如果访问的是jsp、html、css、image、js是不会被拦截的。实现了HandlerInterceptor接口的类就是拦截器。拦截器是AOP思想的一个具体应用。 过滤器：在web.xml中配置的Filter就是过滤器，url_pattern配置了/*会对所有资源进行过滤。 登录拦截示例： 1234567891011121314151617181920212223242526272829303132package org.yuye757.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controllerpublic class LoginController &#123; @RequestMapping(&quot;/login&quot;) public String login(String username, String password, HttpSession session)&#123; session.setAttribute(&quot;username&quot;, username); return &quot;main&quot;; &#125; @RequestMapping(&quot;/goLogin&quot;) public String goLogin()&#123; return &quot;login&quot;; &#125; @RequestMapping(&quot;/main&quot;) public String main()&#123; return &quot;main&quot;; &#125; @RequestMapping(&quot;/logout&quot;) public String logout(HttpSession session)&#123; session.removeAttribute(&quot;username&quot;); return &quot;redirect:/main&quot;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637package org.yuye757.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor &#123; // return true即放行，return false则阻断 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); System.out.println(request.getRequestURI()); if (request.getRequestURI().contains(&quot;Login&quot;) || request.getRequestURI().contains(&quot;login&quot;))&#123; return true; &#125; if (session.getAttribute(&quot;username&quot;) != null)&#123; return true; &#125; request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response); return false; &#125; // 下面两个不会返回值，一般用于其他处理，如日志，或者直接删掉也可以 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;org.yuye757.interceptor.LoginInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 七、文件上传和下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package org.yuye757.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.*;import java.net.URLEncoder;@Controllerpublic class FileUploader &#123; @RequestMapping(&quot;/upload&quot;) public String upload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpSession session) throws IOException &#123; String filename = file.getOriginalFilename(); if (&quot;&quot;.equals(filename))&#123; return &quot;redirect:/index.jsp&quot;; &#125; System.out.println(&quot;上传文件名：&quot; + filename); // 上传路径保存设置 String path = session.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); // 如果路径不存在，则创建一个 File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; System.out.println(&quot;上传文件保存地址：&quot; + realPath); // 创建流 InputStream is = file.getInputStream(); OutputStream os = new FileOutputStream(realPath + &quot;\\\\&quot; + filename); // 读写 int len = 0; byte[] buffer = new byte[1024]; while((len = is.read(buffer)) &gt; 0)&#123; os.write(buffer, 0, buffer.length); os.flush(); &#125; os.close(); is.close(); return &quot;redirect:/index.jsp&quot;; &#125; @RequestMapping(&quot;/upload2&quot;) public String upload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpSession session) throws IOException &#123; String filename = file.getOriginalFilename(); if (&quot;&quot;.equals(filename))&#123; return &quot;redirect:/index.jsp&quot;; &#125; System.out.println(&quot;上传文件名：&quot; + filename); // 上传路径保存设置 String path = session.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); // 如果路径不存在，则创建一个 File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; System.out.println(&quot;上传文件保存地址：&quot; + realPath); // 通过CommonsMultipartFile的方法直接写入文件 file.transferTo(new File(path + &quot;/&quot; + filename)); return &quot;redirect:/index.jsp&quot;; &#125; @RequestMapping(&quot;/download1&quot;) public void download1(HttpServletRequest request, HttpServletResponse response, String filename) throws IOException &#123; String path = request.getSession().getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;); response.reset(); // 设置页面不缓存，清空buffer response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;multipart/form-data&quot;); // 设置响应头 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(filename, &quot;utf-8&quot;)); File file = new File(path + &quot;\\\\&quot; + filename); System.out.println(&quot;下载文件为：&quot; + file.toString()); // 读取文件流 InputStream is = new FileInputStream(file); // 输出文件流 OutputStream os = response.getOutputStream(); // 读写 int len = 0; byte[] buffer = new byte[1024]; while((len = is.read(buffer)) &gt; 0)&#123; os.write(buffer, 0, buffer.length); os.flush(); &#125; os.close(); is.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yury757.github.io/tags/spring/"}]},{"title":"springboot-study","slug":"java/springboot/springboot-study","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-24T09:06:45.735Z","comments":true,"path":"/java/springboot/springboot-study","link":"","permalink":"https://yury757.github.io/java/springboot/springboot-study","excerpt":"","text":"约定大于配置！！ 版本：SpringBoot-2.4.3 一、springboot使用简介（1）pom.xmlpom.xml的依赖都在父工程中spring-boot-dependencies中，我们在引入一些springboot依赖时，可以不需要指定版本，因为父工程中指定了建议的版本。也可以写版本号使用我们自己的版本号。 （2）启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 就是一个个功能的开关，我们要使用某个功能，找到相应的启动器starter打开就可以了。如下官网提供了很多启动器： https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/using-spring-boot.html#using-boot-starter （3）启动类springboot为我们写了一个默认的启动类，该启动类加了@SpringBootApplication注解，这个注解主要由以下三个注解组成。 @SpringBootConfiguration：表示这是一个配置类 @EnableAutoConfiguration：启用自动装配 @ComponentScan：组件扫描，自动注册bean 以上三个注解不是必需的，即我们可以挑选使用我们自己需要的功能，或者使用其他注解来启动应用。如下，我们不启用组件扫描，配置了一个属性，还导入了我们自定义的其他配置类。 1234567891011121314151617package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.context.annotation.ComponentScanimport org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration(proxyBeanMethods = false)@EnableAutoConfiguration@Import(&#123; MyConfig.class, MyAnotherConfig.class &#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; （4）运行程序12345# 使用jar包直接运行java -jar target/myapplication-0.0.1-SNAPSHOT.jar# 使用maven运行mvn spring-boot:run （5）自动配置Spring Boot自动配置会尝试根据您添加的jar依赖项自动配置您的Spring应用程序。 例如，如果HSQLDB位于类路径上，并且尚未手动配置任何数据库连接bean，则Spring Boot会自动配置内存数据库。springboot支持的自动配置类如下： https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/appendix-auto-configuration-classes.html 可以在配置文件中加入以下设置查看哪些自动配置生效了，哪些没生效。 1debug: true （6）手动配置当我们不想用某个依赖的自动配置时，我们可以在我们的启动程序中加上exclude=&#123;DataSourceAutoConfiguration.class&#125;来排除，然后在配置文件中写上我们需要的配置。其实不用排除也可以，springboot中的自动配置有默认值，直接在配置文件中写我们需要的配置，会覆盖默认值。springboot自动配置的默认值如下： https://docs.spring.io/spring-boot/docs/2.4.3/reference/html/appendix-application-properties.html 123456import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyApplication &#123;&#125; 配置文件中可以写的配置属性从哪里来？（重要！！） 打开下面这个文件 1\\org\\springframework\\boot\\spring-boot-autoconfigure\\2.4.3\\spring-boot-autoconfigure-2.4.3.jar!\\META-INF\\spring.factories 都是一个个的xxxAutoConfiguration类，点进去基本都会有以下几个注解： 12345678910111213// 表明这是一个配置类，即在spring中讲的使用配置类来配置bean@Configuration(proxyBeanMethods = false)// 条件：必须加载了某个类，这个自动配置类才会生效@ConditionalOnClass(KafkaTemplate.class)// 使用某个属性类当作自动配置的属性@EnableConfigurationProperties(KafkaProperties.class)// 点进去上面那个xxxProperties.class，可以发现这里面有很多属性// 且有下面这个注解，这个注解的功能就是将我们的配置文件的属性和这个类中的属性绑定（参考下面的“使用yaml给bean注入属性”）@ConfigurationProperties(prefix = &quot;spring.kafka&quot;)public class KafkaProperties&#123;&#125; 即xxxAutoConfiguration类就是一个个的配置类，目的是实例化一个个的bean；而xxxProperties类就是属性类，为示例化bean提供属性值，我们在配置文件中可以写的属性就是xxxProperties类中的属性。 （7）配置顺序（重要！！）springboot可以从很多地方来配置，官方给了一个配置的覆盖顺序，后面配置会覆盖前面的配置： 1234567891011121314151617181920212223242526271、Default properties (specified by setting SpringApplication.setDefaultProperties).2、@PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.3、（主要！）Config data (such as application.properties files)4、A RandomValuePropertySource that has properties only in random.*.5、OS environment variables.6、Java System properties (System.getProperties()).7、JNDI attributes from java:comp/env.8、ServletContext init parameters.9、ServletConfig init parameters.10、Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).11、Command line arguments.12、properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.13、@TestPropertySource annotations on your tests.14、Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active. 而第3点配置文件application.yaml可以放置在以下位置，加载顺序也是后面的配置会覆盖前面的配置： 12345671、classpath:/2、classpath:/config/3、file:/4、file:/config/ 多环境配置： 可以在文件名后面加对应环境，来设置对应环境的配置，即application-dev.yaml。然后在application.yaml中配置如下设置来修改配置文件： 123spring: profiles: active: dev 或者不用新建application-dev.yaml配置文件，而是直接在application.yaml中加入三根英文横线---来分隔文档版本，并且加上对应的环境，也可以进行配置切换。如下使用的就是dev环境。其实建议使用额外增加一个配置文件application-dev.yaml的形式。 1234567891011121314151617181920server: port: 8084spring: profiles: active: dev---server: port: 8085spring: profiles: dev---server: port: 8086spring: profiles: test 对于多环境配置的加载顺序，官网也还有一个顺序，也是后面的配置会覆盖前面的配置，如下： 12345671、Application properties packaged inside your jar (application.properties and YAML variants).2、Profile-specific application properties packaged inside your jar (application-&#123;profile&#125;.properties and YAML variants).3、Application properties outside of your packaged jar (application.properties and YAML variants).4、Profile-specific application properties outside of your packaged jar (application-&#123;profile&#125;.properties and YAML variants). 最佳的一种方式就是： 在classpath:/下的application.yaml中配置我们的应用，多环境则配置相应的application-&#123;profiles&#125;.yaml，然后启动项目时在命令行中加上spring.profiles.active参数。 二、YAML配置springboot会读取的数据配置文件只有application.properties、application.yaml这两个，修改了文件名则不会生效。 推荐使用yaml配置文件。 1、YAML语法具体语法见这里：https://www.ruanyifeng.com/blog/2016/07/yaml.html 注意点： YAML语法对空格的要求及其严格，一定要小心。 Key-Value键值对中，key后后面冒号后面一定要加一个空格！！ 缩进为两个空格，表示子属性，不能用tab符号。 其中引用的使用建议使用EL表达式，而不是&amp;、*，因为EL表达式不仅可以因为该文件内的属性，还可以引用springboot给我们设置好的其他属性。还可以使用类似三元运算符。 123number: $&#123;random.uuid&#125;version: $&#123;mysql.version&#125;number2: $&#123;value2:123&#125; # 若value2存在则使用value2的值，否则使用123 2、使用yaml给bean注入属性123456789101112131415person: name: yury757 age: 3 number: 10 happy: false birth: 2020/12/02 maps: k1: v1 k2: v2 lists: - code - music dog: name: 旺财3 age: 2 配置了yaml后可以直接在对应的类上面用以下注解，来给bean注入属性。这个注解的作用是将配置文件中的属性值，映射到这个类的属性上。prefix的值就是配置文件中的某一个Key。 1@ConfigurationProperties(prefix = &quot;person&quot;) 123456789101112@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123; private String name; private int age; private Integer number; private boolean happy; private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 加了这个注解后IDEA会有一个红色的提示，pom.xml中加入以下依赖，就不会有了。 123456&lt;!-- 用yaml注入对象属性值的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 这种方式需要对应的类有 无参构造方法 和 每个属性的setter方法，不然会报错。 3、JSR303校验即在属性上加一些注解可以对注入的值进行校验。 导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; 普通值校验 1234567891011121314@Min // 验证 Number 和 String 对象是否大等于指定的值 @Max // 验证 Number 和 String 对象是否小等于指定的值 @DecimalMax //被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度@DecimalMin //被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度@Digits //验证 Number 和 String 的构成是否合法 @Digits(integer=,fraction=) // 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。@Range(min=, max=) // 校验值的大小是否在给定的范围内（可包含）@Range(min=10000,max=50000,message=&quot;range.bean.wage&quot;)private BigDecimal wage;@Valid // 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)@CreditCardNumber // 信用卡验证@Email // 验证是否是邮件地址，如果为null,不进行验证，算通过验证。@ScriptAssert(lang= ,script=, alias=) // 脚本代码段验证，lang为哪种语言@URL(protocol=,host=, port=,regexp=, flags=) // url验证 空检查 1234@Null // 验证对象是否为null@NotNull // 验证对象是否不为null, 无法查检长度为0的字符串@NotBlank // 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty // 检查约束元素是否为NULL或者是EMPTY. Booelan检查 12@AssertTrue // 验证 Boolean 对象是否为 true @AssertFalse // 验证 Boolean 对象是否为 false 长度检查 12@Size(min=, max=) // 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内 @Length(min=, max=) // 验证string字符串的长度是否在给定的范围指内 日期检查 123@Past // 验证 Date 和 Calendar 对象是否在当前时间之前 @Future // 验证 Date 和 Calendar 对象是否在当前时间之后 @Pattern // 验证 String 对象是否符合正则表达式的规则 三、使用springboot开发web12345678910111213141516171819202122232425262728293031&lt;!-- web启动器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 用yaml注入对象属性值 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- 属性校验 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- thymeleaf模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 系统功能监控、统计相关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 单元测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt; 1、静态资源存放位置（1）webjars静态资源（一般不这么用） 从webjars导入的静态资源的访问路径是：classpath + 导入的webjars包在META-INF/resources/后面的路径。 （2）其他静态资源 （从左到右优先级依次降低，即同一个静态资源，会先拿最左边的）： 1&#123;&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&#125; 配置文件中，以下配置的默认值是/**，即把类路径当作根目录，再去找上面的三个文件夹。若修改了这里，比如改成了/test/**，则要通过/test/这个路径才能找到对应的资源。所以千万不要设置下面这个配置。 123spring mvc static-path-pattern: /** 即我们只要将静态资源放在resources、static、public下的任意一个位置就可以了，按照自己喜好分类放置。 注意template目录和外部的目录是无法直接访问到的。 2、模板引擎（1）thymeleaf pom.xml依赖 若springboot版本没有thymeleaf启动器，则引入以下依赖。 123456789&lt;!-- thymeleaf模板引擎，最好使用3.x --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;&lt;/dependency&gt; 如有启动器，则直接引入启动器的依赖即可，引入以下依赖反而报错。 12345&lt;!-- thymeleaf模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 同样按上面的方法找到我们需要在配置文件中需要配置的属性，找到下面这个类 123456789101112131415161718192021@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = DEFAULT_PREFIX; private String suffix = DEFAULT_SUFFIX; private String mode = &quot;HTML&quot;; private Charset encoding = DEFAULT_ENCODING; private boolean cache = true; private Integer templateResolverOrder; private String[] viewNames; private String[] excludedViewNames; private boolean enableSpringElCompiler; private boolean renderHiddenMarkersBeforeCheckboxes = false; private boolean enabled = true; private final Servlet servlet = new Servlet(); private final Reactive reactive = new Reactive();&#125; 从上面可以看到thymeleaf使用的前缀是classpath:/templates/，后缀是.html，因此我们要把html文件放到templates目录下，才会生效。 在html中加入thymeleaf的命名空间，就可以使用thymeleaf的语法了。 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 一定要了解的thymeleaf语法： Variable Expression：$&#123;&#125; Selection Variable Expression：*&#123;&#125; Message Expression：#&#123;&#125; Link Url Expression：@&#123;&#125; Fragment Expression：~&#123;&#125; 3、自定义扩展webmvc 写一个配置类，要实现WebMvcConfigurer接口，并加上@Configuration注解 想加入一个自定义视图解析器，则自定义一个视图解析器类（视图解析器类要实现接口ViewResolver），然后定一个@bean的方法，返回这个类就注册好了。 想加入一个自定义拦截器，则定义一个拦截器（拦截器要实现接口HandlerInterceptor），然后重写addInterceptors方法，把拦截器注册进去，再配置好需要拦截的url pattern即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.yury757.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;// 自定义视图解析器步骤// 写一个配置类，要实现WebMvcConfigurer接口，并加上@Configuration注解@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; // 往IOC容器中注册一个bean @Bean public MyViewResolver getMyViewResolver()&#123; return new MyViewResolver(); &#125; // 自定义视图解析器 public static class MyViewResolver implements ViewResolver &#123; @Override public View resolveViewName(String viewName, Locale locale) throws Exception &#123; return null; &#125; &#125; // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()) .addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/*.js&quot;, &quot;/*.css&quot;); &#125; // 自定义拦截器 private static class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(request.getRequestURI()); return true; &#125; &#125;&#125; 4、国际化（i18n）sources目录下新建一个i18n目录，再新建以下三个配置文件（这里只能使用.properties，不能使用.yaml）： 123login.propertieslogin_en_US.propertieslogin_zh_CN.properties 会发现这三个被绑定在一起了，然后就可以像正常输入配置文件一样，在对应的语言配置中输入变量及对应语言的内容。 1234567891011121314151617181920# login.propertieslogin.btn=登录login.password=密码login.rememberMe=记住我login.tips=请登录login.username=用户名# login_en_US.propertieslogin.btn=Sign Inlogin.password=passwordlogin.rememberMe=remember melogin.tips=Please Login Inlogin.username=username# login_zh_CN.propertieslogin.btn=登录login.password=密码login.rememberMe=记住我login.tips=请登录login.username=用户名 然后在html中就可以使用这里面的变量，不同的模板引擎有不同的写法，如thymeleaf的写法是： 123456#&#123;login.tips&#125;&lt;div class=&quot;text-center mb-4&quot;&gt; &lt;img class=&quot;mb-4&quot; src=&quot;https://getbootstrap.com/docs/4.0/assets/brand/bootstrap-solid.svg&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot;&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#&#123;login.tips&#125;&quot;&gt;&lt;/h1&gt;&lt;/div&gt; 最后还要在webmvc组件中配置国际化处理器，以及将处理器注册到bean中的配置类，如下： 12345678910111213141516171819202122232425262728package com.yury757.config;import org.springframework.web.servlet.LocaleResolver;import org.thymeleaf.util.StringUtils;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Arrays;import java.util.Locale;// 国际化处理器public class MyLocaleResolver implements LocaleResolver &#123; // 解析请求，精简版，不能直接在工作中使用 @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); if (!StringUtils.isEmpty(l))&#123; String[] s = l.split(&quot;_&quot;); locale = new Locale(s[0], s[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123;&#125;&#125; 1234567891011121314151617181920212223package com.yury757.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MyWebMvcConfigurer implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;/index&quot;); registry.addViewController(&quot;/&quot;).setViewName(&quot;/index&quot;); &#125; // 注册bean，使用我们自己写的国际化组件 // 注意！！！！！这里方法名要用和类名一样，且首字母小写 @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 四、SpringBoot整合其他组件pom中以spring-boot-starter-开头的就是springboot官方的，以-spring-boot-starter结尾的就是对应组件的公司自己写的。 （1）整合Druid数据源123456789101112&lt;!-- log4j2 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- druid数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource druid: username: root password: root url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC # 最大等待时间，配置获取连接等待超时，时间单位都是毫秒ms max-wait: 60000 # 最大值 max-active: 20 #最小值 min-idle: 5 #初始化大小 initial-size: 5 #配置一个连接在池中最小生存的时间 min-evictable-idle-time-millis: 60000 #配置间隔多久才进行一次检测，检测需要关闭的空闲连接 time-between-eviction-runs-millis: 300000 test-on-borrow: false test-on-return: false test-while-idle: true pool-prepared-statements: true #最大PSCache连接 max-pool-prepared-statement-per-connection-size: 20 use-global-data-source-stat: true # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计， # wall用于防火墙 filter: stat: enabled: true wall: enabled: true log4j2: enabled: true # 配置StatFilter web-stat-filter: # 默认为false，设置为true启动 enabled: true exclusions: &quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot; # 配置StatViewServlet stat-view-servlet: url-pattern: &quot;/druid/*&quot; # 允许哪些ip login-username: root login-password: root # 禁止哪些ip deny: 192.168.1.102 # 是否可以重置 reset-enable: true # 启用 enabled: true （2）整合mybatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt; 123mybatis: type-aliases-package: com.yury757.pojo mapper-locations: classpath:mybatis/mapper/*.xml 12345678910111213141516171819202122package com.yury757.mapper;import com.yury757.pojo.User;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import org.springframework.web.bind.annotation.RequestParam;import java.util.List;@Mapper@Repositorypublic interface UserMapper &#123; public List&lt;User&gt; selectList(); public User selectById(@RequestParam(&quot;id&quot;) int id); public int addUser(User user); public int updateUser(User user); public int deleteUser(@RequestParam(&quot;id&quot;) int id);&#125; 五、网站安全这部分内容用过滤器和拦截器也可以做到，只是以下两个框架可以使我们的安全组件更高效更简化。 1、SpringSecurity功能：身份验证（Authentication）和访问控制（Authorization） 很重要的几个类或注解： WebSecurityConfigurerAdapter：想要自定义安全策略，只要继承这个类就可以，重写里面的方法即可 AuthenrcationManagerBuilder：自定义认证策略 @EnableWebSecurity：开启WebSecurity模式 1234567@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; super.configure(http); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.yury757.config;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import javax.sql.DataSource;@EnableWebSecuritypublic class MySecurityConfig extends WebSecurityConfigurerAdapter &#123; private DataSource dataSource; // 自定义授权规则 @Override protected void configure(HttpSecurity http) throws Exception &#123; // 首页所有人可以访问，功能页只有对应权限的人才能访问 http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;); // 没有权限，跳到登录页面 http.formLogin().loginPage(&quot;/toLogin&quot;).loginProcessingUrl(&quot;/login&quot;).defaultSuccessUrl(&quot;/index&quot;); // 使用自己的登录页面和自己的登录处理逻辑时，要禁用csrf防护 // 千万不要禁用csrf，及找其他方式处理登录页面 http.csrf().disable(); // 开启注销功能 http.logout(); // 开启“记住我”功能，实际上就是丢了一个“rememberMe”的cookie，默认保存两周 http.rememberMe(); &#125; // 自定义认证规则 // 在spring security5中，需要不能直接使用密码，要加密使用 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; // 这些数据正常应该从数据库里面读取 auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) .withUser(&quot;yury757&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;, &quot;vip3&quot;) .and() .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;, &quot;vip2&quot;, &quot;vip3&quot;) .and() .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;); &#125;&#125; 2、Shiro也是一个安全组件。可以脱离web使用。 重要的三个对象： Subject：应用代码直接交互的对象，即外部浏览器或爬虫调用我们服务器api的用户。 SecurityManager：安全管理器，管理所有的subject Realm：连接数据","categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"https://yury757.github.io/tags/springboot/"}]},{"title":"spring-study","slug":"java/spring/Spring-study","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-24T08:56:26.975Z","comments":true,"path":"/java/spring/Spring-study","link":"","permalink":"https://yury757.github.io/java/spring/Spring-study","excerpt":"","text":"代码地址：yury757/SpringStudy (github.com) spring：约定大于配置！ 一、IOC（控制反转）1、什么是IOC之前都是我们手动new一个对象（比如new一个Dao层对象），然后使用这个对象的属性的方法。 而IOC就是不用我们去new这个对象，我们只要定义一些配置，然后把创建对象的工作交给spring框架处理，我们需要使用时直接把对象从IOC容器中取出来即可。 因此IOC（控制反转）的含义就是：spring中，对象创建的权利从我们程序员手动创建控制管理，转变为由spring框架去创建控制管理。 DI（依赖注入）的含义就是：spring框架在创建类的实例时，这个类的所有属性需要私有化，并且设置getter、setter方法，spring框架就可以通过setter方法给对应属性注入值。若没有相应的setter方法，则会报错。 配置如下： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 使用spring来创建对象，在spring中，这些对象都叫做bean --&gt; &lt;!-- id：唯一id --&gt; &lt;!-- class：需要new的类型 --&gt; &lt;!-- property：对象的属性 --&gt; &lt;!-- property.name：对象属性名 --&gt; &lt;!-- property.value：对象属性设置值 --&gt; &lt;bean id=&quot;hello&quot; class=&quot;org.yuyr757.pojo.Hello&quot;&gt; &lt;property name=&quot;str&quot; value=&quot;spring_value&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 取出对象的代码如下： 12345// 获取spring的上下文对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);// 我们的对象都在spring管理，我们要使用的话，直接去spring容器里面取Hello hello = (Hello)context.getBean(&quot;hello&quot;);System.out.println(hello.toString()); 和Mybatis有点像，都是通过配置文件来配置创建对象所需要的东西，然后把创建对象的工作交给框架来做。 只不过Mybatis是根据接口创建对象，这个对象的类型的java代码我们甚至没写过，而且对象里面只有方法（CRUD）。而spring的创建对象只是单纯的根据我们写好的java类去new一个实例，然后我们需要什么就取什么。 2、通过bean创建对象的四种方式123456789101112131415161718192021222324&lt;!-- 无参构造，再调用相应属性的setter方法 --&gt;&lt;bean id=&quot;user1&quot; class=&quot;org.yuyr757.pojo.User&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;test_user_name1&quot;/&gt;&lt;/bean&gt;&lt;!-- 有参构造，使用构造方法参数下标 --&gt;&lt;bean id=&quot;user2&quot; class=&quot;org.yuyr757.pojo.User&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;2&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;test_user_name2&quot;/&gt;&lt;/bean&gt;&lt;!-- 有参构造，使用构造方法参数类型 --&gt;&lt;!-- 不建议使用 --&gt;&lt;bean id=&quot;user3&quot; class=&quot;org.yuyr757.pojo.User&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;3&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;test_user_name3&quot;/&gt;&lt;/bean&gt;&lt;!-- 有参构造，使用构造方法参数参数名 --&gt;&lt;bean id=&quot;user4&quot; class=&quot;org.yuyr757.pojo.User&quot;&gt; &lt;constructor-arg name=&quot;id&quot; value=&quot;4&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;test_user_name4&quot;/&gt;&lt;/bean&gt; 3、spring创建对象的时间值得注意的是，bean默认为单例模式。对于单例模式的bean，当程序启动时，spring就会立即给帮我们把对象创建好了，而不是等我们调用getBean时创建的。 12345678910111213141516171819202122232425262728293031323334353637package org.yuyr757.pojo;public class User &#123; private int id; private String name; public User() &#123; System.out.println(&quot;调用了无参构造方法&quot;); &#125; public User(int id, String name) &#123; System.out.println(&quot;调用了有参构造方法&quot;); this.id = id; this.name = name; &#125; public String getName() &#123; System.out.println(&quot;调用了getName方法&quot;); return name; &#125; public void setName(String name) &#123; System.out.println(&quot;调用了setName方法&quot;); this.name = name; &#125; public int getId() &#123; System.out.println(&quot;调用了getId方法&quot;); return id; &#125; public void setId(int id) &#123; System.out.println(&quot;调用了setId方法&quot;); this.id = id; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122232425262728293031public class TestHello &#123; public static final ApplicationContext context; static&#123; context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); // 在这里打断点调试 // 上面这条语句结束后，就立即打印了下面几句话 // 调用了无参构造方法 // 调用了setId方法 // 调用了setName方法 // 调用了有参构造方法 // 调用了有参构造方法 // 调用了有参构造方法 &#125; @Test public void testUser()&#123; System.out.println(&quot;=============================&quot;); User user1 = (User)context.getBean(&quot;user1&quot;); System.out.println(user1.toString()); System.out.println(&quot;=============================&quot;); User user2 = (User)context.getBean(&quot;user2&quot;); System.out.println(user2.toString()); System.out.println(&quot;=============================&quot;); User user3 = (User)context.getBean(&quot;user3&quot;); System.out.println(user3.toString()); System.out.println(&quot;=============================&quot;); User user4 = (User)context.getBean(&quot;user4&quot;); System.out.println(user4.toString()); System.out.println(&quot;=============================&quot;); &#125;&#125; 4、spring配置文件（1）bean标签 id：唯一id，用于获取到这个对象的id class：需要new的类型，要写全限定类名 property：定义对象的属性的标签 constructor-arg：定义构造函数的标签 name：对象属性名或构造函数的参数名 value：普通值 ref：引用一个bean array：注入一个数组 list：注入一个列表 map：注入一个映射表 set：注入一个集合 null：注入一个null指针 props：注入一个properties对象 scope：作用域 （2）import标签导入其他bean配置文件。 适用于团队开发，不同的人开发的bean不同，最终汇总的时候用一个applicationContext.xml引入各个bean.xml即可。 123&lt;import resource=&quot;beans.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;&lt;import resource=&quot;beans3.xml&quot;/&gt; 5、注入方式（1）普通方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package org.yuyr757.pojo;import java.util.*;public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, address=&quot; + address + &quot;, books=&quot; + Arrays.toString(books) + &quot;, hobbies=&quot; + hobbies + &quot;, card=&quot; + card + &quot;, games=&quot; + games + &quot;, info=&quot; + info + &quot;, wife=&#x27;&quot; + wife + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String[] getBooks() &#123; return books; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public List&lt;String&gt; getHobbies() &#123; return hobbies; &#125; public void setHobbies(List&lt;String&gt; hobbies) &#123; this.hobbies = hobbies; &#125; public Map&lt;String, String&gt; getCard() &#123; return card; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public Set&lt;String&gt; getGames() &#123; return games; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public Properties getInfo() &#123; return info; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public Student() &#123; &#125; public Student(String name, Address address, String[] books, List&lt;String&gt; hobbies, Map&lt;String, String&gt; card, Set&lt;String&gt; games, Properties info, String wife) &#123; this.name = name; this.address = address; this.books = books; this.hobbies = hobbies; this.card = card; this.games = games; this.info = info; this.wife = wife; &#125;&#125; 123456789101112131415161718192021222324252627package org.yuyr757.pojo;public class Address &#123; private String address; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;address=&#x27;&quot; + address + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Address() &#123; &#125; public Address(String address) &#123; this.address = address; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 测试特别复杂类型的注入 --&gt; &lt;bean id=&quot;student&quot; class=&quot;org.yuyr757.pojo.Student&quot;&gt; &lt;!-- 普通值，value --&gt; &lt;property name=&quot;name&quot; value=&quot;yuyr757&quot;/&gt; &lt;!-- bean注入，ref --&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!-- 数组注入，array --&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;三国演义&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!-- 列表注入，list --&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;写代码&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 映射表注入，map --&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;111111111111111111&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;222222222222222222&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 集合注入，set --&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;魂斗罗&lt;/value&gt; &lt;value&gt;冒险岛&lt;/value&gt; &lt;value&gt;七龙珠&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- null注入，null --&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!-- properties对象注入，props，注意和map的区别 --&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;U201300001&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;address&quot; class=&quot;org.yuyr757.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;我是一个地址&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; （2）拓展方式12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 以上加入这个这个拓展标签 --&gt; &lt;!-- xmlns:p=&quot;http://www.springframework.org/schema/p&quot; --&gt; &lt;!-- 加入这个标签后可以直接在后面使用 p:属性名 来定义属性 --&gt; &lt;bean id=&quot;user5&quot; class=&quot;org.yuyr757.pojo.User&quot; p:id=&quot;5&quot; p:name=&quot;user_test_5&quot;/&gt; &lt;!-- 以上加入这个这个拓展标签 --&gt; &lt;!-- xmlns:p=&quot;http://www.springframework.org/schema/c&quot; --&gt; &lt;!-- 加入这个标签后可以直接在后面使用 c:属性名/下标 来定义构造方法的参数的值 --&gt; &lt;bean id=&quot;user6&quot; class=&quot;org.yuyr757.pojo.User&quot; c:id=&quot;6&quot; c:name=&quot;user_test_6&quot;/&gt; &lt;bean id=&quot;user7&quot; class=&quot;org.yuyr757.pojo.User&quot; c:_0=&quot;7&quot; c:_1=&quot;user_test_7&quot;/&gt;&lt;/beans&gt; 6、bean的作用域（1）singleton Scope（单例，默认）从服务器启动到服务器消灭，全局只创建一个对象。当使用多线程时，多个线程拿到的是同一个对象（注意线程的安全）。 （2）prototype（多例）每次调用getBean方法，都会重新new一个对象。 （3）request、session、application这三个只能在web应用中使用，和servlet中的不同作用域的context差不多。 7、bean的自动装配即spring会在容器中自动寻找创建某个对象的依赖，并装配到这个对象的属性中。有以下方式： （1）在xml中显式配置 byName：在容器中自动查找对应属性的setter方法名中set后面的值相同的bean的id byType：在容器中自动查找对应属性类型相同的bean，使用这种方式，一定要保证相同类型的对象只有一个bean 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;org.yuyr757.pojo.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;org.yuyr757.pojo.Cat&quot;/&gt;&lt;!-- &lt;bean id=&quot;cat2&quot; class=&quot;org.yuyr757.pojo.Cat&quot;/&gt;--&gt; &lt;!-- byName：在容器中自动查找对应属性的setter方法名中set后面的值相同的bean的id --&gt; &lt;bean id=&quot;people1&quot; class=&quot;org.yuyr757.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;这是我的名字1&quot;/&gt; &lt;/bean&gt; &lt;!-- byType：在容器中自动查找对应属性类型相同的bean --&gt; &lt;!-- 当容器中有两个相同类型的对象时，不能使用byType --&gt; &lt;bean id=&quot;people2&quot; class=&quot;org.yuyr757.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;这是我的名字2&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; （2）使用注解要在applicationContext.xml中加入以下支持。 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; xml配置和注解的一般结合方式：在xml中配置bean，在注入属性时使用注解。 8、注解（1）普通注解 @Component：作用目标：类。把该类当作一个bean对象，即相当于在配置中加入了一个bean标签，默认单例。 @AutoWired：作用目标：很多，一般用于属性。为该属性通过setter方法注入一个值，相当于在配置文件中加入了一个property标签。先通过byType的方法注入的，当IOC容器中有多个相同类型的对象时，再使用byName的方式来注入，而这个name默认就是根据变量名来的。 @Qualifier：作用目标：很多，一般用于属性。通过byName自动注入，该注解有一个value属性，指定去找对应名字的bean。可以和@AutoWired配合使用。 @Resources：作用目标：很多，一般用于属性。相当于以上两个注解的结合。有一个name属性，用于匹配bean的名字，不填。 @value：作用目标：很多，一般用于属性。为该属性通过setter方法注入一个普通的确定的值。 （2）衍生注解 Repository：这是Component注解的别名，用于表示这个类是Dao层的类 Service：这是Component注解的别名，用于表示这个类是Service层的类 Controller：这是Component注解的别名，用于表示这个类是Controller层的类 Scope：作用域，singleton、prototype等 9、使用java类来配置spring即不需要再xml中配置spring，而是在一个SpringConfig类中配置。 @configuration：在类上加入这个注解，则表明这是一个配置类。 @Bean：在方法的的上面加这个注解，相当于xml中的一个bean标签，方法的名字就是bean标签的id，方法的返回值就是bean标签的class属性。 @Import：引入其他配置类 123456789101112131415161718192021222324252627package org.yuyr757.config;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.yuyr757.pojo.Address;import org.yuyr757.pojo.User;@Configuration@Import(MyConfig2.class)public class MyConfig &#123; @Bean public Address address()&#123; return new Address(&quot;1&quot;); &#125; @Bean public Address address2()&#123; return new Address(&quot;2&quot;); &#125; @Bean public User getUser()&#123; return new User(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package org.yuyr757.pojo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;public class User &#123; @Value(&quot;yuyr757&quot;) private String name; @Autowired private Address address; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, address=&quot; + address + &#x27;&#125;&#x27;; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public User() &#123; &#125; public User(String name, Address address) &#123; this.name = name; this.address = address; &#125;&#125; 二、AOPAOP：Aspect-Oriented Programming，面向切面编程 1、代理模式（1）静态代理角色： 抽象角色：一般使用接口或抽象类来解决 真实角色：被代理的角色 代理角色：代理真是角色，并做一些附属操作 客户：访问代理角色的人 以租房为例。 很多客户（租户）直接找到真实角色（房东），完成一个操作（租房）。但是要完成这个操作要很多其他繁琐的事情（比如每次都要带客户看房、签合同等），真实角色（房东）不想做这些他认为没有意义的操作。于是真实角色（房东）找到一个同样可以做这个操作（租房）的代理角色（中介），让代理角色（中介）去和客户（租户）完成看房、签合同等其他操作，真实角色（房东）就可以专心做租房这一个操作了。抽象角色指一类人，这类人都可以完成租房这个操作。在这里真实角色（房东）和代理角色（中介）都是同一类抽象角色。 注意在代码中理解四类角色。 示例一 12345package org.yuyr757.Demo1;// 抽象角色public interface Rent &#123; public void rent();&#125; 12345678910111213141516package org.yuyr757.Demo1;// 客户public class Client &#123; public static void main(String[] args) &#123; // 直接找房东租房 Host host = new Host(); host.rent(); System.out.println(&quot;======================&quot;); // 找中介租房 // 通过代理可以做一些附属操作 Proxy proxy = new Proxy(host); proxy.rent(); &#125;&#125; 1234567package org.yuyr757.Demo1;// 房东public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房东要出租房子&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package org.yuyr757.Demo1;// 中介public class Proxy implements Rent &#123; private Host host; public Host getHost() &#123; return host; &#125; public void setHost(Host host) &#123; this.host = host; &#125; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; public void seeHouse()&#123; System.out.println(&quot;中介带看房&quot;); &#125; public void payFee()&#123; System.out.println(&quot;收取中介费&quot;); &#125; public void rent() &#123; this.seeHouse(); host.rent(); this.payFee(); &#125;&#125; 示例二： 12345678package org.yuyr757.Demo2;public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 12345678910111213141516171819package org.yuyr757.Demo2;public class UserServiceImpl implements UserService&#123; public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344package org.yuyr757.Demo2;public class UserServiceProxy implements UserService&#123; private UserService userService; public UserServiceProxy() &#123; &#125; public UserServiceProxy(UserService userService) &#123; this.userService = userService; &#125; public UserService getUserService() &#123; return userService; &#125; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void add() &#123; log(&quot;使用了add&quot;); this.userService.add(); &#125; public void delete() &#123; log(&quot;使用了delete&quot;); this.userService.delete(); &#125; public void update() &#123; log(&quot;使用了update&quot;); this.userService.update(); &#125; public void query() &#123; log(&quot;使用了query&quot;); this.userService.query(); &#125; public void log(String message)&#123; System.out.println(message); &#125;&#125; 123456789package org.yuyr757.Demo2;public class Client &#123; public static void main(String[] args) &#123; UserServiceImpl userService = new UserServiceImpl(); UserServiceProxy userServiceProxy = new UserServiceProxy(userService); userServiceProxy.add(); &#125;&#125; 优点： 可以使真实角色专注他自己的业务，其他业务交给其他角色来做，实现了分工 有良好的扩展性，可以在不修改其他功能的基础上新增其他功能 缺点：一个真实角色就要产生一个代理角色，代码量会翻倍。有没有一种方法可以避免写这么多代理类，或者自动生成代理类。这就是动态代理。 （2）动态代理（十分重要！） 动态代理和静态代理的角色一样。 动态代理的代理角色（代理类）是动态生成的，不是我们自己写的。 动态代理有两类： 基于接口——JDK动态代理 基于类——cglib java字节码实现——javassist 需要了解两个类/接口： InvocationHandler：调用处理程序 Proxy：代理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public interface InvocationHandler &#123; /** * Processes a method invocation on a proxy instance and returns * the result. This method will be invoked on an invocation handler * when a method is invoked on a proxy instance that it is * associated with. * * @param proxy （代理实例，即生成的代理对象，要用该对象去调用某个方法）the proxy instance that the method was invoked on * * @param method （在代理实例上调用的接口方法的实例，即要调用的方法）the &#123;@code Method&#125; instance corresponding to * the interface method invoked on the proxy instance. The declaring * class of the &#123;@code Method&#125; object will be the interface that * the method was declared in, which may be a superinterface of the * proxy interface that the proxy class inherits the method through. * * @param args （参数数组）an array of objects containing the values of the * arguments passed in the method invocation on the proxy instance, * or &#123;@code null&#125; if interface method takes no arguments. * Arguments of primitive types are wrapped in instances of the * appropriate primitive wrapper class, such as * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;. * * @return the value to return from the method invocation on the * proxy instance. If the declared return type of the interface * method is a primitive type, then the value returned by * this method must be an instance of the corresponding primitive * wrapper class; otherwise, it must be a type assignable to the * declared return type. If the value returned by this method is * &#123;@code null&#125; and the interface method&#x27;s return type is * primitive, then a &#123;@code NullPointerException&#125; will be * thrown by the method invocation on the proxy instance. If the * value returned by this method is otherwise not compatible with * the interface method&#x27;s declared return type as described above, * a &#123;@code ClassCastException&#125; will be thrown by the method * invocation on the proxy instance. * * @throws Throwable the exception to throw from the method * invocation on the proxy instance. The exception&#x27;s type must be * assignable either to any of the exception types declared in the * &#123;@code throws&#125; clause of the interface method or to the * unchecked exception types &#123;@code java.lang.RuntimeException&#125; * or &#123;@code java.lang.Error&#125;. If a checked exception is * thrown by this method that is not assignable to any of the * exception types declared in the &#123;@code throws&#125; clause of * the interface method, then an * &#123;@link UndeclaredThrowableException&#125; containing the * exception that was thrown by this method will be thrown by the * method invocation on the proxy instance. * * @see UndeclaredThrowableException */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 这个类提供了创建动态代理类和实例的方法，这个方法是静态的，通过这些方法创建的类都继承了Proxy这个类public class Proxy implements java.io.Serializable&#123; /* -------------------属性------------------- */ // final的属性基本都不用管，因为我们无法做修改 private static final long serialVersionUID = -2222568056686623797L; private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;; private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); private static final Object key0 = new Object(); // 这个是我们需要传入的对象，就是上面说的那个接口类 protected InvocationHandler h; /* -------------------构造方法------------------- */ private Proxy() &#123;&#125;; protected Proxy(InvocationHandler h); /* -------------------静态方法------------------- */ // 生成代理类，会调用getProxyClass0方法 @CallerSensitive public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces); // 检查代理权限 private static void checkProxyAccess(Class&lt;?&gt; caller, ClassLoader loader, Class&lt;?&gt;... interfaces); // 重要！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ // 从类加载器中生成一个代理类，文档说生成代理类之前必须检查代理权限（checkProxyAccess） private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces); // 重要！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ // 生成一个代理类的实例 // loader：真实对象（目标对象）的类加载器 // interfaces：真实对象（目标对象）的接口组成的数组 // h：实现了上面那个InvocationHandler接口的对象 @CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h); // 检查caller类和proxyclass类是否在同一个包内，如果不在同一个包内，再检查相关权限 private static void checkNewProxyPermission(Class&lt;?&gt; caller, Class&lt;?&gt; proxyClass); // 判断一个类是否是一个由Proxy类生成的代理类 public static boolean isProxyClass(Class&lt;?&gt; cl); // 传入一个对象参数，取出这个对象中的InvocationHandler属性，就是上面的h public static InvocationHandler getInvocationHandler(Object proxy); // native，非java实现，不用管 private static native Class&lt;?&gt; defineClass0(ClassLoader loader, String name, byte[] b, int off, int len); /* -------------------内部private类------------------- */ private static final class Key1 extends WeakReference&lt;Class&lt;?&gt;&gt;&#123;&#125; private static final class Key2 extends WeakReference&lt;Class&lt;?&gt;&gt;&#123;&#125; private static final class KeyX&#123;&#125; private static final class KeyFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt;&#123;&#125; // 创建代理类的工厂，如果工厂中有相应接口的代理类的缓存，则会返回一个代理类的复制，否则会重新创建一个代理类 private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123;&#125;&#125; 动态代理的本质：JVM在运行时动态创建class字节码并加载的过程。要实现的接口和调用接口方法的handler，可以生成一个class字节码，然后由对应的类加载器加载calss字节码，就可以在内存中生成一个类对象（代理类）了。当代理对象调用对应方法时，handler会将方法转发给自己的invoke方法。于是我们就可以在invoke方法中加入增强方法的代码。 用动态代理来增强示例二如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package org.yuyr757.DynamicProxy2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyInvocationHandler implements InvocationHandler &#123; private Object target; /** * 设置真实对象，相当于代理对象要和真实对象签定委托代理的契约，代理对象才可以有权限对做真实对象才能做的事情 * 就像现实生活中，租房中介要拿到房东的授权委托书，中介才可以有权去代理房东租房 */ public void setTarget(Object target) &#123; this.target = target; &#125; public ProxyInvocationHandler() &#123; &#125; public ProxyInvocationHandler(Object target) &#123; this.target = target; &#125; /** * 生成一个代理对象，即生成一个租房中介 * @loader 这个中介的类加载器和房东是一样的，即他们的级别是一样的 * @interfaces 这个中介的接口和房东是一样的，即他们都应该有相同的动作 * @h 这个中介拿到一个InvocationHandler对象，即每当客户有租房的动作时，租房的动作会通过InvocationHandler转发到自己的invoke方法，代理对象就可以在invoker方法中做一些额外操作 * 此外newProxyInstance方法内部还会授予相关代理权限，不然任何一个没有权限的人都可以代理房东去租房 */ public Object getProxy()&#123; return Proxy.newProxyInstance( this.target.getClass().getClassLoader(), this.target.getClass().getInterfaces(), this ); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; this.log(method.getName()); Object returnObject = method.invoke(target, args); return returnObject; &#125; public void log(String msg)&#123; System.out.println(&quot;调用了&quot; + msg + &quot;方法&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.yuyr757.DynamicProxy2;import org.yuyr757.Demo2.UserService;import org.yuyr757.Demo2.UserServiceImpl;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Arrays;public class Client &#123; public static void main(String[] args) &#123; UserService userservice = new UserServiceImpl(); ProxyInvocationHandler handler = new ProxyInvocationHandler(userservice); UserService proxy = (UserService)handler.getProxy(); System.out.println(&quot;=============查看生成的类的具体信息=============&quot;); Class proxyClass = proxy.getClass(); System.out.println(&quot;类名称：&quot; + proxyClass.getName()); System.out.println(&quot;类加载器：&quot; + proxyClass.getClassLoader()); System.out.println(&quot;类接口：&quot; + Arrays.toString(proxyClass.getInterfaces())); System.out.println(&quot;类的父类：&quot; + proxyClass.getSuperclass()); System.out.println(&quot;public方法和父类的public方法：&quot;); for (Method method : proxyClass.getMethods()) &#123; System.out.println(method.toString()); &#125; System.out.println(&quot;所有本类的方法：&quot;); for (Method method : proxyClass.getDeclaredMethods()) &#123; System.out.println(method.toString()); &#125; System.out.println(&quot;所有本类的属性：&quot; ); for (Field declaredField : proxyClass.getDeclaredFields()) &#123; System.out.println(declaredField); &#125; System.out.println(&quot;=============测试方法=============&quot;); proxy.add(); proxy.delete(); proxy.update(); proxy.query(); System.out.println(&quot;=============代理其他实现了该接口的类只需要修改目标对象即可=============&quot;); handler.setTarget(new UserServiceImpl2()); UserService proxy2 = (UserService)handler.getProxy(); proxy2.add(); proxy2.delete(); proxy2.update(); proxy2.query(); &#125;&#125; 动态代理的优点：动态代理代理的是接口，一般是一类业务，所有实现了该接口的类都可以被代理，减少了代码量。 缺点：效率稍微低一些。因为要在运行时根据接口动态生成字节码，再重新加载字节码。 2、spring-aop几个重要概念： 切入点（pointcut）：即我们原有的功能或业务逻辑，一堆方法的集合 切面（aspect）：一个切入到我们原有功能里面的新功能的集合（模块），一个类 通知（advisor）：切面要完成的工作，即类中的方法 连接点（joinpoint）：在切入点具体执行的某一个方法 通知的五种类型： 前置通知（Before advice）：即在目标方法执行前加一个增强方法 正常返回通知（After returning advice）：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。 异常返回通知（After throwing advice）：在连接点抛出异常后执行。 返回通知（After (finally) advice）：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 环绕通知（Around advice）：即把目标方法包裹在该通知方法内，比如我们使用IDEA有一个快捷键是ctrl + alt + T，即用一个方法把目标方法包裹（surrounding）起来。使用这种通知时，要把目标方法传入我们的通知方法中。最强的通知类型，完全可以使用这一个通知，然后在通知方法里面定义具体的实现，来满足以上四个通知（下面有示例）。前四个通知和环绕通知最好不要一起使用， 即要么使用前四个通知，要么只使用环绕通知。若都使用了，比如同时使用了前置通知和环绕通知，则目标方法执行前的增强方法好像是根据xml配置的顺序决定的。反正别一起使用就对了。【！！！推荐使用环绕通知，自己写增强方法，因为在有返回值和报异常同时存在的情况下，环绕通知有更强的实现，以上四个通知都做不到】 （1）方式一：使用spring aop接口实现配置文件中不需要aspect，因为spring会去找实现了相应接口的类当作aspect，需要配置pointcut和advisor。 1234567891011&lt;!-- 配置AOP --&gt;&lt;!-- 方式一：使用原生spring aop的api接口 --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点，即需要增强的目方法 --&gt; &lt;!-- expression：表达式，execution(要执行的位置，修饰词 返回值 列名 方法名 参数) --&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* org.yuyr757.services.UserServiceImpl.*(..))&quot;/&gt; &lt;!-- 执行环绕增加 --&gt; &lt;aop:advisor advice-ref=&quot;logBefore&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;logAfter&quot; pointcut-ref=&quot;pointcut&quot;/&gt;&lt;/aop:config&gt; （2）方式二：自定义类+xml配置（建议使用）要自定义类当作aspect，配置文件中定义aspect标签引用自定义类，再配置pointcut、before、after等。 123456789&lt;!-- 方式二：使用自定义类来实现aop --&gt;&lt;aop:config&gt;&lt;!-- 需要配置切面 --&gt; &lt;aop:aspect ref=&quot;diyPoint&quot;&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* org.yuyr757.services.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; （3）方式三：使用自定义类+注解123456789101112131415161718package org.yuyr757.DiyAop;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class DiyPointCut2 &#123; @Before(&quot;execution(* org.yuyr757.services.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;=========方法执行前2=========&quot;); &#125; @After(&quot;execution(* org.yuyr757.services.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;=========方法执行后2=========&quot;); &#125;&#125; 12345&lt;!-- 方式三：使用自定义+注解 --&gt;&lt;aop:aspectj-autoproxy/&gt;&lt;!-- proxy-target-class默认为false，false代表使用jdk自己的动态代理实现，true代表使用cglib实现，一般用false即可 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class=&quot;false&quot;/&gt; （4）示例1234567891011121314151617181920212223242526272829303132333435package org.yuyr757.DiyAop;import org.aspectj.lang.ProceedingJoinPoint;public class DiyPointCut &#123; public void before()&#123; System.out.println(&quot;=========before通知=========&quot;); &#125; public void after()&#123; System.out.println(&quot;=========after通知=========&quot;); &#125; public void afterReturning()&#123; System.out.println(&quot;=========afterReturning通知=========&quot;); &#125; public void afterThrowing()&#123; System.out.println(&quot;=========afterThrowing通知=========&quot;); &#125; public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; Object object = 0; try&#123; System.out.println(&quot;=========around通知前=========&quot;); object = joinPoint.proceed(); System.out.println(&quot;=========around通知-afterReturning=========&quot;); &#125;catch (IllegalArgumentException e)&#123; System.out.println(&quot;=========around通知-afterThrowing=========&quot;); &#125;finally &#123; System.out.println(&quot;=========around通知后=========&quot;); &#125; return object; &#125;&#125; 1234567891011 &lt;aop:config&gt; &lt;!-- 需要配置切面 --&gt; &lt;aop:aspect ref=&quot;diyPoint&quot;&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* org.yuyr757.services.UserServiceImpl.*(..))&quot;/&gt;&lt;!-- &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt;--&gt;&lt;!-- &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;point&quot;/&gt;--&gt;&lt;!-- &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;point&quot;/&gt;--&gt; &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;point&quot;/&gt;&lt;!-- &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt;--&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 123456789101112131415161718192021package org.yuyr757.services;public class UserServiceImpl implements UserService&#123; public int add(int num) &#123; if (num &lt; 50) throw new IllegalArgumentException(); System.out.println(&quot;增加了一个用户&quot;); return num; &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; public void select() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 12345678package org.yuyr757.services;public interface UserService &#123; public int add(int num); public void delete(); public void update(); public void select();&#125; 1234567891011121314151617181920212223242526272829import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.yuyr757.services.UserService;public class TestAop1 &#123; public static final ApplicationContext context; static&#123; context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); &#125; @Test public void testAopAroundReturning()&#123; System.out.println(&quot;【开始测试正常返回时的通知结果】&quot;); UserService userService = context.getBean(&quot;userServiceImpl&quot;, UserService.class); int num = userService.add(188); System.out.println(num); &#125; @Test public void testAopAroundThrowing()&#123; System.out.println(&quot;【开始测试报异常时的通知结果】&quot;); UserService userService = context.getBean(&quot;userServiceImpl&quot;, UserService.class); int num = userService.add(1); System.out.println(num); &#125;&#125; 三、整合spring和mybatis需要用到mybatis-spring这个包。 此外对于每个mapper接口我们必须手动写一个实现类，然后注册到spring的bean中，实现类使用的SqlSession要使用SqlSessionTemplate。其他的都和mybatis一样配置 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 使用spring数据源代替mybatis数据源 --&gt; &lt;bean id=&quot;datasource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=true&amp;amp;serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt; &lt;!-- 绑定mybatis配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!-- 一般这里只需要绑定配置文件就可以，mybatis的配置还是在mybatis-config.xml中配置 --&gt; &lt;/bean&gt; &lt;!-- 这个sqlSessionTemplate是SqlSession的一个实现类，我们以后就不用手动调用openSession()方法来获得SqlSession对象 --&gt; &lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!-- 因为这个类没有setter方法，所以只能通过有参构造方法来初始化 --&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 四、spring的事务管理1、编程式事务管理手动在程序中写try catch来实现事务就是编程式事务管理。 2、声明式事务管理把事务交给IOC容器管理就是声明式事务管理。配置如下： 12345678910111213141516171819202122&lt;!-- 声明式事务管理 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot;/&gt;&lt;/bean&gt;&lt;!-- 结合AOP实现事务织入 --&gt;&lt;!-- 配置事务通知的的类：需要导入tx命名空间 --&gt;&lt;tx:advice id=&quot;txAdvisor&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!-- name：给哪些方法配置事务，propagation：配置事务的传播特性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;select*&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置事务的切入点 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* org.yuyr757.mapper.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvisor&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;&lt;/aop:config&gt;","categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yury757.github.io/tags/spring/"}]},{"title":"Java_JUC-study","slug":"java/java_JUC/Java_JUC-study","date":"2021-08-23T16:00:00.000Z","updated":"2021-08-27T09:26:55.755Z","comments":true,"path":"/java/java_JUC/Java_JUC-study","link":"","permalink":"https://yury757.github.io/java/java_JUC/Java_JUC-study","excerpt":"","text":"一、基础1、进程和线程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。狭义地说，进程就是一个正在运行的程序。 线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。 2、并行和并发并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。即CPU可以同时在两个线程上工作。 并发：在同一个时间段内，两个或多个程序执行，宏观上来看是一起执行的，但微观上来看是交替执行的。比如CPU在线程1上工作一段时间，又切换到线程2上工作一段时间，因此宏观上来看两个程序都执行了。 知乎有一个举例说得好： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。区分它们最关键的点就是：是否是同时。因此，单核CPU是无法实现并行的，只能通过CPU调度实现并发。而多核CPU才能实现并行。 3、线程的状态1234567891011121314public enum State &#123; // 就绪 NEW, // 运行 RUNNABLE, // 阻塞 BLOCKED, // 等待 WAITING, // 有一个特定时间的等待状态 TIMED_WAITING, // 终止 TERMINATED;&#125; 4、java有权限开线程吗？没有。java的thread.start方法本质调用的是一个native方法，该方法调用底层C++方法来实现开线程。 5、wait和sleep的区别（1）来自不同的类，wait来此Object，而sleep来自Thread； （2）wait会释放锁，而sleep不会释放锁； （3）wait只有在synchronized代码块下使用，而sleep可以在任何地方使用； 二、锁 传统使用synchronized来给对象加锁 12345678class Ticket&#123; private int number = 50; public synchronized void sale()&#123; if (this.number &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张表，剩余&quot; + number + &quot;张票&quot;); &#125; &#125;&#125; 使用Lock接口来实现 1、Lock接口123public class ReentrantLock implements Lock, java.io.Serializable &#123;&#125;public static class WriteLock implements Lock, java.io.Serializable &#123;&#125;public static class WriteLock implements Lock, java.io.Serializable &#123;&#125; （1）ReentrantLock（可重入锁，常用）含义：可以多次获取同一个锁，但是释放也要多次释放。 构造方法： 12public ReentrantLock() &#123; sync = new NonfairSync(); &#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; 有两种锁： 公平锁：对线程公平对待，必须先来后到； 非公平锁：线程竞争锁时不管先来后到，让他们蜂拥上去抢。（默认） 123456789101112131415161718192021222324252627282930public class Test02SaleTicket2 &#123; @Test public void test01()&#123; Ticket ticket = new Ticket(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 30; i++) ticket.sale(); &#125;, &quot;A&quot;).start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 30; i++) ticket.sale(); &#125;, &quot;B&quot;).start(); new Thread(() -&gt;&#123; for (int i = 0; i &lt; 30; i++) ticket.sale(); &#125;, &quot;C&quot;).start(); &#125;&#125;class Ticket2&#123; private int number = 50; Lock lock = new ReentrantLock(); public void sale()&#123; lock.lock(); try &#123; // 业务代码 if (this.number &gt; 0)&#123; System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张表，剩余&quot; + number + &quot;张票&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 使用Lock的代码套路： 先调用lock.lock()方法 再用try包裹起来，里面写业务代码 最后finally要调用lock.unlock()方法 Synchronized和Lock的区别 Synchronized是java关键字，而Lock是一个java类 Synchronized无法获取锁的状态，而Lock可以查看锁的状态 Synchronized会自动释放锁，Lock必须手动解锁，如果出了问题而没有释放，则会死锁。 Synchronized，线程1（获得锁），线程2（阻塞），线程1（阻塞），线程2（永远等下去）；而Lock可以使用tryLock方法看是否可以获取锁，若长时间没有获取到锁，则会返回false，而lock()方法如果一直获取不到锁，也会一直阻塞，这就出现了死锁。因此要避免使用lock()方法，使用tryLock()方法。 Synchronized是非公平的可重入锁，不可以中断，而Lock可以手动设置公平和非公平，且可以判断锁状态 Synchronized适合锁少量的代码块同步问题，而Lock适合锁大量同步代码块 即Synchronized是自动版的Lock，而Lock是纯手动配置。 2、生产者消费者问题生产者消费者问题的套路： 先判断等待 再写业务代码 最后通知 （1）使用Synchronized来写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package net.yury757;import org.junit.Test;public class Test03ProducerConsumer &#123; @Test public void test01() &#123; Data data = new Data(); new Thread(() -&gt; &#123; for(int i = 0; i &lt; 1000; i++)&#123; try &#123; data.plus(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for(int i = 0; i &lt; 1000; i++)&#123; try &#123; data.minus(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); &#125;&#125;class Data&#123; private int number = 0; public synchronized void plus() throws InterruptedException &#123; if (number != 0)&#123; // 等待 this.wait(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot; =&gt; &quot; + number); // 通知其他线程，加法做完了 this.notifyAll(); &#125; public synchronized void minus() throws InterruptedException &#123; if (number == 0)&#123; // 等待 this.wait(); &#125; number--; System.out.println(Thread.currentThread().getName() + &quot; =&gt; &quot; + number); // 通知其他线程，减法做完了 this.notifyAll(); &#125;&#125; （2）虚假唤醒（重要）在上面例子中，只有一个生产者和一个消费者，因此生产者只可能被消费者唤醒，而消费者只可能被生产者唤醒。 但是如果有两个生产者和两个消费者的情况下，一个生产者可能唤醒了另外一个生产者，导致生产者的活动执行了两次。这就是虚假唤醒。 解决办法：使用while，而不是if来判断，即某个线程被唤醒后，还要再判断一次是否是真实的被唤醒情况。 （3）使用Lock来写 Synchronized方式 Lock方式 synchronized Lock类 wait方法 Condition类的await方法 notify方法 Condition类的signal方法 Conditioin类就类似一个对象的监视器，await方法可以使调用这个方法的线程阻塞，signal方法可以唤醒某个被阻塞的线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package net.yury757;import org.junit.Test;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Test03ProducerConsumer2 &#123; @Test public void test01() &#123; Data data = new Data(); new Thread(() -&gt; &#123; for(int i = 0; i &lt; 1000; i++)&#123; try &#123; data.plus(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;A&quot;).start(); new Thread(() -&gt; &#123; for(int i = 0; i &lt; 1000; i++)&#123; try &#123; data.minus(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;B&quot;).start(); new Thread(() -&gt; &#123; for(int i = 0; i &lt; 1000; i++)&#123; try &#123; data.plus(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;C&quot;).start(); new Thread(() -&gt; &#123; for(int i = 0; i &lt; 1000; i++)&#123; try &#123; data.minus(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, &quot;D&quot;).start(); &#125;&#125;class Data2&#123; private int number = 0; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void plus() &#123; lock.lock(); try&#123; while (number != 0)&#123; condition.await(); &#125; number++; System.out.println(Thread.currentThread().getName() + &quot; =&gt; &quot; + number); condition.signalAll(); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public void minus() throws InterruptedException &#123; lock.lock(); try&#123; while (number == 0)&#123; condition.await(); &#125; number--; System.out.println(Thread.currentThread().getName() + &quot; =&gt; &quot; + number); condition.signalAll(); &#125;catch (InterruptedException ex)&#123; ex.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 3、（重要！）锁到底锁的是什么 普通方法上加锁，锁的是调用该方法的对象（实例）。 静态方法上加锁，锁的是class对象（模板）。 同一个对象，一个线程调用普通同步方法，另一个线程调用普通方法，普通方法的调用不受锁的影响，因为普通方法调用根本不用去获取锁，因此即使该对象被其他线程锁住了，普通方法也可以成功调用。把同步方法理解成需要在房子里才可以执行，普通方法不用进入房子就可以执行，因此普通方法的调用不会受锁的影响，只有同步方法才会受锁的影响，因为如果房子被其他线程“关门”了，他进不去就只能等待。 同一个对象，一个线程调用静态同步方法，另一个线程调用静态方法，静态方法的调用不受锁的影响，原因同上。 同一个对象，一个线程调用静态同步方法，另一个线程调用普通同步方法，普通同步方法的调用不受锁的影响，因为静态方法锁的是class对象（模板），普通对象（实例）和class对象（模板）不在一起，静态方法在class对象（模板）中，而普通方法在普通对象中。 三、集合类的安全性1、List的安全性12345678910111213141516import java.util.*;import java.util.concurrent.CopyOnWriteArrayList;// 使用ArrayList类，最终打印的长度可能不是10000// 而用CopyOnWriteArrayList类，最终打印的长度就是10000public class Test06UnsafeList &#123; public static void main(String[] args) &#123; List&lt;String&gt; objects = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt;&#123; objects.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(objects.size()); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; ArrayList类是非线程安全的，解决List的安全性的几个解决方案： 使用Vector类，Vector类是线程安全的List实现类，基于synchronized实现 使用Collections.synchronized(new ArrayList&lt;&gt;())，生成的SynchronizedList就是在arraylist外再包了一层同步方法而已。 使用JUC的CopyOnWriteArrayList类，基于ReentrantLock实现，效率比synchronized高。（用这个） 2、Set的安全性12345678910111213141516import java.util.Set;import java.util.UUID;import java.util.concurrent.CopyOnWriteArraySet;public class Test07UnsafeSet &#123; public static void main(String[] args) &#123; Set&lt;String&gt; objects = new CopyOnWriteArraySet&lt;&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt;&#123; objects.add(UUID.randomUUID().toString().substring(0, 5)); System.out.println(objects.size()); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 同样HashSet也是非线程安全的，解决方法： 使用Collections.synchronizedSet(new HashSet&lt;&gt;()) 使用CopyOnWriteArraySet，基于CopyOnWriteArrayList实现，效率比HashSet低（用这个） 3、Map的安全性12345678910111213import java.util.*;public class Test08UnsafeMap &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; objects = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10000; i++) &#123; new Thread(() -&gt;&#123; objects.put(UUID.randomUUID().toString().substring(0, 5), UUID.randomUUID().toString().substring(0, 5)); System.out.println(objects.size()); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; HashMap是非线程安全的，解决方法： 使用Collections.synchronizedMap(new HashMap&lt;&gt;()) 使用ConcurrentHashMap（用这个） 四、Callable（1）Callable和Runnable的区别： Callable可以有返回值 Callable可以抛出异常 调用方法不同，Callable由call()调用，Runnable由run()调用 （2）Callable的使用123456789101112131415161718192021package net.yury757;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Test09Callable implements Callable&lt;String&gt; &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask futureTask = new FutureTask(new Test09Callable()); new Thread(futureTask).start(); new Thread(futureTask).start(); String o = (String)futureTask.get(); System.out.println(&quot;main方法：&quot; + o); &#125; @Override public String call() throws Exception &#123; System.out.println(&quot;方法内部：asdfsdf&quot;); return &quot;asdfsdf&quot;; &#125;&#125; 注意点： 同时使用两次new Thread(futureTask).start();时，只会输出一次 futureTask.get();方法可能会被阻塞，如果call()方法内部是耗时操作的话 五、三大常用辅助类1、CountDownLatch这是一个减法计数器类。构造函数接受一个int参数，表示初始数量；countDown()方法将计数器减1；await()方法会阻塞当前线程，只有当计数器为0时，才会被唤醒并继续往下执行。 如下是一个简单测试类，只有当所有线程都完成了工作，才能输出close the door。 12345678910111213141516171819202122package net.yury757;import java.util.concurrent.CountDownLatch;public class Test10CountDownLatch &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(6); for (int i = 0; i &lt; 6; i++) &#123; new Thread(() -&gt; &#123; System.out.println(&quot;Person &quot; + Thread.currentThread().getName() + &quot; go out&quot;); // 计数器减1 countDownLatch.countDown(); &#125;, String.valueOf(i)).start(); &#125; // 等待计数器归零，才会继续向下执行 countDownLatch.await(); System.out.println(&quot;close the door&quot;); &#125;&#125; 2、CyclicBarrier循环阻塞。使当线程实现全部彼此等待直到达到一个共同的屏障点的辅助类。有点像加法计数器，全部线程都到达了一个准备好了的状态，则就会执行最终线程。 1234567891011121314151617181920212223242526272829package net.yury757;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * 集齐七颗龙珠召唤神龙 */public class Test11CyclicBarrier &#123; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123; System.out.println(&quot;召唤神龙成功&quot;); &#125;); for (int i = 0; i &lt; 7; i++) &#123; final int tmp = i; new Thread(() -&gt; &#123; System.out.println(&quot;收集到了第&quot; + Thread.currentThread().getName() + &quot;颗龙珠&quot;); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 3、Semaphore信号量。类似排队系统，指定一个最大容量，先进来的可以处理，直到到达最大容量，后面的等待，当里面有元素释放时，后面的元素才能进入处理。acquire()放入元素，如果容量满了则等待；release()方法释放元素，唤醒其他等待线程。 123456789101112131415161718192021222324252627package net.yury757;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;public class Test12Semaphore &#123; public static void main(String[] args) &#123; // 默认线程数量 Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; 6; i++) &#123; new Thread(() -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; &#125;, String.valueOf(i)).start(); &#125; &#125;&#125; 六、读写锁接口：ReadWriteLock 实现类：ReentrantReadWriteLock，维护了一对关联的lock，一个只用于读（read lock，共享锁），一个只用于写（write lock，独占锁），read lock可以允许多个线程同时读，而write lock同一个时间点只允许一个线程写。 读-读：可以共存 读-写：不能同时，需排队 写-写：不能同时，需排队 独占锁（写锁）：一次只能被一个线程占有 共享锁（读锁）：可以被多个线程同时占有 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package net.yury757;import jdk.internal.org.objectweb.asm.tree.FieldInsnNode;import java.util.HashMap;import java.util.Map;import java.util.UUID;import java.util.concurrent.locks.ReentrantReadWriteLock;public class Test13ReadWriteLock &#123; public static void main(String[] args) &#123; MyCacheLock cache = new MyCacheLock(); for (int i = 0; i &lt; 500; i++) &#123; final int tmp = i; new Thread(() -&gt; &#123; cache.put(tmp + &quot;&quot;, tmp); &#125;, String.valueOf(i)).start(); &#125; for (int i = 0; i &lt; 500; i++) &#123; final int tmp = i; new Thread(() -&gt; &#123; Object o = cache.get(tmp + &quot;&quot;); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125;/** * 自定义缓存 */class MyCache&#123; private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); public void put(String key, Object object)&#123; System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key); this.map.put(key, object); System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key + &quot;OK&quot;); &#125; public Object get(String key)&#123; System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key); Object o = this.map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key + &quot;OK&quot;); return o; &#125;&#125;/** * 自定义缓存 */class MyCacheLock&#123; private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 读写锁：更加细粒度地控制读写 private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); // 写入操作，同一时间只允许一个线程写入 public void put(String key, Object object)&#123; readWriteLock.writeLock().lock(); try&#123; System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key); this.map.put(key, object); System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key + &quot;OK&quot;); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; finally &#123; readWriteLock.writeLock().unlock(); &#125; &#125; // 读取操作，允许多个线程同时读 public Object get(String key)&#123; readWriteLock.readLock().lock(); Object o = null; try&#123; System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key); o = this.map.get(key); System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key + &quot;OK&quot;); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125;finally &#123; readWriteLock.readLock().lock(); &#125; return o; &#125;&#125; 七、阻塞队列接口：BlockingQueue 1、ArrayBlockingQueue该实现类基于数组实现。 方式 抛出异常 不抛出异常 阻塞等待 超时等待 添加 add(E) offer(E) put(E) offer(E, long, TimeUnit) 移除 remove() poll() take() poll(long, TimeUnit) 检查队首元素 element() peek() - - 2、LinkedBlockingQueue该实现类基于链表实现，和上面的使用方式一样，略。 3、SynchronousQueueSynchronousQueue为同步队列，和其他阻塞队列不太一样，SynchronousQueue在初始化时不需要传入capacity容量参数，可以认为SynchronousQueued的容量为0。 put(E)方法会阻塞，等待其他线程来取出该元素。 take()方法调用时，如果之前没有put进来值，则take会阻塞；如果之前有put进来值，则会取出之前put进来的值。 注意：在测试多线程和sleep时尽量不要用junit测试，junit对他们的支持有些问题，可以直接写一个main方法作为测试类。 八、线程池（重点）1、池化技术线程池、连接池、内存池、对象池…… 池化技术：事先准备好一些资源，有人要用，直接取出来使用，用完之后还回去即可。 好处： 降低资源创建时的CPU等资源消耗 提高响应速度 方便管理 线程池的优点：线程复用、可以控制最大并发数、方便管理线程。 2、七大参数创建线程池应使用如下构造方法自定义创建线程池，而不能使用后面会说的Executors来创建。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 参数名 参数类型 解释 corePoolSize int 维持在线程池中的核心线程数，即使是空闲状态，也会保留在线程池中 maximumPoolSize int 线程池中允许容纳的最大线程。提交任务时，若发现任务阻塞队列满了时，线程池就会进行扩容，但不能超过这个最大线程数 keepAliveTime long 当线程池中的线程数超过核心线程数时，空闲线程的留存时间，当线程处于空闲状态超过这个时间时，会移除这个线程，直到总线程数等于核心线程数 unit TimeUnit keepAliveTime参数的单位 workQueue BlockingQueue&lt;Runnable&gt; 任务阻塞队列，当用户提交执行的任务数超过核心线程数时，剩余任务就会在队列中排队等待 threadFactory ThreadFactory 创建线程的工厂类 handler RejectedExecutionHandler 当任务队列达到上限或线程数达到最大线程数时的处理策略 3、线程池的工作流程 execute(Runnable command)提交任务 判断核心线程中是否存在空闲的线程？若存在，则占用一个空闲线程来执行任务；否则进行下一步。 判断任务阻塞队列是否已满？若没有满，则将任务存入任务阻塞队列中等待；否则进行下一步。 判断整个线程池是否已满，若没有满，则创建一个新的线程执行任务；否则执行拒绝策略。 4、四种拒绝策略（1）抛异常 12345678910111213141516171819public static class AbortPolicy implements RejectedExecutionHandler &#123; /** * Creates an &#123;@code AbortPolicy&#125;. */ public AbortPolicy() &#123; &#125; /** * Always throws RejectedExecutionException. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task * @throws RejectedExecutionException always */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125; （2）在当前线程直接运行 12345678910111213141516171819public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; /** * Creates a &#123;@code CallerRunsPolicy&#125;. */ public CallerRunsPolicy() &#123; &#125; /** * Executes task r in the caller&#x27;s thread, unless the executor * has been shut down, in which case the task is discarded. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; （3）剔除最早提交的那个任务，将新任务开启执行 12345678910111213141516171819202122public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; /** * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor. */ public DiscardOldestPolicy() &#123; &#125; /** * Obtains and ignores the next task that the executor * would otherwise execute, if one is immediately available, * and then retries execution of task r, unless the executor * is shut down, in which case task r is instead discarded. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; （4）啥都不做，静默掠过 123456789101112131415public static class DiscardPolicy implements RejectedExecutionHandler &#123; /** * Creates a &#123;@code DiscardPolicy&#125;. */ public DiscardPolicy() &#123; &#125; /** * Does nothing, which has the effect of discarding task r. * * @param r the runnable task requested to be executed * @param e the executor attempting to execute this task */ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; 5、注意线程池的创建不允许使用Executors去创建，而是通过ThreadPoolExecutor去创建。本质上Executors也是通过new ThreadPoolExecutor的方式来创建线程池，但是Executors把很多参数都封装好了，不能自定义某些参数，因此自己通过new ThreadPoolExecutor的方式创建的线程池在管理上更具有自主性，此外通过使用Executors封装好了的参数创建的线程池有诸多弊端，如下： （1）Executors.newFixedThreadPool(int nThreads) 这种创建方式创建的线程池的任务队列大小是Integer.MAX_VALUE，因此如果工作线程满了，如果同时涌来大量任务请求，则会导致任务队列积压，非常容易导致内存溢出、程序崩溃。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; （2）Executors.newSingleThreadExecutor() 这种方式和上面那个一样，都是由于创建的是一个Integer.MAX_VALUE大小的任务队列，容易造成任务积压导致内存溢出。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; （3）Executors.newCachedThreadPool() 这种创建方式的任务队列是SynchronousQueue，线程池最大容量是Integer.MAX_VALUE，而我们知道SynchronousQueue是同步队列，只要有元素put进去，就会阻塞，此时就需要创建一个线程来处理这个请求，而线程池的最大值又设定为Integer.MAX_VALUE，因此同样如果请求突然增加，就会创建大量线程，容易造成内存溢出。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; （4）Executors.newScheduledThreadPool(int corePoolSize) 这种创建方式和上面一样，可创建的线程最大容量为Integer.MAX_VALUE，容易会因为大量创建线程而导致内存溢出。 12345678public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 总结如下： 以下四种方式都是用的默认的线程创建工厂和默认的拒绝策略。 创建线程池的方式 核心线程数 最大线程数 线程空闲超时时间 任务队列类 任务队列容量 OOM原因 Executors.newFixedThreadPool(int nThreads) 自定义 自定义 0毫秒 LinkedBlockingQueue Integer.MAX_VALUE 任务队列大量堆积导致OOM Executors.newSingleThreadExecutor() 1 1 0毫秒 LinkedBlockingQueue Integer.MAX_VALUE 任务队列大量堆积导致OOM Executors.newCachedThreadPool() 0 Integer.MAX_VALUE 60秒 SynchronousQueue 0 创建大量线程导致OOM Executors.newScheduledThreadPool(int corePoolSize) 自定义 Integer.MAX_VALUE 0微秒 DelayedWorkQueue 0 创建大量线程导致OOM 九、IO密集型程序和CPU密集型程序 CPU密集型也叫计算密集型，指的是系统运作大部分的状况是CPU Loading很高，I/O在很短的时间就可以完成，而CPU还有许多运算要处理。如计算圆周率程序、对视频音频进行编码解码的程序等，绝大部分时间都在进行CPU计算。开发CPU密集型程序尽量使用运行效率更高的编程语言，比如C/C++。 IO密集型是指程序绝大多数时间都花在IO上了，而IO结束后，CPU的计算在很短时间内就可以完成。常见的大部分任务都是IO密集型任务，比如web应用。开发IO密集型程序最好选择开发效率更高的编程语言，如python/java。 十、四大函数式接口函数式接口：只有一个方法的接口。 1、Function1234567891011121314151617181920212223public static void test01()&#123; Function&lt;Integer, String&gt; function = new Function&lt;Integer, String&gt;() &#123; @Override public String apply(Integer o) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; o; i++) &#123; sb.append(&quot;1&quot;); &#125; return sb.toString(); &#125; &#125;; Function&lt;Integer, String&gt; function2 = (Integer o) -&gt;&#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; o; i++) &#123; sb.append(&quot;2&quot;); &#125; return sb.toString(); &#125;; System.out.println(function.apply(2)); System.out.println(function2.apply(4));&#125; 2、Predicate12345678910111213public static void test02()&#123; Predicate&lt;Float&gt; predicate1 = new Predicate&lt;Float&gt;() &#123; @Override public boolean test(Float o) &#123; return o &gt; 1000.2f; &#125; &#125;; Predicate&lt;Float&gt; predicate2 = (Float o) -&gt; &#123; return o &gt; 1000.2f; &#125;; System.out.println(predicate1.test(1000f)); System.out.println(predicate1.test(1001f));&#125; 3、Consumer1234567891011121314151617public static void test03()&#123; Consumer&lt;String[]&gt; consumer1 = new Consumer&lt;String[]&gt;() &#123; @Override public void accept(String[] strings) &#123; for (String s : strings) &#123; System.out.println(s); &#125; &#125; &#125;; Consumer&lt;String[]&gt; consumer2 = (String[] strings) -&gt; &#123; for (String s : strings) &#123; System.out.println(s); &#125; &#125;; consumer1.accept(new String[] &#123;&quot;123&quot;, &quot;456&quot;&#125;); consumer2.accept(new String[] &#123;&quot;abc&quot;, &quot;def&quot;&#125;);&#125; 4、Supplier12345678910111213public static void test04()&#123; Supplier&lt;String&gt; supplier1 = new Supplier&lt;String&gt;() &#123; @Override public String get() &#123; return &quot;suppplier1 =&gt; &quot; + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); &#125; &#125;; Supplier&lt;String&gt; supplier2 = () -&gt; &quot;suppplier2 =&gt; &quot; + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); System.out.println(supplier1.get()); System.out.println(supplier2.get());&#125; 十一、流式计算大数据：存储 + 计算 java集合类、数据库等本质是用来存储东西的，计算都应交给流来操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Test19StreamCalculate &#123; public static void main(String[] args) &#123; test01(); &#125; public static void test01()&#123; User u1 = new User(1, &quot;a&quot;, 21); User u2 = new User(2, &quot;b&quot;, 22); User u3 = new User(3, &quot;c&quot;, 23); User u4 = new User(4, &quot;d&quot;, 24); User u5 = new User(5, &quot;e&quot;, 25); User u6 = new User(6, &quot;f&quot;, 26); List&lt;User&gt; userList = Arrays.asList(u1, u2, u3, u4, u5, u6); // Lambda表达式、链式编程、函数式接口、Stream流式计算 userList.stream() .filter(user -&gt; user.getId() % 2 == 0) // 筛选id为偶数的用户 .filter(user -&gt; user.getAge() &gt; 23) // 筛选年龄大于23的用户 .map(user -&gt; user.getName().toUpperCase()) // 只保留名字 .sorted((String s1, String s2) -&gt; s2.compareTo(s1)) // 对名字倒序排序 .limit(1) // 只取第一个 .forEach(System.out::println); // 打印 &#125;&#125;class User&#123; private int id; private String name; private int age; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; public User(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; &#125;&#125; 十二、ForkJoin1、原理将一个大任务拆分成多个小任务，每个子任务分别执行，全部子任务结束后获取结果，再将所有结果汇总起来成最终结果。 2、特点：工作窃取子任务分配给其他很多线程后，不同线程执行完成的时间可能不一样，先完成的的线程会把未完成的线程的部分任务拿过来帮忙一起做。 里面维护的是双端队列，可以从两端取任务来执行。 3、示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package net.yury757;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;import java.util.stream.LongStream;public class Test18FockJoin extends RecursiveTask&lt;Long&gt; &#123; private Long start; private Long end; // 临界值 private Long temp = 10000L; public Test18FockJoin(Long start, Long end) &#123; this.start = start; this.end = end; &#125; public Long sum()&#123; long sum = 0L; for (Long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125; @Override protected Long compute() &#123; if ((end - start) &lt; temp)&#123; long sum = 0L; for (Long i = start; i &lt;= end; i++) &#123; sum += i; &#125; return sum; &#125;else&#123; long middle = (start + end) / 2; Test18FockJoin test18FockJoin1 = new Test18FockJoin(start, middle); test18FockJoin1.fork(); Test18FockJoin test18FockJoin2 = new Test18FockJoin(middle + 1, end); test18FockJoin2.fork(); return test18FockJoin1.join() + test18FockJoin2.join(); &#125; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; test03(); &#125; /** * 普通计算方式 * 500000000500000000 * 3603毫秒 */ public static void test01()&#123; long starttime = System.currentTimeMillis(); Test18FockJoin task = new Test18FockJoin(1L, 10_0000_0000L); Long res = task.sum(); System.out.println(res); long endtime = System.currentTimeMillis(); System.out.println(&quot;花费时间：&quot; + (endtime - starttime) + &quot;毫秒&quot;); &#125; /** * 使用forkjoin * 500000000500000000 * 2133毫秒 */ public static void test02() throws ExecutionException, InterruptedException &#123; long starttime = System.currentTimeMillis(); ForkJoinPool forkJoinPool = new ForkJoinPool(); Test18FockJoin task = new Test18FockJoin(1L, 10_0000_0000L); ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task); Long res = task.get(); System.out.println(res); long endtime = System.currentTimeMillis(); System.out.println(&quot;花费时间：&quot; + (endtime - starttime) + &quot;毫秒&quot;); &#125; /** * 使用Stream并行流 * 500000000500000000 * 215毫秒 */ public static void test03()&#123; long starttime = System.currentTimeMillis(); long res = LongStream.rangeClosed(1, 10_0000_0000L).parallel().reduce(0, Long::sum); System.out.println(res); long endtime = System.currentTimeMillis(); System.out.println(&quot;花费时间：&quot; + (endtime - starttime) + &quot;毫秒&quot;); &#125;&#125; 十三、异步回调（Future）Future接口：用来处理异步任务的，提供了检查异步任务是否完成、取消任务、是否被取消了、获取任务结果、在指定延迟内获取返回值等接口方法。 CompletableFuture为其中一个实现类，介绍两个方法： 12345// 没有返回值的异步回调public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)&#123;&#125;// 有返回值的异步回调public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) &#123;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package net.yury757;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;/** * 异步调用： * 1、异步执行 * 2、成功回调 * 3、失败回调 */public class Test20Future &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; // 无返回值的异步任务 CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123; System.out.println(&quot;异步无返回值1&quot;); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;异步无返回值2&quot;); &#125;); System.out.println(&quot;同步任务&quot;); // 阻塞，直到获取结果 Void unused = completableFuture.get(); System.out.println(&quot;异步无返回值任务结束&quot;); // 有返回值的异步任务 CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println(&quot;异步有返回值1&quot;); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;异步有返回值2&quot;); int a = 10 / 0; return 1024; &#125;); Integer res = completableFuture2.whenComplete((t, u) -&gt; &#123; System.out.println(&quot;t =&gt; &quot; + t); System.out.println(&quot;u =&gt; &quot; + u); &#125;).exceptionally((ex) -&gt; &#123; System.out.println(ex.getMessage()); return 233; &#125;).get(); System.out.println(res); &#125;&#125; 十四、JMM（重要）1、什么是JMMJMM是java memory model，即java内存模型，因为在不同硬件厂商和不同操作系统下，程序对内存的访问会有一定的差异，会造成相同代码运行出来的结果不一样，因此JMM屏蔽掉了这些差异，实现了java在不同的平台下都能达到一致的效果。 Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行，然后刷回到主存。线程不能直接读写主内存中的变量。 2、八种内存交互操作JMM八种内存交互操作： lock(锁定)，作用于主内存中的变量，把变量标识为线程独占的状态。 read(读取)，作用于主内存的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。 load(加载)，作用于工作内存的变量，把read操作主存的变量放入到工作内存的变量副本中。 use(使用)，作用于工作内存的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign(赋值)，作用于工作内存的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。 store(存储)，作用于工作内存的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。 write(写入)：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 8种内存交互操作制定的规则： 不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。 不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。 不允许线程将没有assign的数据从工作内存同步到主内存。 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。 一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。 一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。 3、三个特征：可见性、原子性、有序性（1）volatile保证可见性可见性，是指在有多个线程对内存中的同一个变量进行操作时，如果内存中的值被修改了，其他线程可以立即直到这个值被改掉了，并获取最新的值。 如下代码示例，这个程序永远不会结束。即这种情况下是没保证可见性的。 123456789101112131415161718package net.yury757;import java.util.concurrent.TimeUnit;public class Test21Volatile &#123; public static int num = 0; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; while (num == 0)&#123; &#125; System.out.println(&quot;线程2：&quot; + num); &#125;); thread.start(); TimeUnit.SECONDS.sleep(1); num = 1; System.out.println(&quot;主线程：&quot; + num); &#125;&#125; 在某些情况下，使用synchronized和lock是可以保证可见性的，但是上面例子不行。 上面这个例子只要在num的定义加上volatile关键字即可。 1public volatile static int num = 0; （2）Atomic类保证原子性原子性：不可分割性，在数据库的事务中，指的是一个事务的所有操作要么全部完成，要么全部不完成。而线程的原子性是指一个线程在执行任务时，是不可分割，不可中断的，且不能被其他线程所干扰，这个线程中的所有操作要么全部成功，要么全部失败。 volatile是无法保证原子性的。 1234567891011121314151617181920212223package net.yury757;public class Test22Atomic &#123; public volatile static int num = 0; public static void add()&#123; num++; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; add(); &#125; &#125;).start(); &#125; while(Thread.activeCount() &gt; 2)&#123; Thread.yield(); &#125; System.out.println(num); &#125;&#125; 即多个线程同时操作同一个资源时，会出现资源错误。对于这种问题，常见的在add方法那里用synchronized和lock来解决。 然而还有一种办法就是使用Atomic类，使用原子类的速度一般情况下比使用锁的效率高。如下： 12345678910111213141516171819202122232425package net.yury757;import java.util.concurrent.atomic.AtomicInteger;public class Test22Atomic &#123; public volatile static AtomicInteger num = new AtomicInteger(); public static void add()&#123; num.getAndIncrement(); // AtomicInteger类的+1方法，底层用的CAS &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; for (int j = 0; j &lt; 1000; j++) &#123; add(); &#125; &#125;).start(); &#125; while(Thread.activeCount() &gt; 2)&#123; Thread.yield(); &#125; System.out.println(num); &#125;&#125; 具体探究见CAS章节。 （3）volatile保证有序性（禁止指令重排）什么是有序性，即你编写的每一行源代码被计算机CPU拿去执行的顺序是和源代码顺序一致的。 指令重排是指你写的程序，计算机并不是按照你写的那样去执行的，即计算机会对你的代码重新架构再执行。 1源代码 —&gt; 编译器的优化重排 —&gt; 指令并行也可能会重排 —&gt; 内存系统也可能会重排 —&gt; 执行 计算机对我们的代码做指令重排就没办法保证有序性，指令重排可能会产生一些不可预知的问题。 在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性，即禁止计算机对某些代码做指令重排。 十五、深究单例模式1、饿汉式单例模式这种模式很少出现线程安全问题，缺点是类一加载就会初始化一个对象，有时候每用到这个对象时，也会一直存在，浪费空间。 123456789101112131415package net.yury757;/** * 饿汉式单例模式 */public class Test23Hungry &#123; private Test23Hungry()&#123; &#125; private final static Test23Hungry hungry = new Test23Hungry(); public static Test23Hungry getInstance()&#123; return hungry; &#125;&#125; 2、懒汉式单例模式懒汉式单例模式是指要用到这个实例时再初始化。如果私有构造方法没有synchronized时，多个线程同时getInstance时会有线程安全问题。 同时加上volatile防止指令重排导致的线程安全问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243package net.yury757;/** * 懒汉式单例模式 */public class Test24Lazy &#123; private Test24Lazy()&#123; System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;); &#125; // 加volatile禁止指令重排导致的线程安全问题 private volatile static Test25DCLLazy lazy = null; // 线程不安全// public static Test24Lazy getInstance()&#123;// if (lazy == null)&#123;// lazy = new Test24Lazy();// &#125;// return lazy;// &#125; // 线程安全 public static Test24Lazy getInstance()&#123; // 双重检测 if (lazy == null)&#123; // 静态方法，因此要锁住class synchronized (Test24Lazy.class)&#123; if (lazy == null)&#123; lazy = new Test24Lazy(); &#125; &#125; &#125; return lazy; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; // 多线程会有问题，可能多次初始化这个类，需要对getInstance方法加锁 Test24Lazy lazy = Test24Lazy.getInstance(); &#125;).start(); &#125; &#125;&#125; 3、反射对单例模式的影响对于例模式，正常情况下是安全的，但是如果通过反射来创建实例，即打破了单例模式。如下： 123456789101112131415161718192021222324package net.yury757;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public class Test25ReflectionHungry &#123; private Test25ReflectionHungry()&#123; System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;); &#125; private volatile static Test25ReflectionHungry hungry = new Test25ReflectionHungry(); public static Test25ReflectionHungry getInstance()&#123; return hungry; &#125; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Test25ReflectionHungry single = Test25ReflectionHungry.getInstance(); Constructor&lt;Test25ReflectionHungry&gt; constructor = Test25ReflectionHungry.class.getDeclaredConstructor(null); constructor.setAccessible(true); Test25ReflectionHungry single2 = constructor.newInstance(); System.out.println(single); System.out.println(single2); &#125;&#125; 对于饿汉式单例模式，直接把构造函数改成如下即可： 12345678private Test25ReflectionHungry()&#123; synchronized (Test25ReflectionHungry.class)&#123; System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;); if (hungry != null)&#123; throw new RuntimeException(&quot;不要尝试使用反射创建对象!&quot;); &#125; &#125;&#125; 但是对于懒汉式单例模式，改成上面这种，有一个问题就是如果一开始就使用反射来创建对象的话依旧没办法阻止。 因此对于懒汉式单例模式可以尝试通过使用使用如下修改： 但是依旧可以通过反射修改flag的值来破坏单例模式，即使通过对flag的值进行加密等其他操作，通过反射几乎总是可以破坏这种单例模式。 123456789101112131415161718192021222324252627282930313233343536373839404142package net.yury757;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public class Test26ReflectionLazy &#123; private static boolean flag = false; private Test26ReflectionLazy()&#123; synchronized (Test25ReflectionHungry.class)&#123; System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;); if (flag == false)&#123; flag = true; &#125;else&#123; throw new RuntimeException(&quot;不要尝试使用反射创建对象!&quot;); &#125; &#125; &#125; private volatile static Test26ReflectionLazy lazy = null; public static Test26ReflectionLazy getInstance()&#123; // 双重检测 if (lazy == null)&#123; // 静态方法，因此要锁住class synchronized (Test24Lazy.class)&#123; if (lazy == null)&#123; lazy = new Test26ReflectionLazy(); flag = true; &#125; &#125; &#125; return lazy; &#125; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; Constructor&lt;Test26ReflectionLazy&gt; constructor = Test26ReflectionLazy.class.getDeclaredConstructor(null); constructor.setAccessible(true); Test26ReflectionLazy single = constructor.newInstance(); Test26ReflectionLazy single2 = constructor.newInstance(); System.out.println(single); System.out.println(single2); &#125;&#125; 4、通过enum来实现安全的单例模式1234567891011121314151617181920212223242526272829303132333435363738394041package net.yury757;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public enum Test27EnumSingle &#123; INSTANCE; private volatile Test27ReflectionLazy lazy = null; public Test27ReflectionLazy getInstance()&#123; return lazy; &#125; private Test27EnumSingle()&#123; if (lazy == null) &#123; lazy = new Test27ReflectionLazy(); &#125; &#125; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; System.out.println(Test27EnumSingle.INSTANCE.getInstance()); // 通过反射内部类无法获取对象 Constructor&lt;Test27ReflectionLazy&gt; constructor = Test27ReflectionLazy.class.getDeclaredConstructor(null); constructor.setAccessible(true); Object single = constructor.newInstance(); Object single2 = constructor.newInstance(); System.out.println(single); System.out.println(single2); &#125;&#125;class Test27ReflectionLazy &#123; Test27ReflectionLazy()&#123; synchronized (Test27ReflectionLazy.class)&#123; System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;); if (Test27EnumSingle.INSTANCE != null &amp;&amp; Test27EnumSingle.INSTANCE.getInstance() != null)&#123; throw new RuntimeException(&quot;不要尝试使用反射创建对象!&quot;); &#125; &#125; &#125;&#125; 十六、CAS1、乐观锁和悲观锁悲观锁：线程开始执行第一步就是获取锁，一旦获得锁，其他的线程进入后就会阻塞等待锁。synchronized和实现了Lock接口的各种锁都是悲观锁。 乐观锁：线程执行的时候不会加锁，假设没有冲突去完成某项操作，如果因为冲突失败了就重试，最后直到成功为止。如自旋锁。 2、什么是CASCAS（Compare-And-Swap）是比较并交换的意思，它是一条 CPU 并发原语（Unsafe类中的三个方法如下），用于判断内存中某个值是否为预期值，如果是则更改为新的值，这个过程是原子的。 CAS机制当中使用了3个基本操作数：内存地址V（由一个Object和一个long型的offset决定），旧的预期值A，计算后要修改后的新值B。 123456789// var1和var2找到对应的内存地址// var4为预期值// var5为新值// 如果内存中的值和预期值相同，则把内存中的值修改为var5public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); 比如我们在探究Atomic保证原子性时发现，使用int型的num++并不是原子操作，可能产生线程安全问题，而num.getAndIncrement()方法则是原子操作，其底层通过自旋锁+CAS来实现。 123456789101112131415public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;// 自旋锁 + CASpublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125;public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 解释如下： 先把内存中的这个对象的值取出来，然后把这个值和内存中的值比较，如果相同，则设置为新的值并退出循环，如果不同则继续循环（自旋锁，会一直尝试比较并修改，直到成功为止）。有人会觉得这不明显相同吗，其实并不是。在高并发的情况下，线程1把这个值取出来了，比如是100，下一时刻线程2可能已经把这个值更新掉了，比如是200，如果线程1仍然更新为101的话就错了，应该在线程2的操作的基础上再+1，即201。因此必须把取出来的值和内存上的值再比较一遍再更新，而这个比较再更新的操作则是一个cpu的原子操作，即在cpu内部是一个不可分割的操作，如果比较发现不同，说明别人把这个东西改过了，因此必须重来。 3、ABA问题ABA问题是指，上面说的线程2把内存中的值改成了200，但是如果中间还有一个线程3又把值从200改回到了100，即线程1执行过程中，内存中的值修改过两次，从100到200，又从200回到100。线程1再执行比较时发现值和预期相同，于是就更新到101。 但是这个100已经不是原来的100了。这就是ABA问题。 ABA问题在大多数情况下不会对程序产生太大的影响，通过带时间戳的原子类可以解决ABA问题，其内部维护了一个int型的时间戳，CAS操作需要再对比时间戳，因此可以通过时间戳来判断内存中的值是否被改动过。 1234567891011121314public class AtomicStampedReference&lt;V&gt; &#123; private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125; &#125; private volatile Pair&lt;V&gt; pair;&#125; 十七、自旋锁自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。被“阻塞”的线程并不是真正停了，而是一直在做循环判断的“等待”（busy waiting），直到其他线程解锁。 123456789101112131415161718192021222324252627package net.yury757;import java.util.concurrent.atomic.AtomicReference;public class Test29SpinLockDemo &#123; AtomicReference&lt;Thread&gt; reference = new AtomicReference&lt;&gt;(); // 加锁 public void lock()&#123; Thread thread = Thread.currentThread(); System.out.println(thread.getName() + &quot; =&gt; 尝试获取锁&quot;); while (!reference.compareAndSet(null, thread))&#123;&#125; System.out.println(thread.getName() + &quot; =&gt; 获取锁成功&quot;); &#125; // 解锁 public void unlock()&#123; Thread thread = Thread.currentThread(); System.out.println(thread.getName() + &quot; =&gt; 尝试解锁&quot;); boolean b = reference.compareAndSet(thread, null); if (b)&#123; System.out.println(thread.getName() + &quot; =&gt; 解锁成功&quot;); &#125;else&#123; System.out.println(thread.getName() + &quot; =&gt; 解锁失败，当前线程没有被加锁&quot;); &#125; &#125;&#125; 解释： 当第一个线程获取到锁时，reference为空，因此lock方法中reference.compareAndSet(null, thread)返回true，则while循环失败退出。 当第二线程尝试获取锁时，reference不为空，则reference.compareAndSet(null, thread)返回false，while则会一直循环。 当第一个线程解锁时，会判断reference中的线程引用是否是当前线程，然后将reference置为null。此时下一刻第二个线程的循环就判断成功了，则成功获取到了锁。 当有多个线程尝试竞争锁时，由于reference.compareAndSet(null, thread)是原子操作，因此只可能有一个线程成功获取锁。","categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yury757.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yury757.github.io/tags/spring/"},{"name":"hbase","slug":"hbase","permalink":"https://yury757.github.io/tags/hbase/"},{"name":"springboot","slug":"springboot","permalink":"https://yury757.github.io/tags/springboot/"}]}