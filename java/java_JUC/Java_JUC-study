<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Java_JUC-study | 
	 
	Yury&#39;s Blog
	</title>
	
	<!-- keywords,description -->
	 
		<meta name="description" content="blog of usual study" />
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Yury's Blog" type="application/atom+xml">
</head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">Yury's Blog</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	
		<li class="menu-item">
			<a href="/tags" class="menu-item-link">标签</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/yury757" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Git
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										learngit
									</a>
									
							<ul>
								<li class="file">
									<a href="/Git/learngit/learn-git">
										learn-git
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										bigdata
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										clickhouse
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/clickhouse/clickhouse">
										clickhouse
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										hadoop
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/hadoop/hadoop-study">
										hadoop-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										hbase
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/hbase/HBase-study">
										HBase-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										kafka
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/kafka/kafka">
										kafka
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										zookeeper
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/zookeeper/zookeeper-study">
										zookeeper-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										computer-science
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Computer-Networking
									</a>
									
							<ul>
								<li class="file">
									<a href="/computer-science/Computer-Networking/Computer-Networking">
										Computer-Networking
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/computer-science/Computer-Networking/socket">
										socket
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										database
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										mysql
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL中的exists与in的使用
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E4%B8%AD%E7%9A%84exists%E4%B8%8Ein%E7%9A%84%E4%BD%BF%E7%94%A8/MySQL%E4%B8%AD%E7%9A%84exists%E4%B8%8Ein%E7%9A%84%E4%BD%BF%E7%94%A8">
										MySQL中的exists与in的使用
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL备份-Linux版
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E5%A4%87%E4%BB%BD-Linux%E7%89%88/MySQL%E5%A4%87%E4%BB%BD-linux%E7%89%88">
										MySQL备份-linux版
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL日期格式化
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/MySQL%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96">
										MySQL日期格式化
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL查询执行计划详解-explain
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3-explain/MySQL%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3-explain">
										MySQL查询执行计划详解-explain
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL迁移数据目录
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/MySQL%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95">
										MySQL迁移数据目录
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										《高性能MySQL》
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第1章-MySQL架构与历史
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC1%E7%AB%A0-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2">
										第一章-MySQL架构与历史
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第2章-MySQL基准测试
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC2%E7%AB%A0-MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">
										第二章 MySQL基准测试
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第3章-服务器性能剖析
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC3%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90">
										第三章-服务器性能剖析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第4章-Schema与数据类型优化
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC4%E7%AB%A0-Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/%E7%AC%AC%E5%9B%9B%E7%AB%A0-Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96">
										第四章-Schema与数据类型优化
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第5章-创建高性能的索引
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC5%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95">
										第五章-创建高性能的索引
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										postgresql
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/postgresql/postgresql">
										postgresql
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										JVM
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/JVM/jvm-1.8">
										jvm-1.8
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										SSM-Build
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/SSM-Build/SSM-Build">
										SSM-Build
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java_JUC
									</a>
									
							<ul>
								<li class="file active">
									<a href="/java/java_JUC/Java_JUC-study">
										Java_JUC-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java_NIO
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/java_NIO/Java_NIO-study">
										Java_NIO-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/java/java%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE">
										java常用配置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										mybatis
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/mybatis/mybatis-study">
										mybatis-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										springMVC
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/springMVC/SpringMVC-Study">
										SpringMVC-Study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										springboot
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/springboot/springboot-study">
										springboot-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										spring
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/spring/Spring-study">
										Spring-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/jetbrains%E7%B3%BB%E5%88%97IDE%E6%8E%A8%E8%8D%90%E8%AE%BE%E7%BD%AE">
										jetbrains系列IDE推荐设置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										linux
									</a>
									
							<ul>
								<li class="file">
									<a href="/linux/linux%E5%91%BD%E4%BB%A4">
										linux命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/linux/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%9A%84%E7%BB%8F%E5%8E%86">
										记一次服务器被挖矿的经历
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										operating-support
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										docker
									</a>
									
							<ul>
								<li class="file">
									<a href="/operating-support/docker/docker">
										docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										project
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										flink_data_warehouse
									</a>
									
							<ul>
								<li class="file">
									<a href="/project/flink_data_warehouse/flink_data_warehouse">
										flink_data_warehouse
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E7%AB%AF%E5%8F%A3%E5%8F%B7">
										常用组件端口号
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	Java_JUC-study
</h1>
<div class="article-meta">
	
	<span>Yury</span>
	<span>2021-08-24 00:00:00</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true">
                        <a href="/categories/java/">java</a>
                        </i>
                      
                    </span>
                
            
    

    
		<span>Tags：</span>
            
                
                    <span>
                        <i class="fa fa-tag" aria-hidden="true">
                        <a href="/tags/java/">java</a>
                        </i>
                    </span>
                
            
    
		</div>

</div>

<div id="article-content">
	<h2 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h2><h3 id="1、进程和线程"><a href="#1、进程和线程" class="headerlink" title="1、进程和线程"></a>1、进程和线程</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。狭义地说，进程就是一个正在运行的程序。</p>
<p>线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<h3 id="2、并行和并发"><a href="#2、并行和并发" class="headerlink" title="2、并行和并发"></a>2、并行和并发</h3><p>并行：一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。即CPU可以同时在两个线程上工作。</p>
<p>并发：在同一个时间段内，两个或多个程序执行，宏观上来看是一起执行的，但微观上来看是交替执行的。比如CPU在线程1上工作一段时间，又切换到线程2上工作一段时间，因此宏观上来看两个程序都执行了。</p>
<p>知乎有一个举例说得好：</p>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</p>
<p>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</p>
<p>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p>
<p><font color="Red">并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。区分它们最关键的点就是：是否是同时。</font>因此，单核CPU是无法实现并行的，只能通过CPU调度实现并发。而多核CPU才能实现并行。</p>
<h3 id="3、线程的状态"><a href="#3、线程的状态" class="headerlink" title="3、线程的状态"></a>3、线程的状态</h3><pre><code class="java">public enum State &#123;
    // 就绪
    NEW,
    // 运行
    RUNNABLE,
    // 阻塞
    BLOCKED,
    // 等待
    WAITING,
    // 有一个特定时间的等待状态
    TIMED_WAITING,
    // 终止
    TERMINATED;
&#125;
</code></pre>
<h3 id="4、java有权限开线程吗？"><a href="#4、java有权限开线程吗？" class="headerlink" title="4、java有权限开线程吗？"></a>4、java有权限开线程吗？</h3><p>没有。java的thread.start方法本质调用的是一个native方法，该方法调用底层C++方法来实现开线程。</p>
<h3 id="5、wait和sleep的区别"><a href="#5、wait和sleep的区别" class="headerlink" title="5、wait和sleep的区别"></a>5、wait和sleep的区别</h3><p>（1）来自不同的类，wait来此Object，而sleep来自Thread；</p>
<p>（2）wait会释放锁，而sleep不会释放锁；</p>
<p>（3）wait只有在synchronized代码块下使用，而sleep可以在任何地方使用；</p>
<h2 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h2><blockquote>
<p>传统使用synchronized来给对象加锁</p>
</blockquote>
<pre><code class="java">class Ticket&#123;
    private int number = 50;
    public synchronized void sale()&#123;
        if (this.number &gt; 0)&#123;
            System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张表，剩余&quot; + number + &quot;张票&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>使用Lock接口来实现</p>
</blockquote>
<h3 id="1、Lock接口"><a href="#1、Lock接口" class="headerlink" title="1、Lock接口"></a>1、Lock接口</h3><pre><code class="java">public class ReentrantLock implements Lock, java.io.Serializable &#123;&#125;
public static class WriteLock implements Lock, java.io.Serializable &#123;&#125;
public static class WriteLock implements Lock, java.io.Serializable &#123;&#125;
</code></pre>
<h4 id="（1）ReentrantLock（可重入锁，常用）"><a href="#（1）ReentrantLock（可重入锁，常用）" class="headerlink" title="（1）ReentrantLock（可重入锁，常用）"></a>（1）ReentrantLock（可重入锁，常用）</h4><p>含义：可以多次获取同一个锁，但是释放也要多次释放。</p>
<p>构造方法：</p>
<pre><code class="java">public ReentrantLock() &#123; sync = new NonfairSync(); &#125;
public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125;
</code></pre>
<p>有两种锁：</p>
<ul>
<li>公平锁：对线程公平对待，必须先来后到；</li>
<li>非公平锁：线程竞争锁时不管先来后到，让他们蜂拥上去抢。（默认）</li>
</ul>
<pre><code class="java">public class Test02SaleTicket2 &#123;
    @Test
    public void test01()&#123;
        Ticket ticket = new Ticket();
        new Thread(() -&gt;&#123; for (int i = 0; i &lt; 30; i++) ticket.sale(); &#125;, &quot;A&quot;).start();
        new Thread(() -&gt;&#123; for (int i = 0; i &lt; 30; i++) ticket.sale(); &#125;, &quot;B&quot;).start();
        new Thread(() -&gt;&#123; for (int i = 0; i &lt; 30; i++) ticket.sale(); &#125;, &quot;C&quot;).start();
    &#125;
&#125;

class Ticket2&#123;
    private int number = 50;

    Lock lock = new ReentrantLock();

    public void sale()&#123;
        lock.lock();

        try &#123;
            // 业务代码
            if (this.number &gt; 0)&#123;
                System.out.println(Thread.currentThread().getName() + &quot;卖出了第&quot; + (number--) + &quot;张表，剩余&quot; + number + &quot;张票&quot;);
            &#125;
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<p>使用Lock的代码套路：</p>
<ul>
<li>先调用lock.lock()方法</li>
<li>再用try包裹起来，里面写业务代码</li>
<li>最后finally要调用lock.unlock()方法</li>
</ul>
<p>Synchronized和Lock的区别</p>
<ul>
<li>Synchronized是java关键字，而Lock是一个java类</li>
<li>Synchronized无法获取锁的状态，而Lock可以查看锁的状态</li>
<li>Synchronized会自动释放锁，Lock必须手动解锁，如果出了问题而没有释放，则会<strong>死锁</strong>。</li>
<li>Synchronized，线程1（获得锁），线程2（阻塞），线程1（阻塞），线程2（永远等下去）；而Lock可以使用tryLock方法看是否可以获取锁，若长时间没有获取到锁，则会返回false，<font color="Red">而lock()方法如果一直获取不到锁，也会一直阻塞，这就出现了死锁。因此要避免使用lock()方法，使用tryLock()方法</font>。</li>
<li>Synchronized是非公平的可重入锁，不可以中断，而Lock可以手动设置公平和非公平，且可以判断锁状态</li>
<li>Synchronized适合锁少量的代码块同步问题，而Lock适合锁大量同步代码块</li>
</ul>
<p>即Synchronized是自动版的Lock，而Lock是纯手动配置。</p>
<h3 id="2、生产者消费者问题"><a href="#2、生产者消费者问题" class="headerlink" title="2、生产者消费者问题"></a>2、生产者消费者问题</h3><p>生产者消费者问题的套路：</p>
<ul>
<li>先判断等待</li>
<li>再写业务代码</li>
<li>最后通知</li>
</ul>
<h4 id="（1）使用Synchronized来写"><a href="#（1）使用Synchronized来写" class="headerlink" title="（1）使用Synchronized来写"></a>（1）使用Synchronized来写</h4><pre><code class="java">package net.yury757;

import org.junit.Test;

public class Test03ProducerConsumer &#123;

    @Test
    public void test01() &#123;
        Data data = new Data();
        new Thread(() -&gt; &#123;
            for(int i = 0; i &lt; 1000; i++)&#123;
                try &#123;
                    data.plus();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;A&quot;).start();

        new Thread(() -&gt; &#123;
            for(int i = 0; i &lt; 1000; i++)&#123;
                try &#123;
                    data.minus();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;B&quot;).start();
    &#125;
&#125;

class Data&#123;
    private int number = 0;
    public synchronized void plus() throws InterruptedException &#123;
        if (number != 0)&#123;
            // 等待
            this.wait();
        &#125;
        number++;
        System.out.println(Thread.currentThread().getName() + &quot; =&gt; &quot; + number);
        // 通知其他线程，加法做完了
        this.notifyAll();
    &#125;

    public synchronized void minus() throws InterruptedException &#123;
        if (number == 0)&#123;
            // 等待
            this.wait();
        &#125;
        number--;
        System.out.println(Thread.currentThread().getName() + &quot; =&gt; &quot; + number);
        // 通知其他线程，减法做完了
        this.notifyAll();
    &#125;
&#125;
</code></pre>
<h4 id="（2）虚假唤醒（重要）"><a href="#（2）虚假唤醒（重要）" class="headerlink" title="（2）虚假唤醒（重要）"></a>（2）虚假唤醒（重要）</h4><p>在上面例子中，只有一个生产者和一个消费者，因此生产者只可能被消费者唤醒，而消费者只可能被生产者唤醒。</p>
<p>但是如果有两个生产者和两个消费者的情况下，<strong>一个生产者可能唤醒了另外一个生产者，导致生产者的活动执行了两次。</strong>这就是虚假唤醒。</p>
<p><font color="Red">解决办法：使用while，而不是if来判断，即某个线程被唤醒后，还要再判断一次是否是真实的被唤醒情况。</font></p>
<h4 id="（3）使用Lock来写"><a href="#（3）使用Lock来写" class="headerlink" title="（3）使用Lock来写"></a>（3）使用Lock来写</h4><table>
<thead>
<tr>
<th>Synchronized方式</th>
<th>Lock方式</th>
</tr>
</thead>
<tbody><tr>
<td>synchronized</td>
<td>Lock类</td>
</tr>
<tr>
<td>wait方法</td>
<td>Condition类的await方法</td>
</tr>
<tr>
<td>notify方法</td>
<td>Condition类的signal方法</td>
</tr>
</tbody></table>
<p>Conditioin类就类似一个对象的监视器，await方法可以使调用这个方法的线程阻塞，signal方法可以唤醒某个被阻塞的线程。</p>
<pre><code class="java">package net.yury757;

import org.junit.Test;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test03ProducerConsumer2 &#123;

    @Test
    public void test01() &#123;
        Data data = new Data();
        new Thread(() -&gt; &#123;
            for(int i = 0; i &lt; 1000; i++)&#123;
                try &#123;
                    data.plus();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;A&quot;).start();

        new Thread(() -&gt; &#123;
            for(int i = 0; i &lt; 1000; i++)&#123;
                try &#123;
                    data.minus();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;B&quot;).start();

        new Thread(() -&gt; &#123;
            for(int i = 0; i &lt; 1000; i++)&#123;
                try &#123;
                    data.plus();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;C&quot;).start();

        new Thread(() -&gt; &#123;
            for(int i = 0; i &lt; 1000; i++)&#123;
                try &#123;
                    data.minus();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;D&quot;).start();
    &#125;
&#125;

class Data2&#123;
    private int number = 0;
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    public void plus() &#123;
        lock.lock();
        try&#123;
            while (number != 0)&#123;
                condition.await();
            &#125;
            number++;
            System.out.println(Thread.currentThread().getName() + &quot; =&gt; &quot; + number);
            condition.signalAll();
        &#125;catch (InterruptedException ex)&#123;
            ex.printStackTrace();
        &#125;finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public void minus() throws InterruptedException &#123;
        lock.lock();
        try&#123;
            while (number == 0)&#123;
                condition.await();
            &#125;
            number--;
            System.out.println(Thread.currentThread().getName() + &quot; =&gt; &quot; + number);
            condition.signalAll();
        &#125;catch (InterruptedException ex)&#123;
            ex.printStackTrace();
        &#125;finally&#123;
            lock.unlock();
        &#125;

    &#125;
&#125;
</code></pre>
<h3 id="3、（重要！）锁到底锁的是什么"><a href="#3、（重要！）锁到底锁的是什么" class="headerlink" title="3、（重要！）锁到底锁的是什么"></a>3、（重要！）锁到底锁的是什么</h3><ul>
<li>普通方法上加锁，锁的是<font color="Red">调用该方法的对象（实例）</font>。</li>
<li>静态方法上加锁，锁的是<font color="Red">class对象（模板）</font>。</li>
<li>同一个对象，一个线程调用普通同步方法，另一个线程调用普通方法，普通方法的调用不受锁的影响，因为普通方法调用根本不用去获取锁，因此即使该对象被其他线程锁住了，普通方法也可以成功调用。<font color="Red">把同步方法理解成需要在房子里才可以执行，普通方法不用进入房子就可以执行，因此普通方法的调用不会受锁的影响，只有同步方法才会受锁的影响，因为如果房子被其他线程“关门”了，他进不去就只能等待。</font></li>
<li>同一个对象，一个线程调用静态同步方法，另一个线程调用静态方法，静态方法的调用不受锁的影响，原因同上。</li>
<li>同一个对象，一个线程调用静态同步方法，另一个线程调用普通同步方法，普通同步方法的调用不受锁的影响，因为静态方法锁的是class对象（模板），普通对象（实例）和class对象（模板）不在一起，静态方法在class对象（模板）中，而普通方法在普通对象中。</li>
</ul>
<h2 id="三、集合类的安全性"><a href="#三、集合类的安全性" class="headerlink" title="三、集合类的安全性"></a>三、集合类的安全性</h2><h3 id="1、List的安全性"><a href="#1、List的安全性" class="headerlink" title="1、List的安全性"></a>1、List的安全性</h3><pre><code class="java">import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

// 使用ArrayList类，最终打印的长度可能不是10000
// 而用CopyOnWriteArrayList类，最终打印的长度就是10000
public class Test06UnsafeList &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; objects = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10000; i++) &#123;
            new Thread(() -&gt;&#123;
                objects.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(objects.size());
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;
</code></pre>
<p>ArrayList类是非线程安全的，解决List的安全性的几个解决方案：</p>
<ul>
<li>使用Vector类，Vector类是线程安全的List实现类，基于synchronized实现</li>
<li>使用Collections.synchronized(new ArrayList&lt;&gt;())，生成的SynchronizedList就是在arraylist外再包了一层同步方法而已。</li>
<li>使用JUC的CopyOnWriteArrayList类，基于ReentrantLock实现，效率比synchronized高。（用这个）</li>
</ul>
<h3 id="2、Set的安全性"><a href="#2、Set的安全性" class="headerlink" title="2、Set的安全性"></a>2、Set的安全性</h3><pre><code class="java">import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;

public class Test07UnsafeSet &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt; objects = new CopyOnWriteArraySet&lt;&gt;();
        for (int i = 0; i &lt; 10000; i++) &#123;
            new Thread(() -&gt;&#123;
                objects.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(objects.size());
            &#125;, String.valueOf(i)).start();
        &#125;

    &#125;
&#125;
</code></pre>
<p>同样HashSet也是非线程安全的，解决方法：</p>
<ul>
<li>使用Collections.synchronizedSet(new HashSet&lt;&gt;())</li>
<li>使用CopyOnWriteArraySet，基于CopyOnWriteArrayList实现，效率比HashSet低（用这个）</li>
</ul>
<h3 id="3、Map的安全性"><a href="#3、Map的安全性" class="headerlink" title="3、Map的安全性"></a>3、Map的安全性</h3><pre><code class="java">import java.util.*;

public class Test08UnsafeMap &#123;
    public static void main(String[] args) &#123;
        Map&lt;String, String&gt; objects = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; 10000; i++) &#123;
            new Thread(() -&gt;&#123;
                objects.put(UUID.randomUUID().toString().substring(0, 5), UUID.randomUUID().toString().substring(0, 5));
                System.out.println(objects.size());
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;
</code></pre>
<p>HashMap是非线程安全的，解决方法：</p>
<ul>
<li>使用Collections.synchronizedMap(new HashMap&lt;&gt;())</li>
<li>使用ConcurrentHashMap（用这个）</li>
</ul>
<h2 id="四、Callable"><a href="#四、Callable" class="headerlink" title="四、Callable"></a>四、Callable</h2><h4 id="（1）Callable和Runnable的区别："><a href="#（1）Callable和Runnable的区别：" class="headerlink" title="（1）Callable和Runnable的区别："></a>（1）Callable和Runnable的区别：</h4><ul>
<li>Callable可以有返回值</li>
<li>Callable可以抛出异常</li>
<li>调用方法不同，Callable由call()调用，Runnable由run()调用</li>
</ul>
<h4 id="（2）Callable的使用"><a href="#（2）Callable的使用" class="headerlink" title="（2）Callable的使用"></a>（2）Callable的使用</h4><pre><code class="java">package net.yury757;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class Test09Callable implements Callable&lt;String&gt; &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        FutureTask futureTask = new FutureTask(new Test09Callable());
        new Thread(futureTask).start();
        new Thread(futureTask).start();
        String o = (String)futureTask.get();
        System.out.println(&quot;main方法：&quot; + o);
    &#125;

    @Override
    public String call() throws Exception &#123;
        System.out.println(&quot;方法内部：asdfsdf&quot;);
        return &quot;asdfsdf&quot;;
    &#125;
&#125;
</code></pre>
<p>注意点：</p>
<ul>
<li>同时使用两次<code>new Thread(futureTask).start();</code>时，只会输出一次</li>
<li><code>futureTask.get();</code>方法可能会被阻塞，如果call()方法内部是耗时操作的话</li>
</ul>
<h2 id="五、三大常用辅助类"><a href="#五、三大常用辅助类" class="headerlink" title="五、三大常用辅助类"></a>五、三大常用辅助类</h2><h3 id="1、CountDownLatch"><a href="#1、CountDownLatch" class="headerlink" title="1、CountDownLatch"></a>1、CountDownLatch</h3><p>这是一个减法计数器类。构造函数接受一个int参数，表示初始数量；countDown()方法将计数器减1；await()方法会阻塞当前线程，只有当计数器为0时，才会被唤醒并继续往下执行。</p>
<p>如下是一个简单测试类，只有当所有线程都完成了工作，才能输出close the door。</p>
<pre><code class="java">package net.yury757;

import java.util.concurrent.CountDownLatch;

public class Test10CountDownLatch &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 0; i &lt; 6; i++) &#123;
            new Thread(() -&gt; &#123;
                System.out.println(&quot;Person &quot; + Thread.currentThread().getName() + &quot; go out&quot;);
                // 计数器减1
                countDownLatch.countDown();
            &#125;, String.valueOf(i)).start();
        &#125;

        // 等待计数器归零，才会继续向下执行
        countDownLatch.await();

        System.out.println(&quot;close the door&quot;);
    &#125;
&#125;
</code></pre>
<h3 id="2、CyclicBarrier"><a href="#2、CyclicBarrier" class="headerlink" title="2、CyclicBarrier"></a>2、CyclicBarrier</h3><p>循环阻塞。使当线程实现全部<font color="Red">彼此等待</font>直到达到一个共同的屏障点的辅助类。有点像加法计数器，全部线程都到达了一个准备好了的状态，则就会执行最终线程。</p>
<pre><code class="java">package net.yury757;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * 集齐七颗龙珠召唤神龙
 */
public class Test11CyclicBarrier &#123;
    public static void main(String[] args) &#123;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123;
            System.out.println(&quot;召唤神龙成功&quot;);
        &#125;);

        for (int i = 0; i &lt; 7; i++) &#123;
            final int tmp = i;
            new Thread(() -&gt; &#123;
                System.out.println(&quot;收集到了第&quot; + Thread.currentThread().getName() + &quot;颗龙珠&quot;);
                try &#123;
                    cyclicBarrier.await();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; catch (BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3、Semaphore"><a href="#3、Semaphore" class="headerlink" title="3、Semaphore"></a>3、Semaphore</h3><p>信号量。类似排队系统，指定一个最大容量，先进来的可以处理，直到到达最大容量，后面的等待，当里面有元素释放时，后面的元素才能进入处理。acquire()放入元素，如果容量满了则等待；release()方法释放元素，唤醒其他等待线程。</p>
<pre><code class="java">package net.yury757;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class Test12Semaphore &#123;
    public static void main(String[] args) &#123;
        // 默认线程数量
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i &lt; 6; i++) &#123;
            new Thread(() -&gt; &#123;
                try &#123;
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;);

                    TimeUnit.SECONDS.sleep(2);

                    System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    semaphore.release();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="六、读写锁"><a href="#六、读写锁" class="headerlink" title="六、读写锁"></a>六、读写锁</h2><p>接口：ReadWriteLock</p>
<p>实现类：ReentrantReadWriteLock，维护了一对关联的lock，一个只用于读（read lock，共享锁），一个只用于写（write lock，独占锁），read lock可以允许多个线程同时读，而write lock同一个时间点只允许一个线程写。</p>
<p>读-读：可以共存</p>
<p>读-写：不能同时，需排队</p>
<p>写-写：不能同时，需排队</p>
<p>独占锁（写锁）：一次只能被一个线程占有</p>
<p>共享锁（读锁）：可以被多个线程同时占有</p>
<pre><code class="java">package net.yury757;

import jdk.internal.org.objectweb.asm.tree.FieldInsnNode;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class Test13ReadWriteLock &#123;
    public static void main(String[] args) &#123;
        MyCacheLock cache = new MyCacheLock();
        for (int i = 0; i &lt; 500; i++) &#123;
            final int tmp = i;
            new Thread(() -&gt; &#123;
                cache.put(tmp + &quot;&quot;, tmp);
            &#125;, String.valueOf(i)).start();
        &#125;

        for (int i = 0; i &lt; 500; i++) &#123;
            final int tmp = i;
            new Thread(() -&gt; &#123;
                Object o = cache.get(tmp + &quot;&quot;);
            &#125;, String.valueOf(i)).start();
        &#125;

    &#125;
&#125;

/**
 * 自定义缓存
 */
class MyCache&#123;
    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    public void put(String key, Object object)&#123;
        System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);
        this.map.put(key, object);
        System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key + &quot;OK&quot;);
    &#125;

    public Object get(String key)&#123;
        System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);
        Object o = this.map.get(key);
        System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key + &quot;OK&quot;);
        return o;
    &#125;
&#125;

/**
 * 自定义缓存
 */
class MyCacheLock&#123;

    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    // 读写锁：更加细粒度地控制读写
    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    // 写入操作，同一时间只允许一个线程写入
    public void put(String key, Object object)&#123;
        readWriteLock.writeLock().lock();
        try&#123;
            System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);
            this.map.put(key, object);
            System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key + &quot;OK&quot;);
        &#125;catch (Exception ex)&#123;
            ex.printStackTrace();
        &#125; finally &#123;
            readWriteLock.writeLock().unlock();
        &#125;
    &#125;

    // 读取操作，允许多个线程同时读
    public Object get(String key)&#123;
        readWriteLock.readLock().lock();
        Object o = null;
        try&#123;
            System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);
            o = this.map.get(key);
            System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key + &quot;OK&quot;);
        &#125;catch (Exception ex)&#123;
            ex.printStackTrace();
        &#125;finally &#123;
            readWriteLock.readLock().lock();
        &#125;
        return o;
    &#125;
&#125;
</code></pre>
<h2 id="七、阻塞队列"><a href="#七、阻塞队列" class="headerlink" title="七、阻塞队列"></a>七、阻塞队列</h2><p>接口：BlockingQueue</p>
<h3 id="1、ArrayBlockingQueue"><a href="#1、ArrayBlockingQueue" class="headerlink" title="1、ArrayBlockingQueue"></a>1、ArrayBlockingQueue</h3><p>该实现类基于数组实现。</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>不抛出异常</th>
<th>阻塞等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>add(E)</td>
<td>offer(E)</td>
<td>put(E)</td>
<td>offer(E, long, TimeUnit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(long, TimeUnit)</td>
</tr>
<tr>
<td>检查队首元素</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="2、LinkedBlockingQueue"><a href="#2、LinkedBlockingQueue" class="headerlink" title="2、LinkedBlockingQueue"></a>2、LinkedBlockingQueue</h3><p>该实现类基于链表实现，和上面的使用方式一样，略。</p>
<h3 id="3、SynchronousQueue"><a href="#3、SynchronousQueue" class="headerlink" title="3、SynchronousQueue"></a>3、SynchronousQueue</h3><p>SynchronousQueue为同步队列，和其他阻塞队列不太一样，SynchronousQueue在初始化时不需要传入capacity容量参数，可以认为SynchronousQueued的容量为0。</p>
<ul>
<li>put(E)方法会阻塞，等待其他线程来取出该元素。</li>
<li>take()方法调用时，如果之前没有put进来值，则take会阻塞；如果之前有put进来值，则会取出之前put进来的值。</li>
</ul>
<p><font color="Red">注意：在测试多线程和sleep时尽量不要用junit测试，junit对他们的支持有些问题，可以直接写一个main方法作为测试类。</font></p>
<h2 id="八、线程池（重点）"><a href="#八、线程池（重点）" class="headerlink" title="八、线程池（重点）"></a>八、线程池（重点）</h2><h3 id="1、池化技术"><a href="#1、池化技术" class="headerlink" title="1、池化技术"></a>1、池化技术</h3><p>线程池、连接池、内存池、对象池……</p>
<p>池化技术：事先准备好一些资源，有人要用，直接取出来使用，用完之后还回去即可。</p>
<p>好处：</p>
<ul>
<li>降低资源创建时的CPU等资源消耗</li>
<li>提高响应速度</li>
<li>方便管理</li>
</ul>
<p>线程池的优点：<font color="Red">线程复用、可以控制最大并发数、方便管理线程。</font></p>
<h3 id="2、七大参数"><a href="#2、七大参数" class="headerlink" title="2、七大参数"></a>2、七大参数</h3><p>创建线程池应使用如下构造方法自定义创建线程池，而不能使用后面会说的Executors来创建。</p>
<pre><code class="java">/**
 * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial
 * parameters.
 *
 * @param corePoolSize the number of threads to keep in the pool, even
 *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set
 * @param maximumPoolSize the maximum number of threads to allow in the
 *        pool
 * @param keepAliveTime when the number of threads is greater than
 *        the core, this is the maximum time that excess idle threads
 *        will wait for new tasks before terminating.
 * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument
 * @param workQueue the queue to use for holding tasks before they are
 *        executed.  This queue will hold only the &#123;@code Runnable&#125;
 *        tasks submitted by the &#123;@code execute&#125; method.
 * @param threadFactory the factory to use when the executor
 *        creates a new thread
 * @param handler the handler to use when execution is blocked
 *        because the thread bounds and queue capacities are reached
 * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;
 *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;
 *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;
 *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt;
 *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;
 * @throws NullPointerException if &#123;@code workQueue&#125;
 *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null
 */
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) &#123;
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
&#125;
</code></pre>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数类型</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>维持在线程池中的核心线程数，即使是空闲状态，也会保留在线程池中</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>int</td>
<td>线程池中允许容纳的最大线程。提交任务时，若发现任务阻塞队列满了时，线程池就会进行扩容，但不能超过这个最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>当线程池中的线程数超过核心线程数时，空闲线程的留存时间，当线程处于空闲状态超过这个时间时，会移除这个线程，直到总线程数等于核心线程数</td>
</tr>
<tr>
<td>unit</td>
<td>TimeUnit</td>
<td>keepAliveTime参数的单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>BlockingQueue&lt;Runnable&gt;</td>
<td>任务阻塞队列，当用户提交执行的任务数超过核心线程数时，剩余任务就会在队列中排队等待</td>
</tr>
<tr>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>创建线程的工厂类</td>
</tr>
<tr>
<td>handler</td>
<td>RejectedExecutionHandler</td>
<td>当任务队列达到上限或线程数达到最大线程数时的处理策略</td>
</tr>
</tbody></table>
<h3 id="3、线程池的工作流程"><a href="#3、线程池的工作流程" class="headerlink" title="3、线程池的工作流程"></a>3、线程池的工作流程</h3><ul>
<li><code>execute(Runnable command)</code>提交任务</li>
<li>判断核心线程中是否存在空闲的线程？若存在，则占用一个空闲线程来执行任务；否则进行下一步。</li>
<li>判断任务阻塞队列是否已满？若没有满，则将任务存入任务阻塞队列中等待；否则进行下一步。</li>
<li>判断整个线程池是否已满，若没有满，则创建一个新的线程执行任务；否则执行拒绝策略。</li>
</ul>
<h3 id="4、四种拒绝策略"><a href="#4、四种拒绝策略" class="headerlink" title="4、四种拒绝策略"></a>4、四种拒绝策略</h3><p>（1）抛异常</p>
<pre><code class="java">public static class AbortPolicy implements RejectedExecutionHandler &#123;
    /**
     * Creates an &#123;@code AbortPolicy&#125;.
     */
    public AbortPolicy() &#123; &#125;

    /**
     * Always throws RejectedExecutionException.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     * @throws RejectedExecutionException always
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;
        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +
                                             &quot; rejected from &quot; +
                                             e.toString());
    &#125;
&#125;
</code></pre>
<p>（2）在当前线程直接运行</p>
<pre><code class="java">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;
    /**
     * Creates a &#123;@code CallerRunsPolicy&#125;.
     */
    public CallerRunsPolicy() &#123; &#125;

    /**
     * Executes task r in the caller&#39;s thread, unless the executor
     * has been shut down, in which case the task is discarded.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;
        if (!e.isShutdown()) &#123;
            r.run();
        &#125;
    &#125;
&#125;
</code></pre>
<p>（3）剔除最早提交的那个任务，将新任务开启执行</p>
<pre><code class="java">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;
    /**
     * Creates a &#123;@code DiscardOldestPolicy&#125; for the given executor.
     */
    public DiscardOldestPolicy() &#123; &#125;

    /**
     * Obtains and ignores the next task that the executor
     * would otherwise execute, if one is immediately available,
     * and then retries execution of task r, unless the executor
     * is shut down, in which case task r is instead discarded.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;
        if (!e.isShutdown()) &#123;
            e.getQueue().poll();
            e.execute(r);
        &#125;
    &#125;
&#125;
</code></pre>
<p>（4）啥都不做，静默掠过</p>
<pre><code class="java">public static class DiscardPolicy implements RejectedExecutionHandler &#123;
    /**
     * Creates a &#123;@code DiscardPolicy&#125;.
     */
    public DiscardPolicy() &#123; &#125;

    /**
     * Does nothing, which has the effect of discarding task r.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;
    &#125;
&#125;
</code></pre>
<h3 id="5、注意"><a href="#5、注意" class="headerlink" title="5、注意"></a>5、注意</h3><p>线程池的创建不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>去创建。本质上<code>Executors</code>也是通过<code>new ThreadPoolExecutor</code>的方式来创建线程池，但是<code>Executors</code>把很多参数都封装好了，不能自定义某些参数，因此自己通过<code>new ThreadPoolExecutor</code>的方式创建的线程池在管理上更具有自主性，此外通过使用<code>Executors</code>封装好了的参数创建的线程池有诸多弊端，如下：</p>
<p>（1）<code>Executors.newFixedThreadPool(int nThreads)</code></p>
<p>这种创建方式创建的线程池的任务队列大小是<strong>Integer.MAX_VALUE</strong>，因此如果工作线程满了，如果同时涌来大量任务请求，则会导致任务队列积压，非常容易导致内存溢出、程序崩溃。</p>
<pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) &#123;
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
&#125;
</code></pre>
<p>（2）<code>Executors.newSingleThreadExecutor()</code></p>
<p>这种方式和上面那个一样，都是由于创建的是一个<strong>Integer.MAX_VALUE</strong>大小的任务队列，容易造成任务积压导致内存溢出。</p>
<pre><code class="java">public static ExecutorService newSingleThreadExecutor() &#123;
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;
</code></pre>
<p>（3）<code>Executors.newCachedThreadPool()</code></p>
<p>这种创建方式的任务队列是SynchronousQueue，线程池最大容量是<strong>Integer.MAX_VALUE</strong>，而我们知道SynchronousQueue是同步队列，只要有元素put进去，就会阻塞，此时就需要创建一个线程来处理这个请求，而线程池的最大值又设定为<strong>Integer.MAX_VALUE</strong>，因此同样如果请求突然增加，就会创建大量线程，容易造成内存溢出。</p>
<pre><code class="java">public static ExecutorService newCachedThreadPool() &#123;
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
&#125;
</code></pre>
<p>（4）<code>Executors.newScheduledThreadPool(int corePoolSize)</code></p>
<p>这种创建方式和上面一样，可创建的线程最大容量为<strong>Integer.MAX_VALUE</strong>，容易会因为大量创建线程而导致内存溢出。</p>
<pre><code class="java">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;
    return new ScheduledThreadPoolExecutor(corePoolSize);
&#125;

public ScheduledThreadPoolExecutor(int corePoolSize) &#123;
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
&#125;
</code></pre>
<p>总结如下：</p>
<p>以下四种方式都是用的默认的线程创建工厂和默认的拒绝策略。</p>
<table>
<thead>
<tr>
<th>创建线程池的方式</th>
<th>核心线程数</th>
<th>最大线程数</th>
<th>线程空闲超时时间</th>
<th>任务队列类</th>
<th>任务队列容量</th>
<th>OOM原因</th>
</tr>
</thead>
<tbody><tr>
<td>Executors.newFixedThreadPool(int nThreads)</td>
<td>自定义</td>
<td>自定义</td>
<td>0毫秒</td>
<td>LinkedBlockingQueue</td>
<td>Integer.MAX_VALUE</td>
<td>任务队列大量堆积导致OOM</td>
</tr>
<tr>
<td>Executors.newSingleThreadExecutor()</td>
<td>1</td>
<td>1</td>
<td>0毫秒</td>
<td>LinkedBlockingQueue</td>
<td>Integer.MAX_VALUE</td>
<td>任务队列大量堆积导致OOM</td>
</tr>
<tr>
<td>Executors.newCachedThreadPool()</td>
<td>0</td>
<td>Integer.MAX_VALUE</td>
<td>60秒</td>
<td>SynchronousQueue</td>
<td>0</td>
<td>创建大量线程导致OOM</td>
</tr>
<tr>
<td>Executors.newScheduledThreadPool(int corePoolSize)</td>
<td>自定义</td>
<td>Integer.MAX_VALUE</td>
<td>0微秒</td>
<td>DelayedWorkQueue</td>
<td>0</td>
<td>创建大量线程导致OOM</td>
</tr>
</tbody></table>
<h2 id="九、IO密集型程序和CPU密集型程序"><a href="#九、IO密集型程序和CPU密集型程序" class="headerlink" title="九、IO密集型程序和CPU密集型程序"></a>九、IO密集型程序和CPU密集型程序</h2><ul>
<li>CPU密集型也叫计算密集型，指的是系统运作大部分的状况是CPU Loading很高，I/O在很短的时间就可以完成，而CPU还有许多运算要处理。如计算圆周率程序、对视频音频进行编码解码的程序等，绝大部分时间都在进行CPU计算。开发CPU密集型程序尽量使用运行效率更高的编程语言，比如C/C++。</li>
<li>IO密集型是指程序绝大多数时间都花在IO上了，而IO结束后，CPU的计算在很短时间内就可以完成。常见的大部分任务都是IO密集型任务，比如web应用。开发IO密集型程序最好选择开发效率更高的编程语言，如python/java。</li>
</ul>
<h2 id="十、四大函数式接口"><a href="#十、四大函数式接口" class="headerlink" title="十、四大函数式接口"></a>十、四大函数式接口</h2><p><strong>函数式接口</strong>：只有一个方法的接口。</p>
<h3 id="1、Function"><a href="#1、Function" class="headerlink" title="1、Function"></a>1、Function</h3><pre><code class="java">public static void test01()&#123;
    Function&lt;Integer, String&gt; function = new Function&lt;Integer, String&gt;() &#123;
        @Override
        public String apply(Integer o) &#123;
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i &lt; o; i++) &#123;
                sb.append(&quot;1&quot;);
            &#125;
            return sb.toString();
        &#125;
    &#125;;

    Function&lt;Integer, String&gt; function2 = (Integer o) -&gt;&#123;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; o; i++) &#123;
            sb.append(&quot;2&quot;);
        &#125;
        return sb.toString();
    &#125;;

    System.out.println(function.apply(2));
    System.out.println(function2.apply(4));
&#125;
</code></pre>
<h3 id="2、Predicate"><a href="#2、Predicate" class="headerlink" title="2、Predicate"></a>2、Predicate</h3><pre><code class="java">public static void test02()&#123;
    Predicate&lt;Float&gt; predicate1 = new Predicate&lt;Float&gt;() &#123;
        @Override
        public boolean test(Float o) &#123;
            return o &gt; 1000.2f;
        &#125;
    &#125;;

    Predicate&lt;Float&gt; predicate2 = (Float o) -&gt; &#123; return o &gt; 1000.2f; &#125;;

    System.out.println(predicate1.test(1000f));
    System.out.println(predicate1.test(1001f));
&#125;
</code></pre>
<h3 id="3、Consumer"><a href="#3、Consumer" class="headerlink" title="3、Consumer"></a>3、Consumer</h3><pre><code class="java">public static void test03()&#123;
    Consumer&lt;String[]&gt; consumer1 = new Consumer&lt;String[]&gt;() &#123;
        @Override
        public void accept(String[] strings) &#123;
            for (String s : strings) &#123;
                System.out.println(s);
            &#125;
        &#125;
    &#125;;
    Consumer&lt;String[]&gt; consumer2 = (String[] strings) -&gt; &#123;
        for (String s : strings) &#123;
            System.out.println(s);
        &#125;
    &#125;;
    consumer1.accept(new String[] &#123;&quot;123&quot;, &quot;456&quot;&#125;);
    consumer2.accept(new String[] &#123;&quot;abc&quot;, &quot;def&quot;&#125;);
&#125;
</code></pre>
<h3 id="4、Supplier"><a href="#4、Supplier" class="headerlink" title="4、Supplier"></a>4、Supplier</h3><pre><code class="java">public static void test04()&#123;
    Supplier&lt;String&gt; supplier1 = new Supplier&lt;String&gt;() &#123;
        @Override
        public String get() &#123;
            return &quot;suppplier1 =&gt; &quot; + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        &#125;
    &#125;;

    Supplier&lt;String&gt; supplier2 = () -&gt; &quot;suppplier2 =&gt; &quot; + UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);

    System.out.println(supplier1.get());
    System.out.println(supplier2.get());
&#125;
</code></pre>
<h2 id="十一、流式计算"><a href="#十一、流式计算" class="headerlink" title="十一、流式计算"></a>十一、流式计算</h2><p>大数据：存储 + 计算</p>
<p>java集合类、数据库等本质是用来存储东西的，计算都应交给流来操作。</p>
<pre><code class="java">public class Test19StreamCalculate &#123;
    public static void main(String[] args) &#123;
        test01();
    &#125;

    public static void test01()&#123;
        User u1 = new User(1, &quot;a&quot;, 21);
        User u2 = new User(2, &quot;b&quot;, 22);
        User u3 = new User(3, &quot;c&quot;, 23);
        User u4 = new User(4, &quot;d&quot;, 24);
        User u5 = new User(5, &quot;e&quot;, 25);
        User u6 = new User(6, &quot;f&quot;, 26);
        List&lt;User&gt; userList = Arrays.asList(u1, u2, u3, u4, u5, u6);
        // Lambda表达式、链式编程、函数式接口、Stream流式计算
        userList.stream()
                .filter(user -&gt; user.getId() % 2 == 0)                // 筛选id为偶数的用户
                .filter(user -&gt; user.getAge() &gt; 23)                   // 筛选年龄大于23的用户
                .map(user -&gt; user.getName().toUpperCase())            // 只保留名字
                .sorted((String s1, String s2) -&gt; s2.compareTo(s1))   // 对名字倒序排序
                .limit(1)                                             // 只取第一个
                .forEach(System.out::println);                        // 打印
    &#125;
&#125;

class User&#123;
    private int id;
    private String name;
    private int age;

    public int getId() &#123;
        return id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;

    public User(int id, String name, int age) &#123;
        this.id = id;
        this.name = name;
        this.age = age;
    &#125;
&#125;
</code></pre>
<h2 id="十二、ForkJoin"><a href="#十二、ForkJoin" class="headerlink" title="十二、ForkJoin"></a>十二、ForkJoin</h2><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><p>将一个大任务拆分成多个小任务，每个子任务分别执行，全部子任务结束后获取结果，再将所有结果汇总起来成最终结果。</p>
<p><img src="/images/FockJoin.png"></p>
<h3 id="2、特点：工作窃取"><a href="#2、特点：工作窃取" class="headerlink" title="2、特点：工作窃取"></a>2、特点：工作窃取</h3><p>子任务分配给其他很多线程后，不同线程执行完成的时间可能不一样，先完成的的线程会把未完成的线程的部分任务拿过来帮忙一起做。</p>
<p>里面维护的是双端队列，可以从两端取任务来执行。</p>
<h3 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h3><pre><code class="java">package net.yury757;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;
import java.util.stream.LongStream;

public class Test18FockJoin extends RecursiveTask&lt;Long&gt; &#123;
    private Long start;
    private Long end;

    // 临界值
    private Long temp = 10000L;

    public Test18FockJoin(Long start, Long end) &#123;
        this.start = start;
        this.end = end;
    &#125;

    public Long sum()&#123;
        long sum = 0L;
        for (Long i = start; i &lt;= end; i++) &#123;
            sum += i;
        &#125;
        return sum;
    &#125;

    @Override
    protected Long compute() &#123;
        if ((end - start) &lt; temp)&#123;
            long sum = 0L;
            for (Long i = start; i &lt;= end; i++) &#123;
                sum += i;
            &#125;
            return sum;
        &#125;else&#123;
            long middle = (start + end) / 2;
            Test18FockJoin test18FockJoin1 = new Test18FockJoin(start, middle);
            test18FockJoin1.fork();
            Test18FockJoin test18FockJoin2 = new Test18FockJoin(middle + 1, end);
            test18FockJoin2.fork();
            return test18FockJoin1.join() + test18FockJoin2.join();
        &#125;
    &#125;


    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        test03();
    &#125;

    /**
     * 普通计算方式
     * 500000000500000000
     * 3603毫秒
     */
    public static void test01()&#123;
        long starttime = System.currentTimeMillis();

        Test18FockJoin task = new Test18FockJoin(1L, 10_0000_0000L);
        Long res = task.sum();

        System.out.println(res);
        long endtime = System.currentTimeMillis();
        System.out.println(&quot;花费时间：&quot; + (endtime - starttime) + &quot;毫秒&quot;);
    &#125;

    /**
     * 使用forkjoin
     * 500000000500000000
     * 2133毫秒
     */
    public static void test02() throws ExecutionException, InterruptedException &#123;
        long starttime = System.currentTimeMillis();

        ForkJoinPool forkJoinPool = new ForkJoinPool();
        Test18FockJoin task = new Test18FockJoin(1L, 10_0000_0000L);
        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);
        Long res = task.get();

        System.out.println(res);
        long endtime = System.currentTimeMillis();
        System.out.println(&quot;花费时间：&quot; + (endtime - starttime) + &quot;毫秒&quot;);
    &#125;

    /**
     * 使用Stream并行流
     * 500000000500000000
     * 215毫秒
     */
    public static void test03()&#123;
        long starttime = System.currentTimeMillis();

        long res = LongStream.rangeClosed(1, 10_0000_0000L).parallel().reduce(0, Long::sum);

        System.out.println(res);
        long endtime = System.currentTimeMillis();
        System.out.println(&quot;花费时间：&quot; + (endtime - starttime) + &quot;毫秒&quot;);
    &#125;
&#125;
</code></pre>
<h2 id="十三、异步回调（Future）"><a href="#十三、异步回调（Future）" class="headerlink" title="十三、异步回调（Future）"></a>十三、异步回调（Future）</h2><p>Future接口：用来处理异步任务的，提供了检查异步任务是否完成、取消任务、是否被取消了、获取任务结果、在指定延迟内获取返回值等接口方法。</p>
<p>CompletableFuture为其中一个实现类，介绍两个方法：</p>
<pre><code class="java">// 没有返回值的异步回调
public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)&#123;&#125;

// 有返回值的异步回调
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) &#123;&#125;
</code></pre>
<pre><code class="java">package net.yury757;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * 异步调用：
 * 1、异步执行
 * 2、成功回调
 * 3、失败回调
 */
public class Test20Future &#123;

    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        // 无返回值的异步任务
        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;
            System.out.println(&quot;异步无返回值1&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;异步无返回值2&quot;);
        &#125;);
        System.out.println(&quot;同步任务&quot;);

        // 阻塞，直到获取结果
        Void unused = completableFuture.get();
        System.out.println(&quot;异步无返回值任务结束&quot;);

        // 有返回值的异步任务
        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;
            System.out.println(&quot;异步有返回值1&quot;);
            try &#123;
                TimeUnit.SECONDS.sleep(1);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;异步有返回值2&quot;);
            int a = 10 / 0;
            return 1024;
        &#125;);
        Integer res = completableFuture2.whenComplete((t, u) -&gt; &#123;
            System.out.println(&quot;t =&gt; &quot; + t);
            System.out.println(&quot;u =&gt; &quot; + u);
        &#125;).exceptionally((ex) -&gt; &#123;
            System.out.println(ex.getMessage());
            return 233;
        &#125;).get();

        System.out.println(res);
    &#125;
&#125;
</code></pre>
<h2 id="十四、JMM（重要）"><a href="#十四、JMM（重要）" class="headerlink" title="十四、JMM（重要）"></a>十四、JMM（重要）</h2><h3 id="1、什么是JMM"><a href="#1、什么是JMM" class="headerlink" title="1、什么是JMM"></a>1、什么是JMM</h3><p>JMM是java memory model，即java内存模型，<font color="Red">因为在不同硬件厂商和不同操作系统下，程序对内存的访问会有一定的差异，会造成相同代码运行出来的结果不一样，因此JMM屏蔽掉了这些差异，实现了java在不同的平台下都能达到一致的效果。</font></p>
<p>Java内存模型规定<strong>所有的变量都存储在主内存</strong>中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，<strong>线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行，然后刷回到主存。线程不能直接读写主内存中的变量</strong>。</p>
<p><img src="/images/JMM.png"></p>
<h3 id="2、八种内存交互操作"><a href="#2、八种内存交互操作" class="headerlink" title="2、八种内存交互操作"></a>2、八种内存交互操作</h3><p>JMM八种内存交互操作：</p>
<ul>
<li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li>
<li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li>
<li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li>
<li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li>
<li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li>
<li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
<li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
</ul>
<p><img src="/images/JMM%E5%85%AB%E7%A7%8D%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C.png"></p>
<p>8种内存交互操作制定的规则：</p>
<ul>
<li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li>
<li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li>
<li>不允许线程将没有assign的数据从工作内存同步到主内存。</li>
<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li>
<li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li>
<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li>
<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li>
<li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li>
</ul>
<h3 id="3、三个特征：可见性、原子性、有序性"><a href="#3、三个特征：可见性、原子性、有序性" class="headerlink" title="3、三个特征：可见性、原子性、有序性"></a>3、三个特征：可见性、原子性、有序性</h3><h4 id="（1）volatile保证可见性"><a href="#（1）volatile保证可见性" class="headerlink" title="（1）volatile保证可见性"></a>（1）volatile保证可见性</h4><p>可见性，是指在有多个线程对内存中的同一个变量进行操作时，如果内存中的值被修改了，其他线程可以立即直到这个值被改掉了，并获取最新的值。</p>
<p>如下代码示例，这个程序永远不会结束。即这种情况下是没保证可见性的。</p>
<pre><code class="java">package net.yury757;

import java.util.concurrent.TimeUnit;

public class Test21Volatile &#123;
    public static int num = 0;
    public static void main(String[] args) throws InterruptedException &#123;
        Thread thread = new Thread(() -&gt; &#123;
            while (num == 0)&#123;
            &#125;
            System.out.println(&quot;线程2：&quot; + num);
        &#125;);
        thread.start();
        TimeUnit.SECONDS.sleep(1);
        num = 1;
        System.out.println(&quot;主线程：&quot; + num);
    &#125;
&#125;
</code></pre>
<p>在某些情况下，使用synchronized和lock是可以保证可见性的，但是上面例子不行。</p>
<p>上面这个例子只要在num的定义加上volatile关键字即可。</p>
<pre><code class="java">public volatile static int num = 0;
</code></pre>
<h4 id="（2）Atomic类保证原子性"><a href="#（2）Atomic类保证原子性" class="headerlink" title="（2）Atomic类保证原子性"></a>（2）Atomic类保证原子性</h4><p>原子性：不可分割性，在数据库的事务中，指的是一个事务的所有操作要么全部完成，要么全部不完成。而线程的原子性是指<font color="Red">一个线程在执行任务时，是不可分割，不可中断的，且不能被其他线程所干扰，这个线程中的所有操作要么全部成功，要么全部失败。</font></p>
<p>volatile是无法保证原子性的。</p>
<pre><code class="java">package net.yury757;

public class Test22Atomic &#123;
    public volatile static int num = 0;
    public static void add()&#123;
        num++;
    &#125;
    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(() -&gt; &#123;
                for (int j = 0; j &lt; 1000; j++) &#123;
                    add();
                &#125;
            &#125;).start();
        &#125;

        while(Thread.activeCount() &gt; 2)&#123;
            Thread.yield();
        &#125;

        System.out.println(num);
    &#125;
&#125;
</code></pre>
<p>即多个线程同时操作同一个资源时，会出现资源错误。对于这种问题，常见的在add方法那里用synchronized和lock来解决。</p>
<p>然而还有一种办法就是使用Atomic类，使用<font color="Red">原子类的速度一般情况下比使用锁的效率高</font>。如下：</p>
<pre><code class="java">package net.yury757;

import java.util.concurrent.atomic.AtomicInteger;

public class Test22Atomic &#123;
    public volatile static AtomicInteger num = new AtomicInteger();
    public static void add()&#123;
        num.getAndIncrement(); // AtomicInteger类的+1方法，底层用的CAS
    &#125;
    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(() -&gt; &#123;
                for (int j = 0; j &lt; 1000; j++) &#123;
                    add();
                &#125;
            &#125;).start();
        &#125;

        while(Thread.activeCount() &gt; 2)&#123;
            Thread.yield();
        &#125;

        System.out.println(num);
    &#125;
&#125;
</code></pre>
<p>具体探究见CAS章节。</p>
<h4 id="（3）volatile保证有序性（禁止指令重排）"><a href="#（3）volatile保证有序性（禁止指令重排）" class="headerlink" title="（3）volatile保证有序性（禁止指令重排）"></a>（3）volatile保证有序性（禁止指令重排）</h4><p>什么是有序性，即你编写的每一行源代码被计算机CPU拿去执行的顺序是和源代码顺序一致的。</p>
<p>指令重排是指<strong>你写的程序，计算机并不是按照你写的那样去执行的，即计算机会对你的代码重新架构再执行。</strong></p>
<pre><code class="java">源代码 —&gt; 编译器的优化重排 —&gt; 指令并行也可能会重排 —&gt; 内存系统也可能会重排 —&gt; 执行
</code></pre>
<p>计算机对我们的代码做指令重排就没办法保证有序性，指令重排可能会产生一些不可预知的问题。</p>
<p>在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性，即禁止计算机对某些代码做指令重排。</p>
<h2 id="十五、深究单例模式"><a href="#十五、深究单例模式" class="headerlink" title="十五、深究单例模式"></a>十五、深究单例模式</h2><h3 id="1、饿汉式单例模式"><a href="#1、饿汉式单例模式" class="headerlink" title="1、饿汉式单例模式"></a>1、饿汉式单例模式</h3><p>这种模式很少出现线程安全问题，缺点是类一加载就会初始化一个对象，有时候每用到这个对象时，也会一直存在，浪费空间。</p>
<pre><code class="java">package net.yury757;

/**
 * 饿汉式单例模式
 */
public class Test23Hungry &#123;
    private Test23Hungry()&#123;

    &#125;
    private final static Test23Hungry hungry = new Test23Hungry();

    public static Test23Hungry getInstance()&#123;
        return hungry;
    &#125;
&#125;
</code></pre>
<h3 id="2、懒汉式单例模式"><a href="#2、懒汉式单例模式" class="headerlink" title="2、懒汉式单例模式"></a>2、懒汉式单例模式</h3><p>懒汉式单例模式是指要用到这个实例时再初始化。如果私有构造方法没有synchronized时，多个线程同时getInstance时会有线程安全问题。</p>
<p>同时加上volatile防止指令重排导致的线程安全问题。</p>
<pre><code class="java">package net.yury757;

/**
 * 懒汉式单例模式
 */
public class Test24Lazy &#123;
    private Test24Lazy()&#123;
        System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;);
    &#125;
    // 加volatile禁止指令重排导致的线程安全问题
    private volatile static Test25DCLLazy lazy = null;

    // 线程不安全
//    public static Test24Lazy getInstance()&#123;
//        if (lazy == null)&#123;
//            lazy = new Test24Lazy();
//        &#125;
//        return lazy;
//    &#125;

    // 线程安全
    public static Test24Lazy getInstance()&#123;
        // 双重检测
        if (lazy == null)&#123;
            // 静态方法，因此要锁住class
            synchronized (Test24Lazy.class)&#123;
                if (lazy == null)&#123;
                    lazy = new Test24Lazy();
                &#125;
            &#125;
        &#125;
        return lazy;
    &#125;

    public static void main(String[] args) &#123;
        for (int i = 0; i &lt; 10; i++) &#123;
            new Thread(() -&gt; &#123;
                // 多线程会有问题，可能多次初始化这个类，需要对getInstance方法加锁
                Test24Lazy lazy = Test24Lazy.getInstance();
            &#125;).start();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="3、反射对单例模式的影响"><a href="#3、反射对单例模式的影响" class="headerlink" title="3、反射对单例模式的影响"></a>3、反射对单例模式的影响</h3><p>对于例模式，正常情况下是安全的，但是如果通过反射来创建实例，即打破了单例模式。如下：</p>
<pre><code class="java">package net.yury757;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Test25ReflectionHungry &#123;
    private Test25ReflectionHungry()&#123;
        System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;);
    &#125;
    private volatile static Test25ReflectionHungry hungry = new Test25ReflectionHungry();

    public static Test25ReflectionHungry getInstance()&#123;
        return hungry;
    &#125;

    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;
        Test25ReflectionHungry single = Test25ReflectionHungry.getInstance();
        Constructor&lt;Test25ReflectionHungry&gt; constructor = Test25ReflectionHungry.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        Test25ReflectionHungry single2 = constructor.newInstance();
        System.out.println(single);
        System.out.println(single2);
    &#125;
&#125;
</code></pre>
<p>对于饿汉式单例模式，直接把构造函数改成如下即可：</p>
<pre><code class="java">private Test25ReflectionHungry()&#123;
    synchronized (Test25ReflectionHungry.class)&#123;
        System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;);
        if (hungry != null)&#123;
            throw new RuntimeException(&quot;不要尝试使用反射创建对象!&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>但是对于懒汉式单例模式，改成上面这种，有一个问题就是如果一开始就使用反射来创建对象的话依旧没办法阻止。</p>
<p>因此对于懒汉式单例模式可以尝试通过使用使用如下修改：</p>
<p>但是依旧可以通过反射修改flag的值来破坏单例模式，即使通过对flag的值进行加密等其他操作，通过反射几乎总是可以破坏这种单例模式。</p>
<pre><code class="java">package net.yury757;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Test26ReflectionLazy &#123;
    private static boolean flag = false;
    private Test26ReflectionLazy()&#123;
        synchronized (Test25ReflectionHungry.class)&#123;
            System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;);
            if (flag == false)&#123;
                flag = true;
            &#125;else&#123;
                throw new RuntimeException(&quot;不要尝试使用反射创建对象!&quot;);
            &#125;
        &#125;
    &#125;
    private volatile static Test26ReflectionLazy lazy = null;

    public static Test26ReflectionLazy getInstance()&#123;
        // 双重检测
        if (lazy == null)&#123;
            // 静态方法，因此要锁住class
            synchronized (Test24Lazy.class)&#123;
                if (lazy == null)&#123;
                    lazy = new Test26ReflectionLazy();
                    flag = true;
                &#125;
            &#125;
        &#125;
        return lazy;
    &#125;

    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;
        Constructor&lt;Test26ReflectionLazy&gt; constructor = Test26ReflectionLazy.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        Test26ReflectionLazy single = constructor.newInstance();
        Test26ReflectionLazy single2 = constructor.newInstance();
        System.out.println(single);
        System.out.println(single2);
    &#125;
&#125;
</code></pre>
<h3 id="4、通过enum来实现安全的单例模式"><a href="#4、通过enum来实现安全的单例模式" class="headerlink" title="4、通过enum来实现安全的单例模式"></a>4、通过enum来实现安全的单例模式</h3><pre><code class="java">package net.yury757;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public enum Test27EnumSingle &#123;
    INSTANCE;
    private volatile Test27ReflectionLazy lazy = null;

    public Test27ReflectionLazy getInstance()&#123;
        return lazy;
    &#125;

    private Test27EnumSingle()&#123;
        if (lazy == null) &#123;
            lazy = new Test27ReflectionLazy();
        &#125;
    &#125;

    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;
        System.out.println(Test27EnumSingle.INSTANCE.getInstance());
        // 通过反射内部类无法获取对象
        Constructor&lt;Test27ReflectionLazy&gt; constructor = Test27ReflectionLazy.class.getDeclaredConstructor(null);
        constructor.setAccessible(true);
        Object single = constructor.newInstance();
        Object single2 = constructor.newInstance();
        System.out.println(single);
        System.out.println(single2);
    &#125;
&#125;

class Test27ReflectionLazy &#123;
    Test27ReflectionLazy()&#123;
        synchronized (Test27ReflectionLazy.class)&#123;
            System.out.println(Thread.currentThread().getName() + &quot; - OK&quot;);
            if (Test27EnumSingle.INSTANCE != null &amp;&amp; Test27EnumSingle.INSTANCE.getInstance() != null)&#123;
                throw new RuntimeException(&quot;不要尝试使用反射创建对象!&quot;);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="十六、CAS"><a href="#十六、CAS" class="headerlink" title="十六、CAS"></a>十六、CAS</h2><h3 id="1、乐观锁和悲观锁"><a href="#1、乐观锁和悲观锁" class="headerlink" title="1、乐观锁和悲观锁"></a>1、乐观锁和悲观锁</h3><p>悲观锁：线程开始执行第一步就是获取锁，一旦获得锁，其他的线程进入后就会阻塞等待锁。synchronized和实现了Lock接口的各种锁都是悲观锁。</p>
<p>乐观锁：线程执行的时候不会加锁，假设没有冲突去完成某项操作，如果因为冲突失败了就重试，最后直到成功为止。如自旋锁。</p>
<h3 id="2、什么是CAS"><a href="#2、什么是CAS" class="headerlink" title="2、什么是CAS"></a>2、什么是CAS</h3><p>CAS（Compare-And-Swap）是比较并交换的意思，它是一条 CPU 并发原语（Unsafe类中的三个方法如下），用于判断内存中某个值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p>
<p>CAS机制当中使用了3个基本操作数：内存地址V（由一个Object和一个long型的offset决定），旧的预期值A，计算后要修改后的新值B。</p>
<pre><code class="java">// var1和var2找到对应的内存地址
// var4为预期值
// var5为新值
// 如果内存中的值和预期值相同，则把内存中的值修改为var5
public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);

public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);

public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);
</code></pre>
<p>比如我们在探究Atomic保证原子性时发现，使用int型的num++并不是原子操作，可能产生线程安全问题，而num.getAndIncrement()方法则是原子操作，其底层通过自旋锁+CAS来实现。</p>
<pre><code class="java">public final int getAndIncrement() &#123;
    return unsafe.getAndAddInt(this, valueOffset, 1);
&#125;

// 自旋锁 + CAS
public final int getAndAddInt(Object var1, long var2, int var4) &#123;
    int var5;
    do &#123;
        var5 = this.getIntVolatile(var1, var2);
    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
&#125;

public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
</code></pre>
<p>解释如下：</p>
<p>先把内存中的这个对象的值取出来，然后把这个值和内存中的值比较，如果相同，则设置为新的值并退出循环，如果不同则继续循环（自旋锁，会一直尝试比较并修改，直到成功为止）。<font color="Red">有人会觉得这不明显相同吗，其实并不是。在高并发的情况下，线程1把这个值取出来了，比如是100，下一时刻线程2可能已经把这个值更新掉了，比如是200，如果线程1仍然更新为101的话就错了，应该在线程2的操作的基础上再+1，即201。因此必须把取出来的值和内存上的值再比较一遍再更新，而这个比较再更新的操作则是一个cpu的原子操作，即在cpu内部是一个不可分割的操作，如果比较发现不同，说明别人把这个东西改过了，因此必须重来。</font></p>
<h3 id="3、ABA问题"><a href="#3、ABA问题" class="headerlink" title="3、ABA问题"></a>3、ABA问题</h3><p>ABA问题是指，上面说的线程2把内存中的值改成了200，但是如果中间还有一个线程3又把值从200改回到了100，<font color="Red">即线程1执行过程中，内存中的值修改过两次，从100到200，又从200回到100。</font>线程1再执行比较时发现值和预期相同，于是就更新到101。</p>
<p><font color="Red">但是这个100已经不是原来的100了。</font>这就是ABA问题。</p>
<p>ABA问题在大多数情况下不会对程序产生太大的影响，通过带时间戳的原子类可以解决ABA问题，其内部维护了一个int型的时间戳，CAS操作需要再对比时间戳，因此可以通过时间戳来判断内存中的值是否被改动过。</p>
<pre><code class="java">public class AtomicStampedReference&lt;V&gt; &#123;
    private static class Pair&lt;T&gt; &#123;
        final T reference;
        final int stamp;
        private Pair(T reference, int stamp) &#123;
            this.reference = reference;
            this.stamp = stamp;
        &#125;
        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;
            return new Pair&lt;T&gt;(reference, stamp);
        &#125;
    &#125;
    private volatile Pair&lt;V&gt; pair;
&#125;
</code></pre>
<h2 id="十七、自旋锁"><a href="#十七、自旋锁" class="headerlink" title="十七、自旋锁"></a>十七、自旋锁</h2><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<font color="Red">被“阻塞”的线程并不是真正停了，而是一直在做循环判断的“等待”（busy waiting），直到其他线程解锁。</font></p>
<pre><code class="java">package net.yury757;

import java.util.concurrent.atomic.AtomicReference;

public class Test29SpinLockDemo &#123;
    AtomicReference&lt;Thread&gt; reference = new AtomicReference&lt;&gt;();

    // 加锁
    public void lock()&#123;
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName() + &quot; =&gt; 尝试获取锁&quot;);
        while (!reference.compareAndSet(null, thread))&#123;&#125;
        System.out.println(thread.getName() + &quot; =&gt; 获取锁成功&quot;);
    &#125;

    // 解锁
    public void unlock()&#123;
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName() + &quot; =&gt; 尝试解锁&quot;);
        boolean b = reference.compareAndSet(thread, null);
        if (b)&#123;
            System.out.println(thread.getName() + &quot; =&gt; 解锁成功&quot;);
        &#125;else&#123;
            System.out.println(thread.getName() + &quot; =&gt; 解锁失败，当前线程没有被加锁&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<p>解释：</p>
<p>当第一个线程获取到锁时，reference为空，因此lock方法中reference.compareAndSet(null, thread)返回true，则while循环失败退出。</p>
<p>当第二线程尝试获取锁时，reference不为空，则reference.compareAndSet(null, thread)返回false，while则会一直循环。</p>
<p>当第一个线程解锁时，会判断reference中的线程引用是否是当前线程，然后将reference置为null。此时下一刻第二个线程的循环就判断成功了，则成功获取到了锁。</p>
<p>当有多个线程尝试竞争锁时，由于reference.compareAndSet(null, thread)是原子操作，因此只可能有一个线程成功获取锁。</p>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/java/spring/Spring-study">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  Spring-study
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/bigdata/hadoop/hadoop-study">
                hadoop-study
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>