<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		JVM-1.8-memory-and-garbage-collect | 
	 
	Yury&#39;s Blog
	</title>
	
	<!-- keywords,description -->
	 
		<meta name="description" content="blog of usual study" />
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Yury's Blog" type="application/atom+xml">
</head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">Yury's Blog</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	
		<li class="menu-item">
			<a href="/tags" class="menu-item-link">标签</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/yury757" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Git
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										learngit
									</a>
									
							<ul>
								<li class="file">
									<a href="/Git/learngit/learn-git">
										learn-git
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										bigdata
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										clickhouse
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/clickhouse/clickhouse">
										clickhouse
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										hadoop
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/hadoop/hadoop-study">
										hadoop-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										hbase
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/hbase/HBase-study">
										HBase-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										kafka
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/kafka/kafka">
										kafka
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										zookeeper
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/zookeeper/zookeeper-study">
										zookeeper-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										computer-science
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Computer-Networking
									</a>
									
							<ul>
								<li class="file">
									<a href="/computer-science/Computer-Networking/Computer-Networking">
										Computer-Networking
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										database
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										mysql
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL中的exists与in的使用
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E4%B8%AD%E7%9A%84exists%E4%B8%8Ein%E7%9A%84%E4%BD%BF%E7%94%A8/MySQL%E4%B8%AD%E7%9A%84exists%E4%B8%8Ein%E7%9A%84%E4%BD%BF%E7%94%A8">
										MySQL中的exists与in的使用
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL备份-Linux版
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E5%A4%87%E4%BB%BD-Linux%E7%89%88/MySQL%E5%A4%87%E4%BB%BD-linux%E7%89%88">
										MySQL备份-linux版
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL日期格式化
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/MySQL%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96">
										MySQL日期格式化
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL查询执行计划详解-explain
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3-explain/MySQL%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3-explain">
										MySQL查询执行计划详解-explain
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL迁移数据目录
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/MySQL%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95">
										MySQL迁移数据目录
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										《高性能MySQL》
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第1章-MySQL架构与历史
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC1%E7%AB%A0-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2">
										第一章-MySQL架构与历史
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第2章-MySQL基准测试
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC2%E7%AB%A0-MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">
										第二章 MySQL基准测试
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第3章-服务器性能剖析
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC3%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90">
										第三章-服务器性能剖析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第4章-Schema与数据类型优化
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC4%E7%AB%A0-Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/%E7%AC%AC%E5%9B%9B%E7%AB%A0-Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96">
										第四章-Schema与数据类型优化
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第5章-创建高性能的索引
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC5%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95">
										第五章-创建高性能的索引
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										postgresql
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/postgresql/postgresql">
										postgresql
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										JVM
									</a>
									
							<ul>
								<li class="file active">
									<a href="/java/JVM/jvm-1.8">
										jvm-1.8
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										SSM-Build
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/SSM-Build/SSM-Build">
										SSM-Build
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java_JUC
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/java_JUC/Java_JUC-study">
										Java_JUC-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java_NIO
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/java_NIO/Java_NIO-study">
										Java_NIO-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/java/java%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE">
										java常用配置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										mybatis
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/mybatis/mybatis-study">
										mybatis-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										springMVC
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/springMVC/SpringMVC-Study">
										SpringMVC-Study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										springboot
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/springboot/springboot-study">
										springboot-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										spring
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/spring/Spring-study">
										Spring-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/jetbrains%E7%B3%BB%E5%88%97IDE%E6%8E%A8%E8%8D%90%E8%AE%BE%E7%BD%AE">
										jetbrains系列IDE推荐设置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										linux
									</a>
									
							<ul>
								<li class="file">
									<a href="/linux/linux%E5%91%BD%E4%BB%A4">
										linux命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/linux/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%9A%84%E7%BB%8F%E5%8E%86">
										记一次服务器被挖矿的经历
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										operating-support
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										docker
									</a>
									
							<ul>
								<li class="file">
									<a href="/operating-support/docker/docker">
										docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										project
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										flink_data_warehouse
									</a>
									
							<ul>
								<li class="file">
									<a href="/project/flink_data_warehouse/flink_data_warehouse">
										flink_data_warehouse
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	jvm-1.8
</h1>
<div class="article-meta">
	
	<span>Yury</span>
	<span>2021-09-20 00:00:00</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true">
                        <a href="/categories/java/">java</a>
                        </i>
                      
                    </span>
                
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<p>JVM版本：HotSpot 1.8</p>
<p>推荐书籍：</p>
<ul>
<li>《The Java Virtual Machine Specification》（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">The Java® Virtual Machine Specification (oracle.com)</a>）</li>
<li>《深入理解java虚拟机——JVM高级特性与最佳实践》</li>
</ul>
<h2 id="一、JVM简介"><a href="#一、JVM简介" class="headerlink" title="一、JVM简介"></a>一、JVM简介</h2><h3 id="1、JVM是什么"><a href="#1、JVM是什么" class="headerlink" title="1、JVM是什么"></a>1、JVM是什么</h3><p>狭义上来说，JVM是java运行的平台。</p>
<p>广义上来说，It is the component of the technology responsible for its hardware- and operating system independence, the small size of its compiled code, and its ability to protect users from malicious programs. 即JVM是一个操作系统或硬件与用户程序之间的一个接口或平台，这个接口可以使用户的程序与不同的操作系统或硬件独立开，只要程序运行在这个平台上，就可以对不同的操作系统或硬件进行相同的操作，就像一个虚拟的计算机，可以执行一系列的虚拟计算机指令。</p>
<p>虚拟机分为两类：</p>
<ul>
<li>系统虚拟机，虚拟一个操作系统的运行环境（模拟硬件），如VMWare，是操作系统的运行环境，可以安装window、Linux等。</li>
<li>程序虚拟机，虚拟一个普通应用程序的运行环境（模拟软件），如JVM，是二进制字节码的运行环境。</li>
</ul>
<p>java SE架构：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/">Java Platform Standard Edition 8 Documentation (oracle.com)</a>，JVM处于最底层，即java的运行环境。</p>
<h3 id="2、JVM厂商"><a href="#2、JVM厂商" class="headerlink" title="2、JVM厂商"></a>2、JVM厂商</h3><p>JVM和JVM规范（JVM Specification）不一样，JVM规范是一套规范，并不是JVM本身，而JVM是基于这套规范的实现，java官网上的JVM只是Oracle（Sun）对JVM规范的一个实现版本，不过还有其他厂商实现的JVM，如：</p>
<ul>
<li><p>Oracle HotSpot（<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/#java8">Java Downloads | Oracle</a>）（里面有很多历史，可以了解一下）</p>
</li>
<li><p>Microsoft OpenJDK（<a target="_blank" rel="noopener" href="https://www.microsoft.com/openjdk">Microsoft Build of OpenJDK</a>）</p>
</li>
<li><p>Alibaba Dragonwell（<a target="_blank" rel="noopener" href="https://developer.aliyun.com/opensource/project/alibabadragonwell">开发者平台_开发者中心 (aliyun.com)</a>）</p>
</li>
<li><p>Azul OpenJDK（<a target="_blank" rel="noopener" href="https://www.azul.com/downloads/azure-only/">Azure Only Downloads - Azul | Better Java Performance, Superior Java Support</a>）</p>
</li>
<li><p>Red Hat OpenJDK（<a target="_blank" rel="noopener" href="https://developers.redhat.com/products/openjdk/download">OpenJDK Download | Red Hat Developer</a>）</p>
</li>
<li><p>Amazon Corretto（<a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/corretto/">Amazon Corretto-OpenJDK 的免费多平台发行版-AWS云服务</a>）</p>
</li>
</ul>
<pre><code class="shell"># Oracle
java version &quot;13.0.2&quot; 2020-01-14
Java(TM) SE Runtime Environment (build 13.0.2+8)
Java HotSpot(TM) 64-Bit Server VM (build 13.0.2+8, mixed mode, sharing)

# Microsoft
openjdk version &quot;11.0.12&quot; 2021-07-20
OpenJDK Runtime Environment Microsoft-25199 (build 11.0.12+7)
OpenJDK 64-Bit Server VM Microsoft-25199 (build 11.0.12+7, mixed mode)

# Alibaba
openjdk version &quot;1.8.0_302&quot;
OpenJDK Runtime Environment (Alibaba Dragonwell 8.8.8) (build 1.8.0_302-b01)
OpenJDK 64-Bit Server VM (Alibaba Dragonwell 8.8.8) (build 25.302-b01, mixed mode)

# 不同的Linux发行版会提供OpenJDK或其变体作为系统默认的JVM实现
openjdk version &quot;1.8.0_292&quot;
OpenJDK Runtime Environment (build 1.8.0_292-8u292-b10-0ubuntu1~18.04-b10)
OpenJDK 64-Bit Server VM (build 25.292-b10, mixed mode)
</code></pre>
<h3 id="3、跨语言平台"><a href="#3、跨语言平台" class="headerlink" title="3、跨语言平台"></a>3、跨语言平台</h3><p>JVM是一个跨语言的平台，只要对应的编译器按照一定的规范（JSR-292）能生成JVM可以识别的字节码文件，就可以运行其他语言的程序，而不仅仅是java。</p>
<p>因此java的强大之处并不在于java语言本身，而更在于JVM的强大。</p>
<p><img src="/images/JVM%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%B9%B3%E5%8F%B0.png"></p>
<h3 id="4、JVM整体结构"><a href="#4、JVM整体结构" class="headerlink" title="4、JVM整体结构"></a>4、JVM整体结构</h3><p>JVM主要分为三个区域：</p>
<ul>
<li>类加载子系统</li>
<li>运行时数据区</li>
<li>执行引擎</li>
</ul>
<p><img src="/images/JVM%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png"></p>
<h3 id="5、java代码执行流程"><a href="#5、java代码执行流程" class="headerlink" title="5、java代码执行流程"></a>5、java代码执行流程</h3><ul>
<li>java编译器（如javac）编译成.class字节码文件（前端编译器）<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>语法/抽象语法树</li>
<li>语义分析</li>
<li>注解抽象语法树</li>
<li>字节码生成器</li>
</ul>
</li>
<li>JVM<ul>
<li>类加载</li>
<li>字节码校验</li>
<li>解释器，逐行将字节码翻译成机器指令，解析执行</li>
<li>JIT编译器（后端编译器），对字节码整体进行编译再执行，区别在于JIT会缓存一些热点代码等，优化执行效率</li>
</ul>
</li>
</ul>
<p><font color="Red">注意：解释器和JIT编译器属于JVM的执行引擎下，可以共存，但是不会同时运行，JIT编译器和解释器只能选其中一种来执行，但是并不是在JVM的整个生命周期内只能选一种运行，而是可以切换运行，根据当前要执行的代码的特征，JVM会选择其中一种来执行。</font></p>
<h3 id="6、class文件反编译"><a href="#6、class文件反编译" class="headerlink" title="6、class文件反编译"></a>6、class文件反编译</h3><p>通过javap命令可以对.class文件进行反编译，查看字节码指令。</p>
<pre><code class="shell">javap -v Demo01.class

Classfile /D:/Adocument/Java/JVM/out/production/c1-memory-and-garbage-collect/net/yury/demo/Demo01.class
  Last modified 2021-9-20; size 580 bytes
  MD5 checksum fa60e763603ba1e3f645376ecc25e0ac
  Compiled from &quot;Demo01.java&quot;
public class net.yury.demo.Demo01
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #5.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Fieldref           #24.#25        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = Methodref          #26.#27        // java/io/PrintStream.println:(I)V
   #4 = Class              #28            // net/yury/demo/Demo01
   #5 = Class              #29            // java/lang/Object
   #6 = Utf8               &lt;init&gt;
   #7 = Utf8               ()V
   #8 = Utf8               Code
   #9 = Utf8               LineNumberTable
  #10 = Utf8               LocalVariableTable
  #11 = Utf8               this
  #12 = Utf8               Lnet/yury/demo/Demo01;
  #13 = Utf8               main
  #14 = Utf8               ([Ljava/lang/String;)V
  #15 = Utf8               args
  #16 = Utf8               [Ljava/lang/String;
  #17 = Utf8               a
  #18 = Utf8               I
  #19 = Utf8               b
  #20 = Utf8               c
  #21 = Utf8               SourceFile
  #22 = Utf8               Demo01.java
  #23 = NameAndType        #6:#7          // &quot;&lt;init&gt;&quot;:()V
  #24 = Class              #30            // java/lang/System
  #25 = NameAndType        #31:#32        // out:Ljava/io/PrintStream;
  #26 = Class              #33            // java/io/PrintStream
  #27 = NameAndType        #34:#35        // println:(I)V
  #28 = Utf8               net/yury/demo/Demo01
  #29 = Utf8               java/lang/Object
  #30 = Utf8               java/lang/System
  #31 = Utf8               out
  #32 = Utf8               Ljava/io/PrintStream;
  #33 = Utf8               java/io/PrintStream
  #34 = Utf8               println
  #35 = Utf8               (I)V
&#123;
  public net.yury.demo.Demo01();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lnet/yury/demo/Demo01;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: iconst_4
         1: istore_1
         2: iconst_3
         3: istore_2
         4: iload_1
         5: iload_2
         6: iadd
         7: istore_3
         8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        11: iload_1
        12: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V
        15: return
      LineNumberTable:
        line 5: 0
        line 6: 2
        line 7: 4
        line 8: 8
        line 9: 15
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      16     0  args   [Ljava/lang/String;
            2      14     1     a   I
            4      12     2     b   I
            8       8     3     c   I
&#125;
SourceFile: &quot;Demo01.java&quot;
</code></pre>
<p>JVM是基于栈的架构，不同CPU架构不同，因此不能基于寄存器来设计。</p>
<h3 id="7、JVM生命周期"><a href="#7、JVM生命周期" class="headerlink" title="7、JVM生命周期"></a>7、JVM生命周期</h3><ul>
<li><strong>启动</strong>：Java虚拟机的启动是通过<strong>引导类加载器</strong>（bootstrap class loader）创建一个初始类（initial class）来完成的，这个初始类是由虚拟机的具体实现来指定的，不同实现版本的JVM的类可能不一样。</li>
<li><strong>执行</strong>：JVM执行的任务就是执行用户程序，即执行一个java程序，实际上是执行一个JVM进程，而用户程序只不过在这个进程上运行。</li>
<li><strong>退出</strong>：程序正常终止、异常或错误而终止、操作系统错误终止、某个线程调用Runtime类或System类的exit方法或其他方法手动终止程序等都会导致程序退出，程序终止则JVM也退出。</li>
</ul>
<h2 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h2><p>类加载子系统（class loader subsystem）负责加载.class字节码文件。</p>
<p>类加载过程分为一下几个步骤：加载、链接、初始化。</p>
<h3 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h3><ul>
<li>通过全限定类名获取定义此类的二进制流（本地文件，网络，<font color="Red">动态代理</font>，<font color="Red">JSP生成</font>）</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象（详见反射），作为方法区这个类的各种数据的访问入口</li>
</ul>
<h3 id="2、链接"><a href="#2、链接" class="headerlink" title="2、链接"></a>2、链接</h3><ul>
<li><strong>验证</strong>：验证class字节码文件是否符合当前JMV规范，保证类被正确地加载并不会危害JVM本身。主要有：文件格式验证、元数据验证、字节码验证、符号引用验证。</li>
<li><strong>准备</strong>：为变量分配内存，并设置该变量的默认值。用final static修饰的变量在编译成class文件时就会分配值，因而这种变量在这个阶段就会直接赋值。这里不会为示例变量分配初始化值，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。</li>
<li><strong>解析</strong>：将内存池中的符号引用转换为直接引用。即比如我们引用了一个java.Lang.String类，会产生一个对这个类的符号引用，等其他类都准备好了之后，将符号引用转换为地址引用这样的直接引用。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</li>
</ul>
<h3 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a>3、初始化</h3><p>这个初始化并不是初始化实例，而是类的初始化。</p>
<ul>
<li>执行类构造器方法&lt;clinit&gt;()的过程。此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。即执行所有static变量或static代码块相关的初始化操作，若没有这两类操作，则不会产生对应的&lt;clinit&gt;()方法。</li>
<li>初始化顺序是按照代码在源文件中的顺序执行</li>
<li>若该类具有父类，则必须先执行父类的&lt;clinit&gt;()方法，父类初始化完成后，才能初始化子类。</li>
<li>JVM必须保证一个类的&lt;clinit&gt;()方法在多线程中被同步加锁，保证只能被加载一次。</li>
</ul>
<pre><code class="java">package net.yury.demo;

public class Demo02 &#123;
    public static void main(String[] args) &#123;
        Runnable task = ()-&gt;&#123;
            System.out.println(Thread.currentThread().getName() + &quot;开始&quot;);
            AnotherClass deadThread = new AnotherClass();
            System.out.println(Thread.currentThread().getName() + &quot;结束&quot;);
        &#125;;
        Thread thread1 = new Thread(task, &quot;thread-1&quot;);
        Thread thread2 = new Thread(task, &quot;thread-2&quot;);

        thread1.start();
        thread2.start();
    &#125;
&#125;

class AnotherClass &#123;
    static &#123;
        System.out.println(Thread.currentThread().getName() + &quot;正在初始化&quot;);
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(Thread.currentThread().getName() + &quot;初始化结束&quot;);
    &#125;
&#125;
</code></pre>
<p>如以上代码执行时最多一个线程进入AnotherClass的static代码块去执行，要么是thread-1，要么是thread-2。</p>
<pre><code class="java">thread-1开始
thread-2开始
thread-1正在初始化
thread-1初始化结束
thread-1结束
thread-2结束
</code></pre>
<h3 id="4、类加载器（重点）"><a href="#4、类加载器（重点）" class="headerlink" title="4、类加载器（重点）"></a>4、类加载器（重点）</h3><p>按被加载的被的类的类型划分，类加载分为一下几种：</p>
<ul>
<li>引导类加载器（Bootstrap ClassLoader）</li>
<li>扩展类加载器（Extension ClassLoader）</li>
<li>应用程序类加载器（Application ClassLoader）</li>
<li>用户自定义类加载器（意为用户自定义的<strong>类加载器</strong>，而不是<strong>用户自定义类</strong>的加载器，没有加载器这个东西，只有类加载器）</li>
</ul>
<p>而按照JVM的标准，后面三种都叫用户自定义类加载器。<font color="Red">所有直接或间接派生于ClassLoader的类加载器都是用户自定义类加载器</font>。如扩展类加载器（ExtClassLoader）间接继承了ClassLoader。</p>
<p>Launcher类是JVM的一个入口应用，后面可以看到扩展了加载器和应用程序类加载器都是Launcher类里面的内部类。</p>
<h4 id="（1）引导类加载器"><a href="#（1）引导类加载器" class="headerlink" title="（1）引导类加载器"></a>（1）引导类加载器</h4><p>引导类加载器为C/C++编写，用于引导java的核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar、sun.boot.class.path路径下的内容），用于提供JVM启动运行自身需要的类。</p>
<p><font color="Red">扩展类加载器和应用程序类加载器也是一个类，因此引导类加载器用于还用于加载这两个特殊的类。</font></p>
<p>出于安全考虑，Bootstrap类加载器只加载包含java、javax、sun等开头的类。</p>
<p>引导类加载器加载的类，调用getClassLoader()方法返回null。</p>
<pre><code class="java">package net.yury.demo;

import com.sun.net.ssl.internal.ssl.Provider;
import sun.misc.Launcher;

import java.net.URL;

public class Demo03BootstrapClassLoader &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;bootstrap引导类加载器加载的路径为：&quot;);
        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();
        for (URL urL : urLs) &#123;
            System.out.println(urL.toString());
        &#125;
        ClassLoader classLoader = Provider.class.getClassLoader();
        System.out.println(classLoader);
    &#125;
&#125;

/*
bootstrap引导类加载器加载的路径为：
file:/D:/Program%20Files%20(x86)/Java/jdk1.8.0_201/jre/lib/resources.jar
file:/D:/Program%20Files%20(x86)/Java/jdk1.8.0_201/jre/lib/rt.jar
file:/D:/Program%20Files%20(x86)/Java/jdk1.8.0_201/jre/lib/sunrsasign.jar
file:/D:/Program%20Files%20(x86)/Java/jdk1.8.0_201/jre/lib/jsse.jar
file:/D:/Program%20Files%20(x86)/Java/jdk1.8.0_201/jre/lib/jce.jar
file:/D:/Program%20Files%20(x86)/Java/jdk1.8.0_201/jre/lib/charsets.jar
file:/D:/Program%20Files%20(x86)/Java/jdk1.8.0_201/jre/lib/jfr.jar
file:/D:/Program%20Files%20(x86)/Java/jdk1.8.0_201/jre/classes
null
*/
</code></pre>
<h4 id="（2）扩展类加载器"><a href="#（2）扩展类加载器" class="headerlink" title="（2）扩展类加载器"></a>（2）扩展类加载器</h4><p>java语言编写，由sun.misc.Launcher$ExtClassLoader实现，继承于ClassLoader，该类由Bootstrap引导类加载器加载。</p>
<p>加载的类目录为指定的java.ext.dirs系统属性目录，若没指定则默认为JAVA_HOME/jre/lib/ext，当用户写了一个类放入这个目录下也会被加载。</p>
<pre><code class="java">package net.yury.demo;

import sun.security.ec.CurveDB;

public class Demo04ExtClassLoader &#123;
    public static void main(String[] args) &#123;
        String property = System.getProperty(&quot;java.ext.dirs&quot;);
        System.out.println(property);

        ClassLoader classLoader = CurveDB.class.getClassLoader();
        System.out.println(classLoader);
    &#125;
&#125;

/*
D:\Program Files (x86)\Java\jdk1.8.0_201\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext
sun.misc.Launcher$ExtClassLoader@4b67cf4d
*/
</code></pre>
<h4 id="（3）应用程序类加载器"><a href="#（3）应用程序类加载器" class="headerlink" title="（3）应用程序类加载器"></a>（3）应用程序类加载器</h4><p>应用程序类加载器也叫系统类加载器，java语言编写，由sun.misc.Launcher$AppClassLoader实现，继承于ClassLoader，该类由扩展类加载器加载。</p>
<p>加载的类的目录为指定的java.class.path系统属性目录。</p>
<p><font color="Red">该类加载器是java应用程序的默认类加载器，即java应用的类一般都是由这个类加载器加载的。</font></p>
<pre><code class="java">package net.yury.demo;

public class Demo05AppClassLoader &#123;
    public static void main(String[] args) &#123;
        ClassLoader classLoader = Demo05AppClassLoader.class.getClassLoader();
        System.out.println(classLoader);
    &#125;
&#125;

/*
sun.misc.Launcher$AppClassLoader@18b4aac2
*/
</code></pre>
<p>总结如下：</p>
<p><img src="/images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%B1%BB%E5%9E%8B.png"></p>
<h4 id="（4）用户自定义类加载器"><a href="#（4）用户自定义类加载器" class="headerlink" title="（4）用户自定义类加载器"></a>（4）用户自定义类加载器</h4><p>不适用以上三种类加载器，而是用户自定义一个类加载器，来加载需要加载的类。</p>
<p>为什么需要自定义类加载器？</p>
<ul>
<li>隔离加载类</li>
<li>修改类的加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄露</li>
</ul>
<p>定义用户自定义类的两个方法：</p>
<ul>
<li>继承ClassLoader类，重写findClass方法，JDK1.2之前要重写loadClass方法</li>
<li>继承URLClassLoader类，按照需求重写部分方法</li>
<li>将URLClassLoader类作为一个参考模板，模仿重写一个适应自己需求的一个类</li>
</ul>
<h4 id="（5）获取类加载器的方式"><a href="#（5）获取类加载器的方式" class="headerlink" title="（5）获取类加载器的方式"></a>（5）获取类加载器的方式</h4><ul>
<li>Class.getClassLoader()</li>
<li>Thread.currentThread().getContextClassLoader()</li>
<li>ClassLoader.getSystemClassLoader()</li>
<li>DriverManager.getCallerCLassLoader()</li>
</ul>
<h3 id="5、双亲委派机制（重点）"><a href="#5、双亲委派机制（重点）" class="headerlink" title="5、双亲委派机制（重点）"></a>5、双亲委派机制（重点）</h3><p>JVM对class文件采用的是<font color="Red">按需加载</font>的方式加载，即在要用到这个类时才会将这个类加载进内存中生成class对象。而加载某个类时，JVM加载类时采用的是<font color="Red">双亲委派机制</font>，是一种任务委派模式。</p>
<p>双亲委派机制原理如下：</p>
<ul>
<li>当一个类加载器收到加载类的请求时，并不会自己去加载这个类，而是将这个请求委托给父类去加载</li>
<li>父类加载器收到加载请求后，会继续向上委托，最终到达Bootstrap ClassLoader</li>
<li>在这个递归的过程中，如果父类加载器完成了加载过程，则成功返回，否则才让子类加载器去完成类加载，知道这个类完成加载。</li>
</ul>
<p>注：“父类加载器“的断句为”<strong>父 类加载器</strong>“，还是一个类加载器，而不是父类的类加载器。类加载器可以通过调用getParent()方法获取其父类加载器。</p>
<pre><code class="java">/**
 * Returns the parent class loader for delegation. Some implementations may
 * use &lt;tt&gt;null&lt;/tt&gt; to represent the bootstrap class loader. This method
 * will return &lt;tt&gt;null&lt;/tt&gt; in such implementations if this class loader&#39;s
 * parent is the bootstrap class loader.
 */
public final ClassLoader getParent() &#123;&#125;
</code></pre>
<p><font color="Red">就像注释中说的，类加载器在任务委派方面是存在父子这种层次关系的，上面一节中讲到的不同类型的类加载器可以加载那些类，只是说明了它拥有加载这些类的能力，而不是说这些类一定由这个类加载器加载。而某个类最终由哪个类加载器加载，取决于可以加载这个类的最高级别的类加载器。</font></p>
<p>类加载器在任务委派方面的级别从高到低依次如下：</p>
<ul>
<li>Bootstrap ClassLoader</li>
<li>Extension ClassLoader</li>
<li>Application ClassLoader</li>
<li>UserDefined ClassLoader</li>
</ul>
<p>例如用户定义了一个java.lang.String类，而用户在使用这个类时，并不会找到用户定义的这个类，而是用了bootstrap classloader加载的rt.jar包下的java.lang.String类。因为通过双亲委派机制加载类时，加载任务不会直接进行，而是从最底层一直往上传递，最顶层的bootstrap classloader可以完成这个类的加载，于是直接完成了加载并返回class对象了，并不会将加载任务继续返还给子类加载器加载。代码略。</p>
<p>机制的优点：</p>
<ul>
<li>避免类被重复加载</li>
<li>保护程序安全，防止核心api被随意篡改</li>
</ul>
<h3 id="6、识别同一个类"><a href="#6、识别同一个类" class="headerlink" title="6、识别同一个类"></a>6、识别同一个类</h3><p>JVM中识别两个对象是否属于同一个类，包含以下两个校验：</p>
<ul>
<li>全限定类名是否相同</li>
<li>这两个对象的类是否由同一个类加载器加载的</li>
</ul>
<h3 id="7、类的主动使用和被动使用"><a href="#7、类的主动使用和被动使用" class="headerlink" title="7、类的主动使用和被动使用"></a>7、类的主动使用和被动使用</h3><p>主动使用包括：</p>
<ul>
<li>创建类实例</li>
<li>访问类或接口的静态变量，或对该静态变量进行赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>JVM启动时被标明为启动类的类</li>
<li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandler实例的解析结果</li>
</ul>
<p>除了以上几种情况为主动使用，其他均为被动使用。<font color="Red">类的被动使用不会导致类的初始化，即不会执行对应的&lt;clinit&gt;()方法</font>。</p>
<h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><h3 id="1、组成"><a href="#1、组成" class="headerlink" title="1、组成"></a>1、组成</h3><ul>
<li>方法区（JDK1.8叫元空间metaspace，或堆外内存）</li>
<li>JVM堆</li>
<li>程序计数器</li>
<li>本地方法栈</li>
<li>JVM栈</li>
</ul>
<p><font color="Red">其中方法区和JVM堆的生命周期和JVM进程的生命周期一样，而程序计数器、本地方法栈、JVM栈的生命周期和程序线程的生命周期一样，每有一个线程， 就会有一个自身的程序计数器、本地方法栈、JVM栈。</font></p>
<p><img src="/images/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png"></p>
<h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><p><font color="Red">在HotSpot JVM中，每个线程都与操作系统中的本地线程直接映射。java线程准备好时，操作系统中对应的本地线程也同时创建；java线程终止时，本地线程也会回收。</font></p>
<p><strong>普通线程</strong>：用户应用程序需要执行一定的工作而创建的工作线程。JVM虚拟机在所有普通线程终止时自动终止。</p>
<p><strong>守护线程</strong>：驻立在后台的线程，用于服务普通线程的线程，当JVM虚拟机准备终止时，守护线程才会终止。</p>
<p>HotSpot JVM中的守护线程主要有：</p>
<ul>
<li>JVM线程</li>
<li>周期任务线程</li>
<li>GC线程</li>
<li>编译线程</li>
<li>信号调度线程</li>
</ul>
<h3 id="3、程序计数器（PC寄存器）"><a href="#3、程序计数器（PC寄存器）" class="headerlink" title="3、程序计数器（PC寄存器）"></a>3、程序计数器（PC寄存器）</h3><p>英文全称：Program Counter Register。它是对CPU的寄存器的一种抽象模拟。</p>
<p>PC寄存器用来<font color="Red">存储指向下一条指令的地址</font>，也即将要执行的指令代码。由执行引擎读取下一条指令。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。可以理解为数据库中的游标，或集合的迭代器。</p>
<p>线程私有，和线程的生命周期一致。</p>
<p><font color="Red">没有GC，且是唯一一个在JVM规范中没有规定任何OOM情况的区域。</font></p>
<pre><code class="java">package net.yury.demo;

public class Demo06PCRegister &#123;
    public static void main(String[] args) &#123;
        int i = 10;
        int j = 20;
        int k = i + j;
        String s = &quot;yury&quot;;
        System.out.println(s);
    &#125;
&#125;
</code></pre>
<p>对于上面这段代码反编译后的指令如下：</p>
<p><img src="/images/pc%E5%AF%84%E5%AD%98%E5%99%A8.png"></p>
<p><strong>问题1：为什么要用PC寄存器？</strong></p>
<p>因为CPU需要不断地在各个线程之间切换运行，需要有一个东西记录CPU需要运行的下一条指令的位置，不然CPU从其他线程切换回来不知道从哪里开始。</p>
<p><strong>问题2：PC寄存器为什么是线程私有的？</strong></p>
<p>因为PC寄存器是记录每个线程的下一条指令的位置，和线程相关，因此要每个线程独享一份PC寄存器。如果设计成公用的，则需要将对应线程的id也记录进去（即一种key-value形式的数据结构存储），而在创建线程和销毁线程时还要对这个数据结构进行操作，又涉及并发问题，稍显麻烦。而PC寄存器的占用内存及其小，因此设计成和线程绑定，随着线程生命周期创建或销毁，使用起来更方便。</p>
<h3 id="4、JVM栈"><a href="#4、JVM栈" class="headerlink" title="4、JVM栈"></a>4、JVM栈</h3><p>英文全称：Java Virtual Machine Stacks。</p>
<p><font color="Red">栈是运行时的单位，而堆是存储的单位。栈解决程序运行的问题，即程序如何运行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放在那里。</font></p>
<p><font color="Red">JVM栈内部存储的是一个个的栈帧，对应着一次次的方法调用，当前线程每调用一个方法，则将该方法入栈，栈顶元素即为正在运行的方法，当前方法运行结束后则栈顶元素出栈</font>。主管java程序的运行，每个栈帧中保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<p>线程私有，和线程的生命周期一致。</p>
<p>不存在GC，但是存在OOM。</p>
<p>JVM允许JVM栈的大小是动态的或者固定不变的。若栈大小是固定的，则可能存在<strong>StackOverflowError</strong>异常；若栈大小是动态的，则可能存在<strong>OutOfMemoryError</strong>异常。</p>
<p><font color="Red">设置栈的大小</font>：在JVM参数设置里面加上<code>-Xss1024</code>即可设置栈空间的大小；默认单位是bytes，加上<code>k</code>则以kb为单位，同样加上<code>m</code>则以mb为单位。</p>
<h4 id="（1）栈帧"><a href="#（1）栈帧" class="headerlink" title="（1）栈帧"></a>（1）栈帧</h4><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据集。</p>
<p>在一个活动线程中，一个时间点上只可能有一个活动的栈帧，即栈顶栈帧，对应着当前正在运行的方法。</p>
<pre><code class="java">package net.yury.demo;

public class Demo07JVMStackTest &#123;
    public static void main(String[] args) &#123;
        Demo07JVMStackTest demo = new Demo07JVMStackTest();
        demo.test1();
    &#125;

    public void test1()&#123;
        int a = 10;
        test2();
    &#125;
    public void test2()&#123;
        int b = 20;
        test3();
    &#125;
    public void test3()&#123;
        int c = 30;
    &#125;
&#125;
</code></pre>
<p>如在运行以上代码时，通过debug手动控制程序的运行时，会发现每当进入一个方法时，下图的顶端方法就会变成当前方法。每执行完一个方法时，顶端方法就会移除。</p>
<p><img src="/images/stack%E6%B5%8B%E8%AF%95.png"></p>
<p>注意：不同线程中的所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧。即不同栈之间的栈帧时隔离的。</p>
<blockquote>
<p>返回类型</p>
</blockquote>
<p>函数有两种返回方式，一是正常返回，而是异常返回。这两种返回方式都会导致栈帧被弹出。</p>
<p>正常返回时，使用return指令，返回值会被传给下一个栈帧，接着当前栈帧就被JVM丢弃。返回值为void其实也有一个return。</p>
<p>异常返回时，抛出的异常会传给下一个栈帧去处理，如果下一个栈帧没有处理该异常，则继续往前抛，直到有一个函数可以处理这个异常。</p>
<blockquote>
<p>栈帧内部结构</p>
</blockquote>
<ul>
<li><p><font color="Red">局部变量表</font></p>
</li>
<li><p><font color="Red">操作数栈（或表达式栈）</font></p>
</li>
<li><p>动态链接（或指向运行时常量池的方法引用）</p>
</li>
<li><p>方法返回地址（或方法正常退出或异常退出的定义）</p>
</li>
<li><p>其他附加信息</p>
</li>
</ul>
<p><img src="/images/%E6%A0%88%E5%B8%A7.png"></p>
<h4 id="（2）局部变量表"><a href="#（2）局部变量表" class="headerlink" title="（2）局部变量表"></a>（2）局部变量表</h4><p>局部变量表（local variables），<font color="Red">定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，如字节码指令中的store、load等指令都会对局部变量表的操作</font>，这些数据类型包括基本数据类型、对象引用（reference），以及returnAddress类型。</p>
<p><font color="Red">局部变量表中最基本的存储单元是slot（变量槽）</font>。32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</p>
<ul>
<li>boolean、byte、short、char在存储之前都会被转换成int，占用一个slot</li>
<li>float为占用一个字节，故占用一个slot</li>
<li>long和double则占用两个slot</li>
<li>引用类型占用一个slot</li>
</ul>
<p>局部变量表是和线程绑定的，不存在线程安全的问题。</p>
<p><strong>局部变量表所需的容量大小是在编译器就确定下来了</strong>，并保存在方法的Code属性的locals数据项中，在方法运行期间是不会改变局部变量表的大小的。</p>
<p><font color="Red">局部变量表中的变量是重要的垃圾回收的根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</font></p>
<p>如下这段代码，在javap命令下展示的局部变量表如下所示。locals即为局部变量表的容量（数字数组的长度），L开头表示引用类型。</p>
<pre><code class="java">package net.yury.demo;

public class Demo08Slot &#123;
    public static void main(String[] args) &#123;
        String res = test(args);
    &#125;
    public static String test(String[] args)&#123;
        long a = 1L;
        double b = 2;
        float c = 3F;
        int d = 3;
        short e = 4;
        byte f = 5;
        boolean g = true;
        char h = &#39;a&#39;;
        String i = &quot;123&quot;;
        return i + &quot;456&quot;;
    &#125;
&#125;
/*
public static java.lang.String test(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)Ljava/lang/String;
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=12, args_size=1
         0: lconst_1
         1: lstore_1
         2: ldc2_w        #3                  // double 2.0d
         5: dstore_3
         6: ldc           #5                  // float 3.0f
         8: fstore        5
        10: iconst_3
        11: istore        6
        13: iconst_4
        14: istore        7
        16: iconst_5
        17: istore        8
        19: iconst_1
        20: istore        9
        22: bipush        97
        24: istore        10
        26: ldc           #6                  // String 123
        28: astore        11
        30: new           #7                  // class java/lang/StringBuilder
        33: dup
        34: invokespecial #8                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V
        37: aload         11
        39: invokevirtual #9                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
        42: ldc           #10                 // String 456
        44: invokevirtual #9                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
        47: invokevirtual #11                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
        50: areturn
      LineNumberTable:
        line 8: 0
        line 9: 2
        line 10: 6
        line 11: 10
        line 12: 13
        line 13: 16
        line 14: 19
        line 15: 22
        line 16: 26
        line 17: 30
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      51     0  args   [Ljava/lang/String;
            2      49     1     a   J
            6      45     3     b   D
           10      41     5     c   F
           13      38     6     d   I
           16      35     7     e   S
           19      32     8     f   B
           22      29     9     g   Z
           26      25    10     h   C
           30      21    11     i   Ljava/lang/String;
*/
</code></pre>
<p>局部变量表在LocalVariableTable下，</p>
<ul>
<li>start：该局部变量开始生效的字节码行号</li>
<li>length：该局部变量开始生效的字节码行的数量，start + length一定等于该方法的总字节码行数</li>
<li>slot：占据的槽位的编号</li>
<li>name：局部变量名</li>
<li>signature：局部变量类型缩写</li>
</ul>
<p>最上面<code>Code：</code>下面的<code>locals</code>即为局部变量表的大小，而<code>stack</code>为操作数栈的长度。</p>
<p>LineNumberTable这个表指的是<strong>源代码中行号（冒号左边）</strong>和<strong>字节码行号（冒号右边）</strong>的对应关系</p>
<p><img src="/images/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png"></p>
<p><font color="Red">注意：非静态方法，会把对自身对象的引用this放在第0个位置的slot处作为“局部变量”，甚至方法的参数都要放在这个“局部变量”后面。而静态方法中，不会将自身对象的应用放到局部变量表中，因此在静态方法中使用this会报错。如下：</font></p>
<pre><code class="java">public String test1(long i) throws FileNotFoundException &#123;
    FileInputStream fileInputStream = new FileInputStream(&quot;&quot;);
    this.test2();
    return this.name;
&#125;
/*
public java.lang.String test1(long) throws java.io.FileNotFoundException;
    descriptor: (J)Ljava/lang/String;
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=4, args_size=2
         0: new           #12                 // class java/io/FileInputStream
         3: dup
         4: ldc           #13                 // String
         6: invokespecial #14                 // Method java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V
         9: astore_3
        10: aload_0
        11: invokevirtual #15                 // Method test2:()V
        14: aload_0
        15: getfield      #16                 // Field name:Ljava/lang/String;
        18: areturn
      LineNumberTable:
        line 21: 0
        line 22: 10
        line 23: 14
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      19     0  this   Lnet/yury/demo/Demo09Method;
            0      19     1     i   J
           10       9     3 fileInputStream   Ljava/io/FileInputStream;
    Exceptions:
      throws java.io.FileNotFoundException
*/
</code></pre>
<blockquote>
<p>slot的重复利用</p>
</blockquote>
<p>局部变量表中的slot槽位是可以重复利用的。当一个局部变量过了其作用域时，那么后面申明的局部变量可以利用前面过期的局部变量的slot槽位，以达到节省资源的作用。</p>
<p>如下，c和d利用了过期了的b的slot槽位。</p>
<pre><code class="java">public void test3()&#123;
    int a = 0;
    &#123;
        long b = 100L;
        b = a;
    &#125;
    int c = 0;
    char d = &#39;a&#39;;
&#125;
/*
public void test3();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: iconst_0
         1: istore_1
         2: ldc2_w        #4                  // long 100l
         5: lstore_2
         6: iload_1
         7: i2l
         8: lstore_2
         9: iconst_0
        10: istore_2
        11: bipush        97
        13: istore_3
        14: return
      LineNumberTable:
        line 31: 0
        line 33: 2
        line 34: 6
        line 36: 9
        line 37: 11
        line 38: 14
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            6       3     2     b   J
            0      15     0  this   Lnet/yury/demo/Demo09Method;
            2      13     1     a   I
           11       4     2     c   I
           14       1     3     d   C
*/
</code></pre>
<h4 id="（3）操作数栈"><a href="#（3）操作数栈" class="headerlink" title="（3）操作数栈"></a>（3）操作数栈</h4><p><font color="Red">操作数栈（operand stack），即在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据的一个临时存储空间，主要用于保存一些指令需要用的临时数据。</font>如指令中的push、store、load等指令，都会对操作数栈进行操作。</p>
<p>JVM的执行引擎是基于栈的执行引擎，其中这里说的栈，就是操作数栈。</p>
<p>JVM操作数栈用数组来实现，操作数栈的大小在编译时即确定了，对操作数栈的操作只有入栈和出栈。</p>
<p>操作数栈中的任何一个元素的都可以是任意类型的java数据类型，只是占用的栈单位不一样：</p>
<ul>
<li>32位及以下的类型占用一个栈单位深度，以int类型存放</li>
<li>64位类型占用两个栈单位深度</li>
</ul>
<blockquote>
<p>指令分析</p>
</blockquote>
<pre><code class="java">package net.yury.demo;

public class Demo10OperandStack &#123;
    public void method1() &#123;
        byte m = 15;
        int n = 8;
        int k = m + n;
    &#125;
&#125;
</code></pre>
<pre><code class="java">public void method1();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        15
         2: istore_1
         3: bipush        8
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: return
      LineNumberTable:
        line 5: 0
        line 6: 3
        line 7: 6
        line 8: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  this   Lnet/yury/demo/Demo10OperandStack;
            3       8     1     m   B
            6       5     2     n   I
           10       1     3     k   I
</code></pre>
<p>以上指令是如何一步一步进行的，如下图所示：</p>
<p><img src="/images/%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%E5%88%86%E6%9E%90.png"></p>
<p><font color="Red">注意：对于<code>int n = 8;</code>这段代码，虽然指定的是int型，但是数值不超过byte的范围，所以编译后的类型是byte。即并不是我们指定什么类型，它就是什么类型，前端编译器会对我们的代码做优化。</font></p>
<p>对于有返回值的函数，调用这个函数时，会将函数结果压入栈顶，如下所示。sum方法和上面的method方法的指令，除了ireturn有区别外，其他均无区别。getSum方法的指令中，<font color="Red"><code>aload_0</code>是将this自身对应的引用从局部变量表中复制出来，放入操作数栈中；<code>invokevirtual</code>指令则是取出栈顶元素，以该元素为对象，调用对象中的一个方法，返回的结果会被重新压入栈顶；<code>istore_1</code>则是将栈顶元素出栈，即取出刚才的函数返回值，放入局部变量表中的1号slot槽位。</font></p>
<pre><code class="java">public void getSum()&#123;
    int a = sum();
    int b = 10000;
&#125;

public int sum()&#123;
    byte m = 15;
    int n = 8;
    int k = m + n;
    return k;
&#125;
</code></pre>
<pre><code class="java">public void getSum();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=3, args_size=1
         0: aload_0
         1: invokevirtual #2                  // Method sum:()I
         4: istore_1
         5: sipush        10000
         8: istore_2
         9: return
      LineNumberTable:
        line 11: 0
        line 12: 5
        line 13: 9
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lnet/yury/demo/Demo10OperandStack;
            5       5     1     a   I
            9       1     2     b   I

  public int sum();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        15
         2: istore_1
         3: bipush        8
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: iload_3
        11: ireturn
      LineNumberTable:
        line 16: 0
        line 17: 3
        line 18: 6
        line 19: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      12     0  this   Lnet/yury/demo/Demo10OperandStack;
            3       9     1     m   B
            6       6     2     n   I
           10       2     3     k   I
</code></pre>
<blockquote>
<p>i++与++i的区别</p>
</blockquote>
<p>先通过字节码分析，可以发现，<code>n++</code>是先将数据从局部变量表中复制到操作数栈中，再对局部变量表中slot为1的变量的值进行++操作，最后将操作数栈中栈顶元素store到新的局部变量中，而<code>++n</code>是先在局部变量表中slot为1的变量的值进行++操作，再load到操作数栈中，最后store到新的局部变量中。即load和++操作的执行顺序不一样，这就导致n++返回的是n，而++n返回的是(n+1)。</p>
<pre><code class="java">public void test()&#123;
    int n = 1000;
    int m = n++;
    int k = ++n;
&#125;
</code></pre>
<pre><code class="java">public void test();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=4, args_size=1
         0: sipush        1000
         3: istore_1
         4: iload_1
         5: iinc          1, 1
         8: istore_2
         9: iinc          1, 1
        12: iload_1
        13: istore_3
        14: return
      LineNumberTable:
        line 23: 0
        line 24: 4
        line 25: 9
        line 26: 14
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      15     0  this   Lnet/yury/demo/Demo10OperandStack;
            4      11     1     n   I
            9       6     2     m   I
           14       1     3     k   I
</code></pre>
<blockquote>
<p>栈顶缓存技术（top-of-stack caching）</p>
</blockquote>
<p>由于JVM是基于栈设计的，因此在不断的执行指令过程中，经常会有入栈出栈的操作，这就意味着存在多次的内存读写操作，会对整体运行速度有所影响。因此HotSpot JVM对此处做了一个缓存，即<font color="Red">将所有栈顶元素缓存到物理CPU寄存器中，依次降低对内存的读写，提高执行效率。</font></p>
<p>CPU还有一个东西叫高速缓存（一级、二级、三级），这个东西是集成到CPU内和CPU完全独立的一个器件，作为CPU的临时数据缓存区。而CPU寄存器是属于CPU本身的，因此CPU对寄存器的读写速度比对高速缓存的读写速度快得多。这一块是硬件相关的东西，不同架构的硬件设计不一样，可以去学习学习。</p>
<h4 id="（4）动态链接"><a href="#（4）动态链接" class="headerlink" title="（4）动态链接"></a>（4）动态链接</h4><p>之前说过，每个栈帧都对应一个方法的执行，那么JVM怎么知道这个栈帧是对应的哪个方法呢，这就是通过动态链接来实现的。</p>
<p>每个栈帧中都包含了一个指向运行时常量池中的该栈帧对应的方法类型的引用，这样字节码文件中的指令就可以支持使用动态链接。</p>
<p><font color="Red">动态链接（Dynamic Linking），将符号方法引用转换为直接方法引用，加载符号引用对应的类，将对变量的访问转换为这些变量在对应的存储结构中的对应的偏移量。</font></p>
<p>java代码被编译成字节码指令后，所有的类、变量和方法都保存在运行时常量池中，并都指定了一个通过#开头的独一无二的符号引用作为这个变量或方法的引用。<font color="Red">动态链接就是将这个符号引用转换为直接引用，从而实现方法的调用、类的加载和变量的使用。</font></p>
<p>比如下面这个类的运行时常量池和test()方法的字节码。运行时常量池中记录了这个类所需要的字节码对象，左边的#加数字即为对应的符号引用，test()方法中的指令需要用到某个对象时，则使用这个引用即可。</p>
<p>JVM的运行时常量池可以把其他字节码文件中的对象在本字节码文件中设置引用，但动态链接只能链接本字节码文件中运行时常量池中包含的对象，无法直接链接到外部字节码文件的对象。</p>
<pre><code class="java">package net.yury.demo;

public class Demo11DynamicLinking &#123;
    public static void main(String[] args) &#123;
        new Demo11DynamicLinking().test();
    &#125;

    public void test(int i)&#123;

    &#125;

    public void test()&#123;
        String test = Demo08Slot.test(null);
        Demo10OperandStack demo = new Demo10OperandStack();
        demo.test();
        test(10);
        System.out.println(test);
    &#125;
&#125;
</code></pre>
<pre><code class="java">Constant pool:
   #1 = Methodref          #14.#36        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Class              #37            // net/yury/demo/Demo11DynamicLinking
   #3 = Methodref          #2.#36         // net/yury/demo/Demo11DynamicLinking.&quot;&lt;init&gt;&quot;:()V
   #4 = Methodref          #2.#38         // net/yury/demo/Demo11DynamicLinking.test:()V
   #5 = Class              #39            // java/lang/String
   #6 = String             #40            // 123456
   #7 = Methodref          #41.#42        // net/yury/demo/Demo08Slot.test:([Ljava/lang/String;)Ljava/lang/String;
   #8 = Class              #43            // net/yury/demo/Demo10OperandStack
   #9 = Methodref          #8.#36         // net/yury/demo/Demo10OperandStack.&quot;&lt;init&gt;&quot;:()V
  #10 = Methodref          #8.#38         // net/yury/demo/Demo10OperandStack.test:()V
  #11 = Methodref          #2.#44         // net/yury/demo/Demo11DynamicLinking.test:(I)V
  #12 = Fieldref           #45.#46        // java/lang/System.out:Ljava/io/PrintStream;
  #13 = Methodref          #47.#48        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #14 = Class              #49            // java/lang/Object
  #15 = Utf8               &lt;init&gt;
  #16 = Utf8               ()V
  #17 = Utf8               Code
  #18 = Utf8               LineNumberTable
  #19 = Utf8               LocalVariableTable
  #20 = Utf8               this
  #21 = Utf8               Lnet/yury/demo/Demo11DynamicLinking;
  #22 = Utf8               main
  #23 = Utf8               ([Ljava/lang/String;)V
  #24 = Utf8               args
  #25 = Utf8               [Ljava/lang/String;
  #26 = Utf8               test
  #27 = Utf8               (I)V
  #28 = Utf8               i
  #29 = Utf8               I
  #30 = Utf8               testString
  #31 = Utf8               Ljava/lang/String;
  #32 = Utf8               demo
  #33 = Utf8               Lnet/yury/demo/Demo10OperandStack;
  #34 = Utf8               SourceFile
  #35 = Utf8               Demo11DynamicLinking.java
  #36 = NameAndType        #15:#16        // &quot;&lt;init&gt;&quot;:()V
  #37 = Utf8               net/yury/demo/Demo11DynamicLinking
  #38 = NameAndType        #26:#16        // test:()V
  #39 = Utf8               java/lang/String
  #40 = Utf8               123456
  #41 = Class              #50            // net/yury/demo/Demo08Slot
  #42 = NameAndType        #26:#51        // test:([Ljava/lang/String;)Ljava/lang/String;
  #43 = Utf8               net/yury/demo/Demo10OperandStack
  #44 = NameAndType        #26:#27        // test:(I)V
  #45 = Class              #52            // java/lang/System
  #46 = NameAndType        #53:#54        // out:Ljava/io/PrintStream;
  #47 = Class              #55            // java/io/PrintStream
  #48 = NameAndType        #56:#57        // println:(Ljava/lang/String;)V
  #49 = Utf8               java/lang/Object
  #50 = Utf8               net/yury/demo/Demo08Slot
  #51 = Utf8               ([Ljava/lang/String;)Ljava/lang/String;
  #52 = Utf8               java/lang/System
  #53 = Utf8               out
  #54 = Utf8               Ljava/io/PrintStream;
  #55 = Utf8               java/io/PrintStream
  #56 = Utf8               println
  #57 = Utf8               (Ljava/lang/String;)V

  public void test();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=4, locals=4, args_size=1
         0: iconst_1
         1: anewarray     #5                  // class java/lang/String
         4: dup
         5: iconst_0
         6: ldc           #6                  // String 123456
         8: aastore
         9: astore_1
        10: aload_1
        11: invokestatic  #7                  // Method net/yury/demo/Demo08Slot.test:([Ljava/lang/String;)Ljava/lang/String;
        14: astore_2
        15: new           #8                  // class net/yury/demo/Demo10OperandStack
        18: dup
        19: invokespecial #9                  // Method net/yury/demo/Demo10OperandStack.&quot;&lt;init&gt;&quot;:()V
        22: astore_3
        23: aload_3
        24: invokevirtual #10                 // Method net/yury/demo/Demo10OperandStack.test:()V
        27: aload_0
        28: bipush        10
        30: invokevirtual #11                 // Method test:(I)V
        33: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;
        36: aload_2
        37: invokevirtual #13                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        40: return
      LineNumberTable:
        line 16: 0
        line 17: 10
        line 18: 15
        line 19: 23
        line 20: 27
        line 21: 33
        line 22: 40
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      41     0  this   Lnet/yury/demo/Demo11DynamicLinking;
           10      31     1 testString   [Ljava/lang/String;
           15      26     2  test   Ljava/lang/String;
           23      18     3  demo   Lnet/yury/demo/Demo10OperandStack;
</code></pre>
<blockquote>
<p>早期绑定和晚期绑定</p>
</blockquote>
<p><strong>绑定</strong>是一个字段、方法或类在符号引用被转换成直接引用的过程。</p>
<p><strong>早期绑定</strong>：如果被调用的目标的类型在编译期间就是确定的，且运行期间保持不变，则这个目标的绑定过程叫早期绑定。</p>
<p><strong>晚期绑定</strong>：如果被调用的目标的类型在编译期间无法确定，只能在运行期间确定，则这个目标的绑定过程叫晚期绑定。</p>
<p>对于方法而言，有早期绑定和晚期绑定又叫静态链接和动态链接。</p>
<p><strong>静态链接</strong>：如果被调用的方法类型在编译期间就是确定下来的，并且运行期间保持不变，这种情况下将调用的方法的符号引用转换为直接引用的过程叫静态链接。</p>
<p><strong>动态链接</strong>：如果被调用的方法类型在编译期间无法确定，只能在运行期间将调用的方法的符号引用转换为直接引用，这个过程叫动态链接。</p>
<blockquote>
<p>虚方法和非虚方法</p>
</blockquote>
<p><strong>虚方法</strong>：编译期间无法确定的方法叫虚方法；</p>
<p><strong>非虚方法</strong>：编译期间就可以确定，且运行期间无法修改的方法，叫非需方法。</p>
<p>虚方法的调用使用在字节码层面会使用invokevirtual和invokeinterface两个指令；而非虚方法的调用在字节码层面使用invokestatic和invokespecial指令。final方法外除外，final方法的调用仍然使用invokevirtual指令。</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用父类方法、私有方法、构造器方法</li>
<li>invokevirtual：调用其他普通方法或final方法</li>
<li>invokeinterface：调用接口方法</li>
<li>invokedynamic：使用函数式接口或lamdba表达式生成一个对象时使用的指令</li>
</ul>
<p>不同方法的调用使用的字节码指令如下。值得注意的是，下面这段代码中，Function接口通过lamdba表达式和new的方式使用的底层指令不一样，lamdba使用invokedynamic，而new实际上是生成了一个匿名内部类<code>Demo12DynamicLinking2$1</code>，并初始化这个匿名内部类，因此使用了invokespecial。</p>
<pre><code class="java">package net.yury.demo;

import java.util.function.Function;

public class Demo12DynamicLinking2 extends Parent implements Interface&#123;
    public static void main(String[] args) &#123;
    &#125;

    public static void test1()&#123; &#125;
    private void test2()&#123; &#125;
    public void test3()&#123; &#125;
    protected void test4()&#123; &#125;
    public final void test5()&#123; &#125;
    @Override
    public void test6()&#123; System.out.println(&quot;child&quot;); &#125;
    public final void test7()&#123; &#125;
    @Override
    public void test8()&#123; &#125;

    public void method(Interface demo)&#123;
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        super.test6();
        test7();
        test8();
        demo.test8();
        Function&lt;String, String&gt; function1 = s -&gt; &#123; return s; &#125;;
        Function&lt;String, String&gt; function2 = new Function&lt;String, String&gt;() &#123;
            @Override
            public String apply(String s) &#123;
                return s;
            &#125;
        &#125;;
        String s1 = function1.apply(&quot;123&quot;);
        String s2 = function2.apply(&quot;456&quot;);
    &#125;
&#125;

interface Interface&#123;
    public void test8();
&#125;

class Parent&#123;
    public void test6()&#123;
        System.out.println(&quot;parent&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">      stack=3, locals=6, args_size=2
         0: invokestatic  #5                  // Method test1:()V
         3: aload_0
         4: invokespecial #6                  // Method test2:()V
         7: aload_0
         8: invokevirtual #7                  // Method test3:()V
        11: aload_0
        12: invokevirtual #8                  // Method test4:()V
        15: aload_0
        16: invokevirtual #9                  // Method test5:()V
        19: aload_0
        20: invokevirtual #10                 // Method test6:()V
        23: aload_0
        24: invokespecial #11                 // Method net/yury/demo/Parent.test6:()V
        27: aload_0
        28: invokevirtual #12                 // Method test7:()V
        31: aload_0
        32: invokevirtual #13                 // Method test8:()V
        35: aload_1
        36: invokeinterface #14,  1           // InterfaceMethod net/yury/demo/Interface.test8:()V
        41: invokedynamic #15,  0             // InvokeDynamic #0:apply:()Ljava/util/function/Function;
        46: astore_2
        47: new           #16                 // class net/yury/demo/Demo12DynamicLinking2$1
        50: dup
        51: aload_0
        52: invokespecial #17                 // Method net/yury/demo/Demo12DynamicLinking2$1.&quot;&lt;init&gt;&quot;:(Lnet/yury/demo/Demo12DynamicLinking2;)V
        55: astore_3
        56: aload_2
        57: ldc           #18                 // String 123
        59: invokeinterface #19,  2           // InterfaceMethod java/util/function/Function.apply:(Ljava/lang/Object;)Ljava/lang/Object;
        64: checkcast     #20                 // class java/lang/String
        67: astore        4
        69: aload_3
        70: ldc           #21                 // String 456
        72: invokeinterface #19,  2           // InterfaceMethod java/util/function/Function.apply:(Ljava/lang/Object;)Ljava/lang/Object;
        77: checkcast     #20                 // class java/lang/String
        80: astore        5
        82: return
</code></pre>
<blockquote>
<p>继承和方法重写的本质</p>
</blockquote>
<p>java的类可能会有继承关系，而调用一个子类的方法时，JVM怎么知道这个方法是子类重写的方法，还是父类的方法呢。JVM会在编译期做以下操作。</p>
<ol>
<li>将该方法所属的对象引用加载到操作数栈（如果调用静态方法则省略这一步）</li>
<li>找到操作数栈栈顶的第一个元素所执行的对象的实际类型，记作 C</li>
<li>如果在运行时常量池的类型C中找到参数和返回值类型都和调用的方法相同的方法，则再进行权限校验，如果通过则返回这个方法的直接引用，如果权限校验不通过，则返回java.lang.IllegalAccessError异常；</li>
<li>如果没找到类型C中没找到这种方法，则按照类继承关系依次往父类执行第3步查找和权限校验。</li>
<li>如果最终无法正常返回一个方法的直接引用，则抛出异常。</li>
</ol>
<p>因此如果子类有这个方法则调用的是子类的方法，如果没有，则调用的是第一个有该方法的父类方法。</p>
<h4 id="（5）方法返回地址"><a href="#（5）方法返回地址" class="headerlink" title="（5）方法返回地址"></a>（5）方法返回地址</h4><p>正常返回：<font color="Red">方法返回地址存放调用该方法的pc寄存器的值，即返回下一条将要执行的指令的地址。</font></p>
<p>异常返回：通过异常表来确定，栈帧中一般不保存这部分信息。</p>
<p>方法返回的本质：</p>
<ul>
<li>当前栈帧出栈</li>
<li>返回到上层方法的局部变量表、操作数栈，将当前方法的返回值压入操作数栈（如果上层方法要使用的话）</li>
<li>设置pc寄存器的值</li>
</ul>
<p>return指令根据返回值类型的不同分为以下几种：</p>
<ul>
<li>return：返回void</li>
<li>ireturn：返回32位的类型，如boolean、byte、short、char、int</li>
<li>dreturn：返回double</li>
<li>freturn：返回float</li>
<li>lreturn：返回long</li>
<li>areturn：返回引用类型，如所有的类</li>
</ul>
<p>异常处理表：</p>
<p>从<code>from</code>这一行字节码开始，到<code>to</code>这一行字节码，如果出现了<code>type</code>类型，则从<code>target</code>行指令继续执行。如下Exception table所示。</p>
<pre><code class="java">package net.yury.demo;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Arrays;

public class Demo09Method &#123;
    private String name;
    public static void main(String[] args) &#123;
        Demo09Method demo = new Demo09Method();
        String s;
        try&#123;
            s = demo.test1(100L);
            System.out.println(s);
        &#125;catch (FileNotFoundException ex)&#123;
            System.out.println(Arrays.toString(ex.getStackTrace()));
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=4, args_size=1
         0: new           #2                  // class net/yury/demo/Demo09Method
         3: dup
         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V
         7: astore_1
         8: aload_1
         9: ldc2_w        #4                  // long 100l
        12: invokevirtual #6                  // Method test1:(J)Ljava/lang/String;
        15: astore_2
        16: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
        19: aload_2
        20: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        23: goto          40
        26: astore_3
        27: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
        30: aload_3
        31: invokevirtual #10                 // Method java/io/FileNotFoundException.getStackTrace:()[Ljava/lang/StackTraceElement;
        34: invokestatic  #11                 // Method java/util/Arrays.toString:([Ljava/lang/Object;)Ljava/lang/String;
        37: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        40: return
      Exception table:
         from    to  target type
             8    23    26   Class java/io/FileNotFoundException
      LineNumberTable:
        line 10: 0
        line 13: 8
        line 14: 16
        line 17: 23
        line 15: 26
        line 16: 27
        line 18: 40
</code></pre>
<h4 id="（6）一些附加信息"><a href="#（6）一些附加信息" class="headerlink" title="（6）一些附加信息"></a>（6）一些附加信息</h4><p>略。</p>
<h4 id="（7）问题"><a href="#（7）问题" class="headerlink" title="（7）问题"></a>（7）问题</h4><blockquote>
<p>栈相关的报错有哪些？</p>
</blockquote>
<p>stackoverflow，栈溢出，方法调用的次数太多以致于栈耗费的空间超过了我们设置的栈大小，可以通过修改-Xss设置栈大小。</p>
<p>outofmemory，内存不足，栈空间设置足够大，但是方法调用过多，导致整体内存不足。（OOM很少出现在栈空间发生）</p>
<blockquote>
<p>调整栈空间大小，可以保证不出现溢出吗？</p>
</blockquote>
<p>不能。若使用固定大小的栈，即使调整了栈空间大小，他也是确定的；而程序方法的调用如在出现递归的情况下，调用次数是不确定的，有可能会出现栈溢出的情况。</p>
<blockquote>
<p>分配栈空间内存越大越好吗？</p>
</blockquote>
<p>服务器资源是有效的，栈空间内存分配越大，则其他资源（如堆）分配到的空间就受限。应根据服务器和应用程序的实际情况分配。</p>
<blockquote>
<p>垃圾回收会设计到栈空间吗？</p>
</blockquote>
<p>不会，栈没有垃圾回收。</p>
<blockquote>
<p>java对象一定都是在对空间上创建的吗？</p>
</blockquote>
<p>不一定，栈也可以创建对象。堆那边再聊。</p>
<blockquote>
<p><font color="Red">局部变量是线程安全的吗？</font></p>
</blockquote>
<p>若该局部变量是方法内部产生，且方法内部销毁的，则这个局部变量是线程安全的。</p>
<p>若该局部变量以参数形式传入方法，或者作为返回值返回出去的，则这个局部变量是线程不安全的。</p>
<p><strong>即只要这个局部变量的生命周期完全在这个方法内，则是线程安全的；否则是线程不安全的。</strong></p>
<p>一个对象的指针或引用被多个方法或线程使用，即称这个对象出现了<strong>逃逸</strong>（Escape）。全局变量如类属性和私有属性可能会被多个方法或线程使用，这种线程安全问题很常见；而局部变量如果其作用域不仅限于该方法，还被其他方法或线程使用了，即出现了逃逸，则也可能会存在线程安全问题。具体见后面的<strong>逃逸分析</strong>。</p>
<p>最稳妥的方式是，避免局部变量逃逸到其他方法或线程中，如</p>
<ul>
<li>方法参数尽量使用线程安全的对象，或者不可变对象（如String），或者使用私有属性的方式代替传入参数的形式来定义方法。</li>
<li>避免将局部变量作为方法返回值，或者以一个线程安全的或不可变的对象的形式返回（如返回<code>StringBuilder.ToString()</code>）。</li>
<li>坚守一个原则：对象的作用域尽量维持在使用它的最小作用域</li>
</ul>
<pre><code class="java">package net.yury.demo;

public class Demo13ThreadSafe &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        method2();
    &#125;

    public static void method1() throws InterruptedException &#123;
        StringBuilder sb = new StringBuilder();
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10000; i++) &#123;
                sb.append(&#39;a&#39;);
            &#125;
        &#125;).start();
        new Thread(() -&gt; add(sb)).start();
        Thread.sleep(1000);
        System.out.println(sb.toString());
    &#125;

    public static void add(StringBuilder sb)&#123;
        for (int i = 0; i &lt;10000; i++) &#123;
            sb.append(&#39;b&#39;);
        &#125;
    &#125;

    public static void method2() throws InterruptedException &#123;
        StringBuilder sb = add2();
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10000; i++) &#123;
                sb.append(&#39;1&#39;);
            &#125;
        &#125;).start();
        new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 10000; i++) &#123;
                sb.append(&#39;2&#39;);
            &#125;
        &#125;).start();
        Thread.sleep(1000);
        System.out.println(sb.toString());
    &#125;

    public static StringBuilder add2()&#123;
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;abc&quot;);
        return sb;
    &#125;
&#125;
</code></pre>
<h3 id="5、本地方法栈"><a href="#5、本地方法栈" class="headerlink" title="5、本地方法栈"></a>5、本地方法栈</h3><p><font color="Red">本地方法栈（Nativa Method Stack）用于管理本地方法的调用，本地方法栈也是线程私有的。</font></p>
<p>本地方法：使用native关键字修饰的方法，由C/C++实现。</p>
<p>本地方法栈的大小和异常种类和普通的JVM栈是相同的，允许被实现成固定大小或者动态扩展的，溢出和OOM都有可能存在。</p>
<p>本地方法栈的具体做法就是执行本地方法时，在本地方法栈中压入本地方法，然后让执行引擎从本地方法库中加载这个本地方法，再让本地方法执行，最后本地方法栈栈顶元素出栈。</p>
<p><strong>本地方法接口</strong>就是本地方法运行时和JVM沟通的接口，<strong>本地方法库</strong>就是java所有本地方法的集合。</p>
<p><font color="Red">当某个线程调用本地方法时，本地方法执行的权限和JVM有着相同的权限。</font></p>
<ul>
<li>本地方法可以通过本地方法接口来访问JMV内部的运行时数据区。</li>
<li>本地方法可以直接使用本地处理器中的寄存器</li>
<li>本地方法可以直接从本地内存堆中分配任意数量的内存。</li>
</ul>
<p>并不是所有的JVM都支持本地方法，因为JVM规范中并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等，如果JVM产品不打算支持本地方法，那么无需实现本地方法栈也是可以的。</p>
<p>在HotSpot JVM中，直接将JVM栈和本地方法栈合二为一。</p>
<h3 id="6、JVM堆"><a href="#6、JVM堆" class="headerlink" title="6、JVM堆"></a>6、JVM堆</h3><ul>
<li><p>堆是JVM进程私有的，一个JVM进程只有一个堆内存，堆也是JVM内存管理的核心区域。</p>
</li>
<li><p>堆内存的大小是可以调节的。</p>
</li>
<li><p>JVM规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上他应该被视为连续的。</p>
</li>
</ul>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/project/flink_data_warehouse/flink_data_warehouse">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  flink_data_warehouse
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/database/postgresql/postgresql">
                postgresql
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>