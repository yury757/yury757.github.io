<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Java_NIO-study | 
	 
	Yury&#39;s Blog
	</title>
	
	<!-- keywords,description -->
	 
		<meta name="description" content="blog of usual study" />
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "wujun234.github.io";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Yury's Blog" type="application/atom+xml">
</head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">Yury's Blog</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	
		<li class="menu-item">
			<a href="/tags" class="menu-item-link">标签</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/yury757" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										hbase
									</a>
									
							<ul>
								<li class="file">
									<a href="/hbase/HBase-study">
										HBase-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/hello-world">
										hello-world
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										SSM-Build
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/SSM-Build/SSM-Build">
										SSM-Build
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java_JUC
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/java_JUC/Java_JUC-study">
										Java_JUC-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java_NIO
									</a>
									
							<ul>
								<li class="file active">
									<a href="/java/java_NIO/Java_NIO-study">
										Java_NIO-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										mybatis
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/mybatis/mybatis-study">
										mybatis-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										springMVC
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/springMVC/SpringMVC-Study">
										SpringMVC-Study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										springboot
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/springboot/springboot-study">
										springboot-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										spring
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/spring/Spring-study">
										Spring-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	Java_NIO-study
</h1>
<div class="article-meta">
	
	<span>Yury</span>
	<span>2021-08-24 00:00:00</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
                
                    <span>
                        <i class="fa fa-folder" aria-hidden="true">
                        <a href="/categories/java/">java</a>
                        </i>
                      
                    </span>
                
            
    

    
		<span>Tags：</span>
            
                
                    <span>
                        <i class="fa fa-tag" aria-hidden="true">
                        <a href="/tags/java/">java</a>
                        </i>
                    </span>
                
            
    
		</div>

</div>

<div id="article-content">
	<h2 id="一、NIO和IO的区别"><a href="#一、NIO和IO的区别" class="headerlink" title="一、NIO和IO的区别"></a>一、NIO和IO的区别</h2><ul>
<li><p>传统IO面向流，而NIO面向管道（channel）和缓冲区（buffer）。传统IO只能单向传输数据，而NIO可以双向传输数据。传统IO就像单向水管，而NIO中channel像列车轨道，buffer就像火车，可以双向传输数据。</p>
</li>
<li><p>传统IO是阻塞（blocking）的，而NIO就是非阻塞（Non blocking）的。</p>
</li>
<li><p>NIO多了一个选择器（Selector），是针对网络编程用的。</p>
</li>
</ul>
<h2 id="二、缓冲区（Buffer）"><a href="#二、缓冲区（Buffer）" class="headerlink" title="二、缓冲区（Buffer）"></a>二、缓冲区（Buffer）</h2><p>缓冲区（Buffer）是基于数组来做管理的，负责存取数据。java NIO有七种xxxBuffer类，都继承了Buffer类，即八种基本数据类型中，除了boolean以外都提供了对应的xxxBuffer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer</span><br><span class="line">CharBuffer</span><br><span class="line">ShortBuffer</span><br><span class="line">IntBuffer</span><br><span class="line">LongBuffer</span><br><span class="line">FloatBuffer</span><br><span class="line">DoubleBuffer</span><br></pre></td></tr></table></figure>

<p>每种xxxBuffer类还不是最终实现类，最终的实现类有两种，以下以ByteBuffer为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属于下面说的直接缓冲区，不懂操作系统的人最好不要使用，有风险</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectByteBufferR</span> <span class="keyword">extends</span> <span class="title">DirectByteBuffer</span> <span class="keyword">implements</span> <span class="title">DirectBuffer</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用这个实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapByteBuffer</span> <span class="keyword">extends</span> <span class="title">ByteBuffer</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、四个核心属性"><a href="#1、四个核心属性" class="headerlink" title="1、四个核心属性"></a>1、四个核心属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容量，缓冲区总的最大容量</span></span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大可读写的容量</span></span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置，表示缓冲区中正在操作的数据的下标。当position&lt;limit，可以做写入操作，当position=limit时，写入操作会报错。</span></span><br><span class="line"><span class="keyword">int</span> position;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记位置，默认为-1</span></span><br><span class="line"><span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark &lt; position &lt; limit &lt; capacity</span></span><br></pre></td></tr></table></figure>

<h3 id="2、主要方法"><a href="#2、主要方法" class="headerlink" title="2、主要方法"></a>2、主要方法</h3><p>下面以ByteBuffer为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存入数据到缓冲区中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将缓冲区的数据读取到另外一个数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换到读取数据的模式。将limit的值置为当前position的值，再把position归0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        limit = position;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复到初始状态，注意数据还在，只是被遗忘了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        limit = capacity;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将position恢复到上一次mark标记的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mark;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">        position = m;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="Red">注意：<code>public ByteBufferget(byte[] dst, int offset, int length)</code>方法参数中的offset和length不是针对源buffer，而是针对新数组dst的！！</font></p>
<h3 id="3、非直接缓冲区"><a href="#3、非直接缓冲区" class="headerlink" title="3、非直接缓冲区"></a>3、非直接缓冲区</h3><p><img src="/.io//%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<h3 id="4、直接缓冲区"><a href="#4、直接缓冲区" class="headerlink" title="4、直接缓冲区"></a>4、直接缓冲区</h3><p><img src="/.io//%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<p><strong>优点</strong>：效率更高！</p>
<p><strong>缺点：</strong>消耗资源大，数据写入到物理内存中后不受java控制，垃圾回收也有一定的问题。</p>
<p><img src="/.io//%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png"></p>
<h2 id="三、通道（Channel）"><a href="#三、通道（Channel）" class="headerlink" title="三、通道（Channel）"></a>三、通道（Channel）</h2><p>之前进行IO操作，是通过CPU授权给DMA（Direct Memory Access）总线，然后在DMA总线的管理下进行IO操作。而Channel则是一种独立的专门处理IO操作的特殊的（协）处理器，具有自己的IO指令，进行IO操作时不需要CPU授权。</p>
<p><img src="/.io//%E9%80%9A%E9%81%93.png"></p>
<h3 id="1、接口和实现类"><a href="#1、接口和实现类" class="headerlink" title="1、接口和实现类"></a>1、接口和实现类</h3><p>接口：</p>
<p>java.nio.Channels.Channel</p>
<p>实现类：</p>
<ul>
<li>FileChannel：本地数据IO</li>
<li>SocketChannel：TCP连接用</li>
<li>ServerSocketChannel：TCP连接用</li>
<li>DatagramChannel：UDP连接用</li>
</ul>
<h3 id="2、获取通道的三种方式"><a href="#2、获取通道的三种方式" class="headerlink" title="2、获取通道的三种方式"></a>2、获取通道的三种方式</h3><h4 id="（1）各个支持通道的IO类提供了相应的getChannel方法"><a href="#（1）各个支持通道的IO类提供了相应的getChannel方法" class="headerlink" title="（1）各个支持通道的IO类提供了相应的getChannel方法"></a>（1）各个支持通道的IO类提供了相应的getChannel方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(<span class="comment">// 获取流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(filename1);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(filename2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取对应的通道</span></span><br><span class="line">        FileChannel fisChannel = fis.getChannel();</span><br><span class="line">        FileChannel fosChannel = fos.getChannel();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过非直接缓冲区方式</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将源数据通道的数据写入缓冲区</span></span><br><span class="line">        <span class="keyword">while</span> (fisChannel.read(buffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 切换成读取模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取缓冲区中的数据，写入目标数据通道</span></span><br><span class="line">            fosChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清空缓冲区</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用try()&#123;&#125;的方式就可以不用关闭，否则就要关闭所有的流和通道</span></span><br><span class="line">    <span class="comment">//        fosChannel.close();</span></span><br><span class="line">    <span class="comment">//        fisChannel.close();</span></span><br><span class="line">    <span class="comment">//        fis.close();</span></span><br><span class="line">    <span class="comment">//        fos.close();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）使用open函数"><a href="#（2）使用open函数" class="headerlink" title="（2）使用open函数"></a>（2）使用open函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date startTime = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="comment">// 通过open的方式获取通道</span></span><br><span class="line">    <span class="comment">// CREATE_NEW：当文件存在时会报错</span></span><br><span class="line">    <span class="comment">// CREATE：当文件存在时，会在原文件上从头开始覆盖写入。</span></span><br><span class="line">    <span class="comment">// 但是很奇怪，当使用CREATE和直接缓冲区结合的方式时，当source文件的字节数小于destination文件的字节数时，并不会发生写入操作。</span></span><br><span class="line">    <span class="comment">// 即一般使用CREATE_NEW就行</span></span><br><span class="line">    <span class="keyword">try</span>(FileChannel fisChannel = FileChannel.open(Paths.get(filename1), StandardOpenOption.READ);</span><br><span class="line">        FileChannel fosChannel = FileChannel.open(Paths.get(filename2), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用非直接缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (fisChannel.read(buffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            fosChannel.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 通过直接缓冲区方式</span></span><br><span class="line"><span class="comment">            MappedByteBuffer inMappedBuffer = fisChannel.map(FileChannel.MapMode.READ_ONLY, 0, fisChannel.size());</span></span><br><span class="line"><span class="comment">            MappedByteBuffer outMappedBuffer = fosChannel.map(FileChannel.MapMode.READ_WRITE, 0, fisChannel.size());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            // 对直接缓冲区中的数据进行读写，因此省略了从OS地址空间到JVM地址空间的copy操作</span></span><br><span class="line"><span class="comment">            // 使用内存映射文件时，就是将一个硬盘上的文件通过通道映射到物理内存的缓冲区中，当缓冲区有put操作，则会直接将对应的数据写入硬盘</span></span><br><span class="line"><span class="comment">            byte[] dst = new byte[inMappedBuffer.limit()];</span></span><br><span class="line"><span class="comment">            inMappedBuffer.get(dst);</span></span><br><span class="line"><span class="comment">            outMappedBuffer.put(dst);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭通道，同样如果使用了try()&#123;&#125;则不用关闭</span></span><br><span class="line">        <span class="comment">//            fisChannel.close();</span></span><br><span class="line">        <span class="comment">//            fosChannel.close();</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (endTime.getTime() - startTime.getTime()) / <span class="number">1000</span> + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="Red">注意！！使用Channel.transferTo方法时，一次传输最大传输支持2G，如果文件超过2G，则要断点传输！如下：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Date startTime = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">try</span>(FileChannel fisChannel = FileChannel.open(Paths.get(filename1), StandardOpenOption.READ);</span><br><span class="line">        FileChannel fosChannel = FileChannel.open(Paths.get(filename2), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE_NEW))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 通过transferTo，也是通过直接缓冲区的方式</span></span><br><span class="line">        <span class="comment">// transferTo一次传输最大2G，因此无论文件大小的化，最好使用以下方式</span></span><br><span class="line">        <span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> len = fisChannel.size();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt; len)&#123;</span><br><span class="line">            <span class="keyword">long</span> l = fisChannel.transferTo(position, len, fosChannel);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                position = l;</span><br><span class="line">                len -= l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + (endTime.getTime() - startTime.getTime()) / <span class="number">1000</span> + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）通过Files创建"><a href="#（3）通过Files创建" class="headerlink" title="（3）通过Files创建"></a>（3）通过Files创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.newByteChannel();</span><br></pre></td></tr></table></figure>

<h3 id="3、聚集和分散"><a href="#3、聚集和分散" class="headerlink" title="3、聚集和分散"></a>3、聚集和分散</h3><p>分散读取（Scattering Reads）：读取文件时按顺序填入多个缓冲区中，前面的缓冲区填满了，再填后面的缓冲区</p>
<p>聚集写入（Gathering Writes）：将多个缓冲区中的数据按顺序写入到通道中</p>
<p>即就是将channel写入一个bytebuffer数组中，或者从一个bytebuffer数组中读取数据到channel。</p>
<p><img src="/.io//%E8%81%9A%E9%9B%86%E5%92%8C%E5%88%86%E6%95%A3.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(filename1, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        FileChannel channel = raf.getChannel();</span><br><span class="line">        RandomAccessFile raf2 = <span class="keyword">new</span> RandomAccessFile(filename2, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel2 = raf2.getChannel();</span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======分散读取======&quot;</span>);</span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        ByteBuffer buffer2 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 写入缓冲区</span></span><br><span class="line">        ByteBuffer[] buffers = &#123;buffer1, buffer2&#125;;</span><br><span class="line">        channel.read(buffers);</span><br><span class="line">        <span class="comment">// 将缓冲区切换成读取模式</span></span><br><span class="line">        <span class="keyword">for</span> (ByteBuffer buffer : buffers) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将缓冲区中的内容打印出来</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffers[<span class="number">0</span>].array(), <span class="number">0</span>, buffers[<span class="number">0</span>].limit()));</span><br><span class="line">        System.out.println(<span class="string">&quot;=============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffers[<span class="number">1</span>].array(), <span class="number">0</span>, buffers[<span class="number">1</span>].limit()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======聚集写入======&quot;</span>);</span><br><span class="line">        channel2.write(buffers);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、字符集（Charset）"><a href="#四、字符集（Charset）" class="headerlink" title="四、字符集（Charset）"></a>四、字符集（Charset）</h2><p>编码：字符串 =&gt; 字节数组</p>
<p>解码：字节数组 =&gt; 字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SortedMap&lt;String, Charset&gt; stringCharsetSortedMap = Charset.availableCharsets();</span><br><span class="line">    stringCharsetSortedMap.forEach((key, value) -&gt; &#123;</span><br><span class="line">        System.out.println(key.getClass().getName());</span><br><span class="line">        System.out.println(value.getClass().getName());</span><br><span class="line">        System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取一个字符集的类，并得到他们的编码器和解码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Charset gbk = Charset.forName(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">CharsetEncoder charsetEncoder = gbk.newEncoder();</span><br><span class="line">CharsetDecoder charsetDecoder = gbk.newDecoder();</span><br></pre></td></tr></table></figure>

<p>encode方法得到一个ByteBuffer，而decode方法得到一个CharBuffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Charset gbk = Charset.forName(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> CharsetEncoder charsetEncoder = gbk.newEncoder();</span><br><span class="line">    <span class="keyword">final</span> CharsetDecoder charsetDecoder = gbk.newDecoder();</span><br><span class="line"></span><br><span class="line">    CharBuffer charBuffer = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    charBuffer.put(<span class="string">&quot;你好，世界！hello, world!!&quot;</span>);</span><br><span class="line">    charBuffer.flip();</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = charsetEncoder.encode(charBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteBuffer.limit(); i++) &#123;</span><br><span class="line">        System.out.print(byteBuffer.get() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    CharBuffer charBuffer2 = charsetDecoder.decode(byteBuffer);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charBuffer2.limit(); i++) &#123;</span><br><span class="line">        System.out.print(charBuffer2.get() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    charBuffer2.flip();</span><br><span class="line"></span><br><span class="line">    System.out.println(charBuffer2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、阻塞和非阻塞（重点！！）"><a href="#五、阻塞和非阻塞（重点！！）" class="headerlink" title="五、阻塞和非阻塞（重点！！）"></a>五、阻塞和非阻塞（重点！！）</h2><p>这里所说的阻塞和非阻塞主要针对网络编程。在客户端连接服务器时，客户端要向服务器发送数据包请求，双方都会打开一个通道，但是当服务器读取一段数据后，不清楚客户端通道中的数据是否读取完，则这个线程会被阻塞。</p>
<p>而非阻塞网络IO就是在客户端和服务器之间加一个选择器（Selector），所有客户端发送过来的数据包都先通过选择器，由选择器来判断该数据包是否准备完毕，将准备完毕的数据包发送给服务器去处理，而没准备完毕的数据包留在这里。</p>
<p><img src="/.io//%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F.png"></p>
<p>因此，使用NIO完成网络通信的三个核心：</p>
<ul>
<li>Channel，负责连接</li>
<li>Buffer，负责传输数据</li>
<li>Selector，是SelectableChannel的多路复用器，用于监控SelectableChannel的IO状况。</li>
</ul>
<p>这部分笔者还不是很清楚。</p>
<h2 id="六、NIO实战项目"><a href="#六、NIO实战项目" class="headerlink" title="六、NIO实战项目"></a>六、NIO实战项目</h2><p>用NIO写一个非阻塞式http服务器：<a target="_blank" rel="noopener" href="https://github.com/yury757/httpserver">yury757/httpserver (github.com)</a></p>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/java/SSM-Build/SSM-Build">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  SSM-Build
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/java/mybatis/mybatis-study">
                mybatis-study
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Yury</a> 
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>