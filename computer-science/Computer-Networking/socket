<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		socket入门学习 | 
	 
	Yury&#39;s Blog
	</title>
	
	<!-- keywords,description -->
	 
		<meta name="description" content="blog of usual study" />
	

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Yury's Blog" type="application/atom+xml">
</head>

<body>
	<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3efe99c287df5a1d6f0d02d187e403c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<header id="header">
    <a id="title" href="/" class="logo">Yury's Blog</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
	
		<li class="menu-item">
			<a href="/tags" class="menu-item-link">标签</a>
		</li>
	

	
		<li class="menu-item">
			<a href="/categories" class="menu-item-link">分类</a>
		</li>
	

		<li class="menu-item">
			<a href="https://github.com/yury757" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Git
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										learngit
									</a>
									
							<ul>
								<li class="file">
									<a href="/Git/learngit/learn-git">
										learn-git
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										bigdata
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										clickhouse
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/clickhouse/clickhouse">
										clickhouse
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										hadoop
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/hadoop/hadoop-study">
										hadoop-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										hbase
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/hbase/HBase-study">
										HBase-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										kafka
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/kafka/kafka">
										kafka
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										zookeeper
									</a>
									
							<ul>
								<li class="file">
									<a href="/bigdata/zookeeper/zookeeper-study">
										zookeeper-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										computer-science
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										Computer-Networking
									</a>
									
							<ul>
								<li class="file">
									<a href="/computer-science/Computer-Networking/Computer-Networking">
										Computer-Networking
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/computer-science/Computer-Networking/socket">
										socket
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										database
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										mysql
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL中的exists与in的使用
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E4%B8%AD%E7%9A%84exists%E4%B8%8Ein%E7%9A%84%E4%BD%BF%E7%94%A8/MySQL%E4%B8%AD%E7%9A%84exists%E4%B8%8Ein%E7%9A%84%E4%BD%BF%E7%94%A8">
										MySQL中的exists与in的使用
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL备份-Linux版
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E5%A4%87%E4%BB%BD-Linux%E7%89%88/MySQL%E5%A4%87%E4%BB%BD-linux%E7%89%88">
										MySQL备份-linux版
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL日期格式化
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/MySQL%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96">
										MySQL日期格式化
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL查询执行计划详解-explain
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3-explain/MySQL%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3-explain">
										MySQL查询执行计划详解-explain
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										MySQL迁移数据目录
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/MySQL%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/MySQL%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95">
										MySQL迁移数据目录
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										《高性能MySQL》
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第1章-MySQL架构与历史
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC1%E7%AB%A0-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/%E7%AC%AC%E4%B8%80%E7%AB%A0-MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2">
										第一章-MySQL架构与历史
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第2章-MySQL基准测试
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC2%E7%AB%A0-MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95">
										第二章 MySQL基准测试
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第3章-服务器性能剖析
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC3%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90">
										第三章-服务器性能剖析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第4章-Schema与数据类型优化
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC4%E7%AB%A0-Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/%E7%AC%AC%E5%9B%9B%E7%AB%A0-Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96">
										第四章-Schema与数据类型优化
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										第5章-创建高性能的索引
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/mysql/%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E3%80%8B/%E7%AC%AC5%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95">
										第五章-创建高性能的索引
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										postgresql
									</a>
									
							<ul>
								<li class="file">
									<a href="/database/postgresql/postgresql">
										postgresql
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										JVM
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/JVM/jvm-1.8">
										jvm-1.8
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										SSM-Build
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/SSM-Build/SSM-Build">
										SSM-Build
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java_JUC
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/java_JUC/Java_JUC-study">
										Java_JUC-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										java_NIO
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/java_NIO/Java_NIO-study">
										Java_NIO-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/java/java%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE">
										java常用配置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										mybatis
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/mybatis/mybatis-study">
										mybatis-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										springMVC
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/springMVC/SpringMVC-Study">
										SpringMVC-Study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										springboot
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/springboot/springboot-study">
										springboot-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										spring
									</a>
									
							<ul>
								<li class="file">
									<a href="/java/spring/Spring-study">
										Spring-study
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/jetbrains%E7%B3%BB%E5%88%97IDE%E6%8E%A8%E8%8D%90%E8%AE%BE%E7%BD%AE">
										jetbrains系列IDE推荐设置
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										linux
									</a>
									
							<ul>
								<li class="file">
									<a href="/linux/linux%E5%91%BD%E4%BB%A4">
										linux命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/linux/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E6%8C%96%E7%9F%BF%E7%9A%84%E7%BB%8F%E5%8E%86">
										记一次服务器被挖矿的经历
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										operating-support
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										docker
									</a>
									
							<ul>
								<li class="file">
									<a href="/operating-support/docker/docker">
										docker
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										project
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										flink_data_warehouse
									</a>
									
							<ul>
								<li class="file">
									<a href="/project/flink_data_warehouse/flink_data_warehouse">
										flink_data_warehouse
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E7%AB%AF%E5%8F%A3%E5%8F%B7">
										常用组件端口号
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	socket
</h1>
<div class="article-meta">
	
	<span>Yury</span>
	<span>2022-04-15 00:00:00</span>
		<div id="article-categories">
    
		<span>Categories：</span>
            
    

    
		<span>Tags：</span>
            
    
		</div>

</div>

<div id="article-content">
	<p>本学习笔记基于ubuntu18+cpp14中socket代码，学习socket。</p>
<p>最权威的文档：man命令。</p>
<h2 id="1、socket是什么"><a href="#1、socket是什么" class="headerlink" title="1、socket是什么"></a>1、socket是什么</h2><p>socket是一个**<font color="Red">文件描述符（file descriptor）</font>**，可以通过设置DOMAIN、TYPE、PROTOCOL来创建不同类型的socket。</p>
<p>linux将网络IO抽象为对文件的IO，socket就是网络IO的一个通道或者接口。</p>
<pre><code class="c++">// &lt;sys/socket.h&gt;

/* Create a new socket of type TYPE in domain DOMAIN, using
   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
   Returns a file descriptor for the new socket, or -1 for errors.  */
extern int socket (int __domain, int __type, int __protocol) __THROW;
</code></pre>
<h3 id="（1）DOMAIN"><a href="#（1）DOMAIN" class="headerlink" title="（1）DOMAIN"></a>（1）DOMAIN</h3><p>DOMAIN是指地址簇，或者协议簇，表示不同类型的<strong>地址识别方式</strong>。如下所示有这么多种地址簇。</p>
<p>最常用的就是TCP/IP协议簇，即<code>PF_INET</code>，或<code>AF_INET</code>；以及IPV6协议簇，<code>PF_INET6</code>，或<code>AF_INET6</code>。</p>
<p>protocol family和address family本质上是同一种分类，只是为了适配不同的系统才形成两类宏名。在linux上我们一般用<code>AF</code>这一套。</p>
<pre><code class="c++">/* Protocol families.  */
#define PF_UNSPEC    0    /* Unspecified.  */
#define PF_LOCAL    1    /* Local to host (pipes and file-domain).  */
#define PF_UNIX        PF_LOCAL /* POSIX name for PF_LOCAL.  */
#define PF_FILE        PF_LOCAL /* Another non-standard name for PF_LOCAL.  */
#define PF_INET        2    /* IP protocol family.  */
#define PF_AX25        3    /* Amateur Radio AX.25.  */
#define PF_IPX        4    /* Novell Internet Protocol.  */
#define PF_APPLETALK    5    /* Appletalk DDP.  */
#define PF_NETROM    6    /* Amateur radio NetROM.  */
#define PF_BRIDGE    7    /* Multiprotocol bridge.  */
#define PF_ATMPVC    8    /* ATM PVCs.  */
#define PF_X25        9    /* Reserved for X.25 project.  */
#define PF_INET6    10    /* IP version 6.  */
#define PF_ROSE        11    /* Amateur Radio X.25 PLP.  */
#define PF_DECnet    12    /* Reserved for DECnet project.  */
#define PF_NETBEUI    13    /* Reserved for 802.2LLC project.  */
#define PF_SECURITY    14    /* Security callback pseudo AF.  */
#define PF_KEY        15    /* PF_KEY key management API.  */
#define PF_NETLINK    16
#define PF_ROUTE    PF_NETLINK /* Alias to emulate 4.4BSD.  */
#define PF_PACKET    17    /* Packet family.  */
#define PF_ASH        18    /* Ash.  */
#define PF_ECONET    19    /* Acorn Econet.  */
#define PF_ATMSVC    20    /* ATM SVCs.  */
#define PF_RDS        21    /* RDS sockets.  */
#define PF_SNA        22    /* Linux SNA Project */
#define PF_IRDA        23    /* IRDA sockets.  */
#define PF_PPPOX    24    /* PPPoX sockets.  */
#define PF_WANPIPE    25    /* Wanpipe API sockets.  */
#define PF_LLC        26    /* Linux LLC.  */
#define PF_IB        27    /* Native InfiniBand address.  */
#define PF_MPLS        28    /* MPLS.  */
#define PF_CAN        29    /* Controller Area Network.  */
#define PF_TIPC        30    /* TIPC sockets.  */
#define PF_BLUETOOTH    31    /* Bluetooth sockets.  */
#define PF_IUCV        32    /* IUCV sockets.  */
#define PF_RXRPC    33    /* RxRPC sockets.  */
#define PF_ISDN        34    /* mISDN sockets.  */
#define PF_PHONET    35    /* Phonet sockets.  */
#define PF_IEEE802154    36    /* IEEE 802.15.4 sockets.  */
#define PF_CAIF        37    /* CAIF sockets.  */
#define PF_ALG        38    /* Algorithm sockets.  */
#define PF_NFC        39    /* NFC sockets.  */
#define PF_VSOCK    40    /* vSockets.  */
#define PF_KCM        41    /* Kernel Connection Multiplexor.  */
#define PF_QIPCRTR    42    /* Qualcomm IPC Router.  */
#define PF_SMC        43    /* SMC sockets.  */
#define PF_MAX        44    /* For now..  */

/* Address families.  */
#define AF_UNSPEC    PF_UNSPEC
#define AF_LOCAL    PF_LOCAL
#define AF_UNIX        PF_UNIX
#define AF_FILE        PF_FILE
#define AF_INET        PF_INET
#define AF_AX25        PF_AX25
#define AF_IPX        PF_IPX
#define AF_APPLETALK    PF_APPLETALK
#define AF_NETROM    PF_NETROM
#define AF_BRIDGE    PF_BRIDGE
#define AF_ATMPVC    PF_ATMPVC
#define AF_X25        PF_X25
#define AF_INET6    PF_INET6
#define AF_ROSE        PF_ROSE
#define AF_DECnet    PF_DECnet
#define AF_NETBEUI    PF_NETBEUI
#define AF_SECURITY    PF_SECURITY
#define AF_KEY        PF_KEY
#define AF_NETLINK    PF_NETLINK
#define AF_ROUTE    PF_ROUTE
#define AF_PACKET    PF_PACKET
#define AF_ASH        PF_ASH
#define AF_ECONET    PF_ECONET
#define AF_ATMSVC    PF_ATMSVC
#define AF_RDS        PF_RDS
#define AF_SNA        PF_SNA
#define AF_IRDA        PF_IRDA
#define AF_PPPOX    PF_PPPOX
#define AF_WANPIPE    PF_WANPIPE
#define AF_LLC        PF_LLC
#define AF_IB        PF_IB
#define AF_MPLS        PF_MPLS
#define AF_CAN        PF_CAN
#define AF_TIPC        PF_TIPC
#define AF_BLUETOOTH    PF_BLUETOOTH
#define AF_IUCV        PF_IUCV
#define AF_RXRPC    PF_RXRPC
#define AF_ISDN        PF_ISDN
#define AF_PHONET    PF_PHONET
#define AF_IEEE802154    PF_IEEE802154
#define AF_CAIF        PF_CAIF
#define AF_ALG        PF_ALG
#define AF_NFC        PF_NFC
#define AF_VSOCK    PF_VSOCK
#define AF_KCM        PF_KCM
#define AF_QIPCRTR    PF_QIPCRTR
#define AF_SMC        PF_SMC
#define AF_MAX        PF_MAX
</code></pre>
<h3 id="（2）TYPE"><a href="#（2）TYPE" class="headerlink" title="（2）TYPE"></a>（2）TYPE</h3><p>TYPE是指socket传输类型，表示不同的<strong>传输层类型</strong>，如下所示。</p>
<ul>
<li>SOCK_STREAM，即有序的、可靠的、基于连接的字节流。（TCP）</li>
<li>SOCK_DGRAM，面向无连接的，不可靠，固定最大长度数据包。（UDP）</li>
<li>SOCK_RAW，原始socket数据包，需要手动解析数据包格式并作出对应处理。可以理解为TCP/UDP一种封装好了的数据包格式，而RAW则需要自己封装或解析数据包。</li>
<li>SOCK_PACKET，直接从网络链路层获取数据并处理数据，如MySQL、postgresql数据库连接的各种驱动就是这种网络连接方式。</li>
</ul>
<pre><code class="c++">/* Types of sockets.  */
enum __socket_type
&#123;
  SOCK_STREAM = 1,        /* Sequenced, reliable, connection-based
                   byte streams.  */
#define SOCK_STREAM SOCK_STREAM
  SOCK_DGRAM = 2,        /* Connectionless, unreliable datagrams
                   of fixed maximum length.  */
#define SOCK_DGRAM SOCK_DGRAM
  SOCK_RAW = 3,            /* Raw protocol interface.  */
#define SOCK_RAW SOCK_RAW
  SOCK_RDM = 4,            /* Reliably-delivered messages.  */
#define SOCK_RDM SOCK_RDM
  SOCK_SEQPACKET = 5,        /* Sequenced, reliable, connection-based,
                   datagrams of fixed maximum length.  */
#define SOCK_SEQPACKET SOCK_SEQPACKET
  SOCK_DCCP = 6,        /* Datagram Congestion Control Protocol.  */
#define SOCK_DCCP SOCK_DCCP
  SOCK_PACKET = 10,        /* Linux specific way of getting packets
                   at the dev level.  For writing rarp and
                   other similar things on the user level. */
#define SOCK_PACKET SOCK_PACKET

  /* Flags to be ORed into the type parameter of socket and socketpair and
     used for the flags parameter of paccept.  */

  SOCK_CLOEXEC = 02000000,    /* Atomically set close-on-exec flag for the
                   new descriptor(s).  */
#define SOCK_CLOEXEC SOCK_CLOEXEC
  SOCK_NONBLOCK = 00004000    /* Atomically mark descriptor(s) as
                   non-blocking.  */
#define SOCK_NONBLOCK SOCK_NONBLOCK
&#125;;
</code></pre>
<h3 id="（3）PROTOCAL"><a href="#（3）PROTOCAL" class="headerlink" title="（3）PROTOCAL"></a>（3）PROTOCAL</h3><p>PROTOCAL表示最终socket通信协议类型（= 网络层协议 + 传输层协议）。基于IP协议簇包括的协议类型如下。</p>
<p>如果选择0，用于TCP的虚拟协议，则操作系统会自动根据前两个参数选择一种协议。若自己填，却填错了，则无法创建socket。所以一般填0即可。</p>
<ul>
<li>IPPROTO_TCP，网络层使用IP协议，传输层使用TCP协议。</li>
<li>IPPROTO_TCP，网络层使用IP协议，传输层使用TCP协议。</li>
</ul>
<pre><code class="c++">/* Standard well-defined IP protocols.  */
enum
  &#123;
    IPPROTO_IP = 0,       /* Dummy protocol for TCP.  */
#define IPPROTO_IP        IPPROTO_IP
    IPPROTO_ICMP = 1,       /* Internet Control Message Protocol.  */
#define IPPROTO_ICMP        IPPROTO_ICMP
    IPPROTO_IGMP = 2,       /* Internet Group Management Protocol. */
#define IPPROTO_IGMP        IPPROTO_IGMP
    IPPROTO_IPIP = 4,       /* IPIP tunnels (older KA9Q tunnels use 94).  */
#define IPPROTO_IPIP        IPPROTO_IPIP
    IPPROTO_TCP = 6,       /* Transmission Control Protocol.  */
#define IPPROTO_TCP        IPPROTO_TCP
    IPPROTO_EGP = 8,       /* Exterior Gateway Protocol.  */
#define IPPROTO_EGP        IPPROTO_EGP
    IPPROTO_PUP = 12,       /* PUP protocol.  */
#define IPPROTO_PUP        IPPROTO_PUP
    IPPROTO_UDP = 17,       /* User Datagram Protocol.  */
#define IPPROTO_UDP        IPPROTO_UDP
    IPPROTO_IDP = 22,       /* XNS IDP protocol.  */
#define IPPROTO_IDP        IPPROTO_IDP
    IPPROTO_TP = 29,       /* SO Transport Protocol Class 4.  */
#define IPPROTO_TP        IPPROTO_TP
    IPPROTO_DCCP = 33,       /* Datagram Congestion Control Protocol.  */
#define IPPROTO_DCCP        IPPROTO_DCCP
    IPPROTO_IPV6 = 41,     /* IPv6 header.  */
#define IPPROTO_IPV6        IPPROTO_IPV6
    IPPROTO_RSVP = 46,       /* Reservation Protocol.  */
#define IPPROTO_RSVP        IPPROTO_RSVP
    IPPROTO_GRE = 47,       /* General Routing Encapsulation.  */
#define IPPROTO_GRE        IPPROTO_GRE
    IPPROTO_ESP = 50,      /* encapsulating security payload.  */
#define IPPROTO_ESP        IPPROTO_ESP
    IPPROTO_AH = 51,       /* authentication header.  */
#define IPPROTO_AH        IPPROTO_AH
    IPPROTO_MTP = 92,       /* Multicast Transport Protocol.  */
#define IPPROTO_MTP        IPPROTO_MTP
    IPPROTO_BEETPH = 94,   /* IP option pseudo header for BEET.  */
#define IPPROTO_BEETPH        IPPROTO_BEETPH
    IPPROTO_ENCAP = 98,       /* Encapsulation Header.  */
#define IPPROTO_ENCAP        IPPROTO_ENCAP
    IPPROTO_PIM = 103,       /* Protocol Independent Multicast.  */
#define IPPROTO_PIM        IPPROTO_PIM
    IPPROTO_COMP = 108,       /* Compression Header Protocol.  */
#define IPPROTO_COMP        IPPROTO_COMP
    IPPROTO_SCTP = 132,       /* Stream Control Transmission Protocol.  */
#define IPPROTO_SCTP        IPPROTO_SCTP
    IPPROTO_UDPLITE = 136, /* UDP-Lite protocol.  */
#define IPPROTO_UDPLITE        IPPROTO_UDPLITE
    IPPROTO_MPLS = 137,    /* MPLS in IP.  */
#define IPPROTO_MPLS        IPPROTO_MPLS
    IPPROTO_RAW = 255,       /* Raw IP packets.  */
#define IPPROTO_RAW        IPPROTO_RAW
    IPPROTO_MAX
  &#125;;
</code></pre>
<h3 id="（4）创建socket"><a href="#（4）创建socket" class="headerlink" title="（4）创建socket"></a>（4）创建socket</h3><p>若成功创建socket，则返回大于0的数字。创建失败则返回-1。</p>
<pre><code class="c++">// 基于ipv4的TCP连接
int socket1 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
cout &lt;&lt; socket1 &lt;&lt; endl;

// 基于ipv4的UDP连接
int socket2 = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
cout &lt;&lt; socket2 &lt;&lt; endl;

// 基于ipv4的原始数据包
int socket3 = socket(AF_INET, SOCK_RAW, 0);
cout &lt;&lt; socket3 &lt;&lt; endl;
</code></pre>
<h2 id="2、创建socket地址"><a href="#2、创建socket地址" class="headerlink" title="2、创建socket地址"></a>2、创建socket地址</h2><p>以ipv4地址为例。sockaddr_in结构体即为socket地址，三个变量分别为：</p>
<ul>
<li>SOCKADDR_COMMON (sin_)，地址簇，即创建socket的第一个参数</li>
<li>in_port_t sin_port，端口，是一个2字节无符号整数（unsigned short int）。<ul>
<li>htons方法用于将unsigned short int型主机字节序的端口数字转换成网络传输需要的字节序的端口数字。</li>
</ul>
</li>
<li>struct in_addr sin_addr，具体ip地址，是一个4字节无符号整数（unsigned int）。<ul>
<li>htonl方法用于将unsigned int型主机字节序的端口数字转换成网络传输需要的字节序的端口数字。</li>
</ul>
</li>
</ul>
<p>常用地址如下：</p>
<ul>
<li>INADDR_LOOPBACK，本机回环地址，127.0.0.0</li>
<li>INADDR_ANY，接收任意收到的消息，0.0.0.0</li>
<li>INADDR_BROADCASE，广播地址，发动消息到任意主机，255.255.255.255</li>
</ul>
<pre><code class="c++">/* Structure describing an Internet socket address.  */
struct sockaddr_in
  &#123;
    __SOCKADDR_COMMON (sin_);
    in_port_t sin_port;            /* Port number.  */
    struct in_addr sin_addr;        /* Internet address.  */

    /* Pad to size of `struct sockaddr&#39;.  */
    unsigned char sin_zero[sizeof (struct sockaddr) -
               __SOCKADDR_COMMON_SIZE -
               sizeof (in_port_t) -
               sizeof (struct in_addr)];
  &#125;;

/* Internet address.  */
typedef uint32_t in_addr_t;
struct in_addr
  &#123;
    in_addr_t s_addr;
  &#125;;

typedef __uint32_t uint32_t;
typedef unsigned int __uint32_t;

extern uint32_t htonl (uint32_t __hostlong)
     __THROW __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __THROW __attribute__ ((__const__));
</code></pre>
<p>创建socket地址：</p>
<pre><code class="c++">sockaddr_in addr&#123;&#125;;
addr.sin_family = AF_INET;
short unsigned int port = htons(3000);
cout &lt;&lt; &quot;转换前的端口为：&quot; &lt;&lt; 3000 &lt;&lt; &quot;，转换后的端口为：&quot; &lt;&lt; port &lt;&lt; endl;
addr.sin_port = port;
unsigned long int address = htonl(INADDR_LOOPBACK);
cout &lt;&lt; &quot;转换前的地址为：&quot; &lt;&lt; INADDR_LOOPBACK &lt;&lt; &quot;，转换后的地址为：&quot; &lt;&lt; address &lt;&lt; endl;
addr.sin_addr.s_addr = address;
</code></pre>
<h2 id="3、setsockopt"><a href="#3、setsockopt" class="headerlink" title="3、setsockopt"></a>3、setsockopt</h2><p>该方法用于设置socket选项，可选调用，也可以不调用该方法，使用默认选项。但通常来说启动其中的“复用端口号”选项可以开启，若不开启该选项，重启server端的socket程序时，会绑定端口错误，说端口正在被使用。</p>
<pre><code class="c++">/* Set socket FD&#39;s option OPTNAME at protocol level LEVEL
   to *OPTVAL (which is OPTLEN bytes long).
   Returns 0 on success, -1 for errors.  */
extern int setsockopt (int __fd, int __level, int __optname,
             const void *__optval, socklen_t __optlen) __THROW;

setsockopt(welcome_socket, SOL_SOCKET, SO_REUSEADDR, &amp;enable, sizeof(int));
</code></pre>
<p>socket选项如下：</p>
<pre><code class="c++">#define SO_DEBUG    1
#define SO_REUSEADDR    2
#define SO_TYPE        3
#define SO_ERROR    4
#define SO_DONTROUTE    5
#define SO_BROADCAST    6
#define SO_SNDBUF    7
#define SO_RCVBUF    8
#define SO_SNDBUFFORCE    32
#define SO_RCVBUFFORCE    33
#define SO_KEEPALIVE    9
#define SO_OOBINLINE    10
#define SO_NO_CHECK    11
#define SO_PRIORITY    12
#define SO_LINGER    13
#define SO_BSDCOMPAT    14
#define SO_REUSEPORT    15
#ifndef SO_PASSCRED /* powerpc only differs in these */
#define SO_PASSCRED    16
#define SO_PEERCRED    17
#define SO_RCVLOWAT    18
#define SO_SNDLOWAT    19
#define SO_RCVTIMEO    20  // 接收消息的超时时间
#define SO_SNDTIMEO    21  // 发送消息的超时时间
</code></pre>
<h2 id="4、server-socket创建"><a href="#4、server-socket创建" class="headerlink" title="4、server socket创建"></a>4、server socket创建</h2><p>socket表示网络IO的通道，服务器和客户端通信都需要创建socket，服务端接收连接，客户端发起连接。</p>
<p>创建服务端的socket，有以下步骤：</p>
<ul>
<li>创建服务端welcome socket，该socket专门用于接收连接而不会从该socket读取数据。</li>
<li>创建服务端地址结构体sockaddr_in</li>
<li>绑定端口并监听</li>
<li>接收连接，获取connection socket，该socket代表一个连接会话，可以从该socket中读取数据。</li>
<li>读取字节流，处理，写入输出字节流</li>
</ul>
<h3 id="（1）绑定、监听"><a href="#（1）绑定、监听" class="headerlink" title="（1）绑定、监听"></a>（1）绑定、监听</h3><p>将创建的socket绑定到创建的ip地址上。</p>
<p>其中需要将sockaddr_in强制转换为sockaddr指针再绑定。</p>
<pre><code class="c++">/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __THROW;

/* Structure describing a generic socket address.  */
struct sockaddr
  &#123;
    __SOCKADDR_COMMON (sa_);    /* Common data: address family and length.  */
    char sa_data[14];        /* Address data.  */
  &#125;;

bind(welcome_socket1, (struct sockaddr *) &amp;addr, sizeof(addr));
</code></pre>
<p>开启对socket的监听，准备接受客户端连接。</p>
<p>N表示最大队列数，当程序已经接收到一个connection时，若还有其他客户端发起连接，则会进入队列中，当前连接处理结束后会直接从队列中取出下一个连接进行处理。超过该数字的连接将会被抛弃。</p>
<pre><code class="c++">/* Prepare to accept connections on socket FD.
   N connection requests will be queued before further requests are refused.
   Returns 0 on success, -1 for errors.  */
extern int listen (int __fd, int __n) __THROW;

listen(welcome_socket1, 10);
</code></pre>
<h3 id="（2）接收连接"><a href="#（2）接收连接" class="headerlink" title="（2）接收连接"></a>（2）接收连接</h3><p>在已经创建好的服务端socket上阻塞等待客户端连接。</p>
<ul>
<li><p>addr指针表示连接对方的地址，可以用INADDR_ANY表示任意地址，或者填如nullptr，也表示任意地址。若指定了某个地址，则只有该地址可以访问。</p>
</li>
<li><p>addr_len指针表示addr的sizeof。</p>
</li>
</ul>
<p>当接收到一个客户端连接时，该方法就返回一个整数，代表本次会话的连接socket。</p>
<p>注意这个连接socket和服务端socket不一样。服务端socket只用于接收新的连接，而连接socket</p>
<pre><code class="c++">/* Await a connection on socket FD.
   When a connection arrives, open a new socket to communicate with it,
   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
   peer and *ADDR_LEN to the address&#39;s actual length, and return the
   new socket&#39;s descriptor, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int accept (int __fd, __SOCKADDR_ARG __addr,
           socklen_t *__restrict __addr_len);

int connection_socket = accept(welcome_socket1, nullptr, nullptr);
</code></pre>
<h3 id="（3）读取返回"><a href="#（3）读取返回" class="headerlink" title="（3）读取返回"></a>（3）读取返回</h3><p>从使用read方法可以从刚才得到的连接socket中读取字节流，可以用一个缓冲区接收该字节流。</p>
<p>经处理后，再将响应消息通过write方法，写入这个连接socket</p>
<pre><code class="c++">char buffer[1024] = &#123;0&#125;;
read(connection_socket, buffer, sizeof(buffer));
printf(&quot;%s\n&quot;, buffer);
char* response = &quot;hello world!&quot;;
send(connection_socket, response, strlen(response), 0);
close(welcome_socket);
close(connection_socket);
</code></pre>
<h3 id="（4）服务端完整代码"><a href="#（4）服务端完整代码" class="headerlink" title="（4）服务端完整代码"></a>（4）服务端完整代码</h3><pre><code class="c++">int my_server(int port) &#123;
    // TCP连接
    int welcome_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (welcome_socket &lt; 0) &#123;
        cout &lt;&lt; &quot;socket创建失败&quot;;
        exit(-1);
    &#125;
    int enable = 1;
    setsockopt(welcome_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEADDR, &amp;enable, sizeof(int));
    // 创建地址
    struct sockaddr_in addr&#123;&#125;;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    int len = sizeof(addr);

    // 绑定并并监听
    if (bind(welcome_socket, (sockaddr*) &amp;addr, len) &lt; 0) &#123;
        cout &lt;&lt; &quot;绑定失败&quot;;
        exit(-1);
    &#125;
    // listen的第二个参数n，表示最大队列数
    if (listen(welcome_socket, 10) &lt; 0) &#123;
        cout &lt;&lt; &quot;监听失败&quot;;
        exit(-1);
    &#125;

    while (true) &#123;
        int conn_socket = accept(welcome_socket, nullptr, nullptr);
        if (conn_socket &lt; 0) &#123;
            cout &lt;&lt; &quot;客户端连接失败&quot;;
            exit(-1);
        &#125;
        char buffer[1024] = &#123;0&#125;;
        read(conn_socket, buffer, sizeof(buffer));
        printf(&quot;%s\n&quot;, buffer);
        char* response = &quot;OK&quot;;
        send(conn_socket, response, strlen(response), 0);
        close(conn_socket);
    &#125;
&#125;
</code></pre>
<h2 id="5、client-socket创建"><a href="#5、client-socket创建" class="headerlink" title="5、client socket创建"></a>5、client socket创建</h2><p>创建client socket和server端的socket差异不大，只是没有welcome socket和client的区分，以及连接服务端的方法不是accept，而是connect。代码如下：</p>
<pre><code class="c++">int my_client(char* host, int port) &#123;
    int client_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (client_socket &lt; 0) &#123;
        cout &lt;&lt; &quot;客户端socket创建失败！&quot;;
        exit(-1);
    &#125;
    struct sockaddr_in serverAddr&#123;&#125;;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(port);
    int res = inet_pton(AF_INET, host, &amp;serverAddr.sin_addr);
    if (res &lt; 0) &#123;
        cout &lt;&lt; &quot;解析host失败&quot;;
        exit(-1);
    &#125;
    res = connect(client_socket, (struct sockaddr *) &amp;serverAddr, sizeof(serverAddr));
    if (res &lt; 0) &#123;
        cout &lt;&lt; &quot;连接服务器失败&quot;;
        exit(-1);
    &#125;
    char buffer[1024] = &#123;0&#125;;
    char* message = &quot;hello server, I&#39;m client!&quot;;
    int n = send(client_socket, message, strlen(message), 0);
    if (n &lt; 0) &#123;
        cout &lt;&lt; &quot;消息发送失败&quot; &lt;&lt; endl;
    &#125;else &#123;
        cout &lt;&lt; &quot;消息已发送&quot; &lt;&lt; endl;
    &#125;
    read(client_socket, buffer, sizeof(buffer));
    printf(&quot;%s&quot;, buffer);
    close(client_socket);
    return 0;
&#125;
</code></pre>
<h2 id="6、fork-server"><a href="#6、fork-server" class="headerlink" title="6、fork server"></a>6、fork server</h2><p>以上说的tcp server只能处理一个连接，无法处理多个请求。想要处理多个请求，第一时间可以想到用多进程或多进线程，可以通过fork一个server进程来实现处理多请求。在以往的unix操作系统中，使用多线程的难度高于使用多进程，因此大多数c++程序员使用多进程而不是多线程来处理多任务。</p>
<p>代码如下。</p>
<ul>
<li><p><code>signal(SIGCHLD, SIG_IGN);</code>，忽略子进程的信号，子进程会交给操作系统内核来回收</p>
</li>
<li><p><code>fork()</code>，可以创建一个子进程，子进程使用的资源全部是从父进程复制的来。在子进程中该方法返回0，父进程中返回子进程的pid。</p>
</li>
</ul>
<p>这里不深入讨论fork和signal的细节。</p>
<p>题外话：postgres、linux上的oracle数据库的连接就是多进程的，而MySQL是多线程。</p>
<pre><code class="c++">int fork_server(int port) &#123;
    signal(SIGCHLD, SIG_IGN); // 忽略子进程的信号，子进程会交给操作系统内核来回收
    // TCP连接
    int welcome_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (welcome_socket &lt; 0) &#123;
        cout &lt;&lt; &quot;socket创建失败&quot;;
        exit(-1);
    &#125;
    int enable = 1;
    setsockopt(welcome_socket, SOL_SOCKET, SO_REUSEADDR | SO_REUSEADDR, &amp;enable, sizeof(int));
    // 创建地址
    struct sockaddr_in addr&#123;&#125;;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    int len = sizeof(addr);

    // 绑定并并监听
    if (bind(welcome_socket, (sockaddr*) &amp;addr, len) &lt; 0) &#123;
        cout &lt;&lt; &quot;绑定失败&quot;;
        exit(-1);
    &#125;
    // listen的第二个参数n，表示最大队列数
    if (listen(welcome_socket, 10) &lt; 0) &#123;
        cout &lt;&lt; &quot;监听失败&quot;;
        exit(-1);
    &#125;
    int count = 0;

    while (true) &#123;
        int conn_socket = accept(welcome_socket, nullptr, nullptr);
        if (conn_socket &lt; 0) &#123;
            cout &lt;&lt; &quot;客户端连接失败&quot;;
            exit(-1);
        &#125;
        // 如果该进程是父进程，收到一个connection，只需要fork一个子进程，将连接交给子进程来处理，自己可以回去继续接收连接
        if (fork() &gt; 0) &#123;
            continue;
        &#125;
        // 以下是子进程操作
        while (true) &#123;
            char buffer[1024] = &#123;0&#125;;
            int size = read(conn_socket, buffer, sizeof(buffer));
            if (size &lt;= 0) &#123;
                break;
            &#125;
            printf(&quot;%s %d\n&quot;, buffer, count++);
            char* response = buffer;
            send(conn_socket, response, strlen(response), 0);
        &#125;
        close(conn_socket);
        // 子进程需要关闭welcome_socket，并结束进程
        close(welcome_socket);
        return 0;
    &#125;
&#125;
</code></pre>
<h2 id="7、心跳"><a href="#7、心跳" class="headerlink" title="7、心跳"></a>7、心跳</h2><p>服务端对于一个已经建立好的连接，经常会设置接收消息的超时时间，即若超过这个时间没有消息到来时，就会断开该连接。</p>
<p>服务端设置超时时间只需要对connectin socket设置setsockopt即可，如下。</p>
<p>当服务端加上以下代码时，若客户端连接上后，超过10秒没有发送消息，服务端则会自动断开该连接。</p>
<pre><code class="c++">// 设置接收报文超时时间
struct timeval tv&#123;&#125;;
tv.tv_usec = 0;
tv.tv_sec = 10;
setsockopt(conn_socket, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, sizeof(tv));
</code></pre>
<p>而客户端为了保证一直保持连接状态，就需要定时向服务端发送心跳包。可以简单通过fork一个客户端进程来时间定时发送心跳包。</p>
<pre><code class="c++">if (fork() == 0) &#123;
    // 若为子进程，则无限循环每过5秒发送发送心跳包。
    while(true) &#123;
        send(client_socket, &quot;0&quot;, 1, 0);
        char buffer[1024] = &#123;&#125;;
        read(client_socket, buffer, sizeof(buffer));
        printf(&quot;%s&quot;, buffer);
        sleep(5);
    &#125;
    return 0;
&#125;
</code></pre>
<p>同时服务端也需要对收到的消息进行额外处理。若为心跳包，则不进行业务处理，而是直接返回一个success。</p>
<pre><code class="c++">// 简单设定心跳报文为一个字符0，则当服务端收到心跳报文，不进行业务处理，只返回可以只返回一个成功消息即可。
if (size == 1 &amp;&amp; strcmp(buffer, &quot;0&quot;) == 0) &#123;
    cout &lt;&lt; &quot;heart beat!&quot; &lt;&lt; endl;
    char* response = &quot;success&quot;;
    send(conn_socket, response, strlen(response), 0);
    continue;
&#125;else if (size &lt;= 0) &#123;
    close(conn_socket);
    break;
&#125;
</code></pre>
<h2 id="8、select"><a href="#8、select" class="headerlink" title="8、select"></a>8、select</h2><h3 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><p>前面说的server socket每次只能处理一个客户端连接，当有多个客户端尝试请求服务器时，会以队列的形式一个一个处理。因此要处理多个客户端的连接，可以使用<strong>select</strong>命令。</p>
<p>select命令允许监控多个socket，当这些socket都没有事件发生时，select被阻塞，当任意一个socket变为活动状态时就会返回对应socket数字，当select的返回值为-1时，则表示产生异常。</p>
<p>select命令使用的结构体是<code>fd_set</code>，即socket要放在这个结构体中，才能被监控到。该默认大小是128个字节，结构体底层使用bitmap，128个字节对应1024位，每个位代表一个socket，因此最多可以记录1024个socket情况。</p>
<pre><code class="c++">/* fd_set for select and pselect.  */
typedef struct
  &#123;
    /* XPG4.2 requires this member name.  Otherwise avoid the name
       from the global namespace.  */
#ifdef __USE_XOPEN
    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)-&gt;fds_bits)
#else
    __fd_mask __fds_bits[__FD_SETSIZE / __NFDBITS];
# define __FDS_BITS(set) ((set)-&gt;__fds_bits)
#endif
  &#125; fd_set;
</code></pre>
<p>对<code>fd_set</code>数据结构的操作方法如下：</p>
<pre><code class="c++">fd_set read_fd;

// 清空fd_set
FD_ZERO(&amp;read_fd);  

// 往fd_set中新增一个文件描述符，即将bitmap对应位置的值设置为1
FD_SET(master_sock, &amp;read_fd);   

// 从fd_set中移除一个文件描述符，即将bitmap对应位置的值设置为0
FD_CLR(master_sock, &amp;read_fd); 

// 如果一个文件描述符中发生了一些事件，则返回1，否则返回0。该事件可以是新连接、可读事件、可写事件等等。
FD_ISSET(master_sock, &amp;readfds); 
</code></pre>
<p>select函数如下：</p>
<ul>
<li>返回值 &gt; 1，即活跃的socket</li>
<li>返回值 = 0，超时</li>
<li>返回值 = -1，出现异常</li>
</ul>
<pre><code class="c++">/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
   after waiting the interval specified therein.  Returns the number of ready
   descriptors, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int select (int __nfds, fd_set *__restrict __readfds,
           fd_set *__restrict __writefds,
           fd_set *__restrict __exceptfds,
           struct timeval *__restrict __timeout);
</code></pre>
<h3 id="（2）流程"><a href="#（2）流程" class="headerlink" title="（2）流程"></a>（2）流程</h3><p>使用select常用轮询的方式：</p>
<p>1、先创建一个welcome_socket准备接收连接，创建一个数组<code>int client_socket[30]</code>用于存放收到的socket。</p>
<p>2、清空fd_set，将welcome_socket放入fd_set中监控，将client_socket中已有的连接放入fd_set中进行监控</p>
<p>3、先判断welcome是否有活动。若有活动，则创建新连接，并加入到client_socket数组中。</p>
<p>4、再循环client_socket依次判断这里面的所有socket是否有活动。若有活动则进行IO读写。若发现已经断开连接，则从client_socket中移除。</p>
<p>5、重复步骤2。</p>
<h3 id="（3）完整实现"><a href="#（3）完整实现" class="headerlink" title="（3）完整实现"></a>（3）完整实现</h3><pre><code class="c++">int select_server(int port) &#123;
    int opt = true;
    int welcome_socket , addrlen , new_socket , client_socket[30] ,
            max_clients = 30 , activity, i , valread , sd;
    int max_sd, count = 0;
    struct sockaddr_in address &#123; &#125;;

    char buffer[1025];  //data buffer of 1K

    //set of socket descriptors
    fd_set readfds;

    //a message
    char *message = &quot;ECHO Daemon v1.0 \r\n&quot;;

    //initialise all client_socket[] to 0 so not checked
    for (i = 0; i &lt; max_clients; i++)
    &#123;
        client_socket[i] = 0;
    &#125;

    //create a master socket
    if( (welcome_socket = socket(AF_INET , SOCK_STREAM , 0)) == 0)
    &#123;
        perror(&quot;socket failed&quot;);
        exit(EXIT_FAILURE);
    &#125;

    //set master socket to allow multiple connections ,
    //this is just a good habit, it will work without this
    if( setsockopt(welcome_socket, SOL_SOCKET, SO_REUSEADDR, (char *)&amp;opt,
                   sizeof(opt)) &lt; 0 )
    &#123;
        perror(&quot;setsockopt&quot;);
        exit(EXIT_FAILURE);
    &#125;

    //type of socket created
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons( port );

    //bind the socket to localhost port 8888
    if (bind(welcome_socket, (struct sockaddr *)&amp;address, sizeof(address))&lt;0)
    &#123;
        perror(&quot;bind failed&quot;);
        exit(EXIT_FAILURE);
    &#125;
    printf(&quot;Listener on port %d \n&quot;, port);

    //try to specify maximum of 3 pending connections for the master socket
    if (listen(welcome_socket, 3) &lt; 0)
    &#123;
        perror(&quot;listen&quot;);
        exit(EXIT_FAILURE);
    &#125;

    //accept the incoming connection
    addrlen = sizeof(address);
    puts(&quot;Waiting for connections ...&quot;);

    while(true)
    &#123;
        //clear the socket set
        FD_ZERO(&amp;readfds);

        //add master socket to set
        FD_SET(welcome_socket, &amp;readfds);
        max_sd = welcome_socket;

        //add child sockets to set
        for ( i = 0 ; i &lt; max_clients ; i++)
        &#123;
            //socket descriptor
            sd = client_socket[i];

            //if valid socket descriptor then add to read list
            if(sd &gt; 0)
                FD_SET( sd , &amp;readfds);

            //highest file descriptor number, need it for the select function
            if(sd &gt; max_sd)
                max_sd = sd;
        &#125;

        //wait for an activity on one of the sockets , timeout is NULL ,
        //so wait indefinitely
        activity = select( max_sd + 1 , &amp;readfds , nullptr , nullptr , nullptr);

        if ((activity &lt; 0) &amp;&amp; (errno!=EINTR))
        &#123;
            printf(&quot;select error&quot;);
        &#125;

        //If something happened on the master socket ,
        //then its an incoming connection
        if (FD_ISSET(welcome_socket, &amp;readfds))
        &#123;
            if ((new_socket = accept(welcome_socket,
                                     (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen))&lt;0)
            &#123;
                perror(&quot;accept&quot;);
                exit(EXIT_FAILURE);
            &#125;

            //inform user of socket number - used in send and receive commands
            printf(&quot;New connection , socket fd is %d , ip is : %s , port : %d\n&quot;,
                   new_socket , inet_ntoa(address.sin_addr) , ntohs(address.sin_port));

            //send new connection greeting message
            if( send(new_socket, message, strlen(message), 0) != strlen(message) )
            &#123;
                perror(&quot;send&quot;);
            &#125;

            puts(&quot;Welcome message sent successfully&quot;);

            //add new socket to array of sockets
            for (i = 0; i &lt; max_clients; i++)
            &#123;
                //if position is empty
                if( client_socket[i] == 0 )
                &#123;
                    client_socket[i] = new_socket;
                    printf(&quot;Adding to list of sockets as %d\n&quot; , i);

                    break;
                &#125;
            &#125;
        &#125;

        //else its some IO operation on some other socket
        for (i = 0; i &lt; max_clients; i++)
        &#123;
            sd = client_socket[i];

            if (FD_ISSET( sd , &amp;readfds))
            &#123;
                //Check if it was for closing , and also read the
                //incoming message
                if ((valread = read( sd , buffer, 1024)) == 0)
                &#123;
                    //Somebody disconnected , get his details and print
                    getpeername(sd , (struct sockaddr*)&amp;address , \
                        (socklen_t*)&amp;addrlen);
                    printf(&quot;Host disconnected , ip %s , port %d \n&quot; ,
                           inet_ntoa(address.sin_addr) , ntohs(address.sin_port));

                    //Close the socket and mark as 0 in list for reuse
                    close( sd );
                    client_socket[i] = 0;
                &#125;

                //Echo back the message that came in
                else
                &#123;
                    //set the string terminating NULL byte on the end
                    //of the data read
                    buffer[valread] = &#39;r&#39;;
                    buffer[valread + 1] = &#39;\0&#39;;
                    printf(&quot;%s %d\n&quot;, buffer, count++);
                    send(sd , buffer , strlen(buffer) , 0 );
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h3 id="（4）优缺点"><a href="#（4）优缺点" class="headerlink" title="（4）优缺点"></a>（4）优缺点</h3><p>优点：</p>
<ul>
<li><p>IO复用</p>
</li>
<li><p>适用于并发量小的场景，性能强</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>支持的文件描述符只有1024。由于采用轮询的方式，因此调大该数值的意义不大。</li>
<li>只要连接没有关闭，即使没有活动，也会被遍历到，每次都要遍历所有socket，连接数越多性能越差。</li>
<li>每次循环之前需要拷贝socket</li>
</ul>
<h3 id="（5）pselect"><a href="#（5）pselect" class="headerlink" title="（5）pselect"></a>（5）pselect</h3><p>pselect和select基本一样，在select的基础上有两处变化：</p>
<ul>
<li>timeout结构体从timeval（秒+微秒）改成了timespec（秒+纳秒）</li>
<li>新增了一个__sigmask信号掩码参数</li>
</ul>
<p>嗯，不太懂。</p>
<h3 id="（6）注意点"><a href="#（6）注意点" class="headerlink" title="（6）注意点"></a>（6）注意点</h3><ul>
<li>select对于没有结束的事件，在下一次轮询中还会继续活跃。比如第一次read指定长度的buffer，但是客户端发送的数据包很大，一个buffer没有读完，因此在下一次循环中该socket依然是活跃的，可以继续从socket中读取数据。</li>
<li>select本质上是针对文件描述符的，因此也可以多个文件的读写进行IO复用，但很少这样用。</li>
</ul>
<h2 id="9、poll"><a href="#9、poll" class="headerlink" title="9、poll"></a>9、poll</h2><p>poll和select在本质上没有区别，也是管理多个socket然后进行轮询，根据socket的状态进行处理。</p>
<p>poll使用的数据结构是<code>pollfd</code>，一个封装了socket的机构体。</p>
<pre><code class="c++">/* Data structure describing a polling request.  */
struct pollfd
  &#123;
    // socket
    int fd;            /* File descriptor to poll.  */
    // 用户注册的需要监听的事件
    short int events;        /* Types of events poller cares about.  */
    // 实际在socket上发生的事件
    short int revents;        /* Types of events that actually occurred.  */
  &#125;;
</code></pre>
<p>事件共有以下几种：</p>
<pre><code class="c++">// 常用事件
/* Event types that can be polled for.  These bits may be set in `events&#39;
   to indicate the interesting event types; they will appear in `revents&#39;
   to indicate the status of the file descriptor.  */
#define POLLIN        0x001        /* There is data to read.  */
#define POLLPRI        0x002        /* There is urgent data to read.  */
#define POLLOUT        0x004        /* Writing now will not block.  */

// revents事件如下，revents事件不能用于events，用于表示socket状态
/* Event types always implicitly polled for.  These bits need not be set in
   `events&#39;, but they will appear in `revents&#39; to indicate the status of
   the file descriptor.  */
#define POLLERR        0x008        /* Error condition.  */
#define POLLHUP        0x010        /* Hung up.  */
#define POLLNVAL    0x020        /* Invalid polling request.  */
</code></pre>
<p>poll方法从一个pollfd数组中，获取出和用户注册的事件一致的一个socket。poll方法如下：</p>
<ul>
<li>返回值 = 1，即活跃的socket</li>
<li>返回值 = 0，超时</li>
<li>返回值 = -1，出现异常</li>
</ul>
<pre><code class="c++">/* Poll the file descriptors described by the NFDS structures starting at
   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
   an event to occur; if TIMEOUT is -1, block until an event occurs.
   Returns the number of file descriptors with events, zero if timed out,
   or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);
</code></pre>
<p>poll代码和select也差不多，如下：</p>
<pre><code class="c++">int poll_server(int port) &#123;
    int MAX_CONNECTION = 1024;
    int max_fd;
    struct sockaddr_in addr&#123;&#125;;
    int addr_len = sizeof(addr);
    char buffer[1024];
    char response[1024] = &quot;hello&quot;;
    int count = 0;

    int welcome_socket = create_welcome_socket(port);
    cout &lt;&lt; &quot;welcome_socket:&quot; &lt;&lt; welcome_socket &lt;&lt; endl;
    struct pollfd fds[MAX_CONNECTION];
    // 初始化，将fd设置为-1
    // 对于poll函数，若fd为-1，则会被忽略
    for (int i = 0; i &lt; MAX_CONNECTION; i++) fds[0].fd = -1;

    // 初始化welcome_socket
    fds[welcome_socket].fd = welcome_socket;
    // 为welcome_socket注册可读事件
    fds[welcome_socket].events = POLLIN;
    max_fd = welcome_socket;

    while (true) &#123;
        int activity = poll(fds, max_fd + 1, -1);
        if (activity &lt; 0) &#123;
            printf(&quot;poll error!\n&quot;);
            break;
        &#125;

        for (int i = 0; i &lt;= max_fd; ++i) &#123;
            pollfd f = fds[i];
            if (f.fd == -1) continue;
            if (f.revents != POLLIN) continue;
            if (f.fd == welcome_socket) &#123;
                // 处理welcome_socket
                // (struct sockaddr *)&amp;addr, (socklen_t *)(sizeof(addr))
                int new_connection = accept(welcome_socket, (struct sockaddr *)&amp;addr, (socklen_t*)&amp;addr_len);
                if (new_connection &lt; 0) &#123;
                    printf(&quot;accept error!\n&quot;);
                    continue;
                &#125;
                cout &lt;&lt; &quot;new socket:&quot; &lt;&lt; new_connection &lt;&lt; endl;
                //inform user of socket number - used in send and receive commands
                printf(&quot;New connection , socket:%d , ip:%s , port:%d\n&quot;,
                       new_connection , inet_ntoa(addr.sin_addr) , ntohs(addr.sin_port));
                fds[new_connection].fd = new_connection;
                fds[new_connection].events = POLLIN;
                max_fd = max(max_fd, new_connection);
                f.events = POLLIN;
                cout &lt;&lt; &quot;max_fd:&quot; &lt;&lt; max_fd &lt;&lt; endl;
            &#125;else &#123;
                cout &lt;&lt; &quot;fd:&quot; &lt;&lt; f.fd &lt;&lt; endl;
                if (f.revents == POLLIN) &#123;
                    // 处理读事件
                    int size = read(f.fd, buffer, sizeof(buffer));
                    if (size &lt;= 0) &#123;
                        getpeername(f.fd, (struct sockaddr *)&amp;addr, (socklen_t*)&amp;addr_len);
                        printf(&quot;client disconnected, ip:%s, port:%d\n&quot;,
                               inet_ntoa(addr.sin_addr) , ntohs(addr.sin_port));
                        if (max_fd == f.fd) &#123;
                            for (int j = max_fd - 1; j &gt; 0; --j) &#123;
                                if (fds[j].fd != -1) &#123;
                                    max_fd = fds[j].fd;
                                    break;
                                &#125;
                            &#125;
                        &#125;
                        cout &lt;&lt; &quot;max_fd:&quot; &lt;&lt; max_fd &lt;&lt; endl;
                        close(f.fd);
                        f.fd = -1;
                    &#125;else &#123;
                        printf(&quot;接收消息%d:%s\n&quot;, count++, buffer);
                        buffer[size] = &#39;\0&#39;;
                        size = send(f.fd, buffer, strlen(buffer), 0);
                        if (size &lt; 0) &#123;
                            printf(&quot;write error!\n&quot;);
                        &#125;
                        // 将该socket重新注册监听可读事件
                        f.events = POLLIN;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<p>poll的缺点：</p>
<ul>
<li>没有避免拷贝socket这个环节</li>
<li>依然采用轮询的方式，连接数越多性能越差</li>
</ul>
<h2 id="10、epoll"><a href="#10、epoll" class="headerlink" title="10、epoll"></a>10、epoll</h2><h3 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>为解决以上select和poll轮询的缺点，epoll出现了。</p>
<p>epoll的本质不是主动轮询找到活跃的fd，而是使用系统内核在每个fd上的回调函数实现的。即当有fd活跃时，会触发系统内核的一个callback函数，加入到Ready队列中，并通知应用程序来处理这个事件。因此应用程序只要无限循环处理这个Ready队列中的fd即可。</p>
<p>epoll的两种工作模式：</p>
<ul>
<li>level triggered：水平触发，即当一个fd就绪时，内核会通知你，并且直到该fd事件完全结束。假如你读取了一部分数据，还剩一部分数据没读取，内核会继续通知这个事件。select和poll都是这种工作模式。支持block和no-block socket。</li>
<li>edge triggered：边缘触发，即当一个fd就绪时，内核会通知你，直到你做了某些操作导致这个fd不再时就绪状态，比如读取了一半数据的fd，并不是就绪状态，后面内核就不再通知这个事件了。除非下一次IO又开始了。只支持non-block socket。这种方式会导致代码变得复杂，并且容易丢失数据。</li>
</ul>
<p>man文档是这样举例的：</p>
<p>当一个IO事件如下时，若该fd注册到epoll中使用的是edge triggered时，下面第5步不会是就绪状态，而是阻塞状态。尽管在fd中还有可用数据。同时客户端会一直等待服务器针对这次IO的响应消息。但如果注册到epoll中使用的是level triggered时，第5步则会是就绪状态，即内核还会继续通知应用程序该fd事件。</p>
<ul>
<li>1.将一个read fd注册到epoll实例上</li>
<li>2.read fd对应的客户端发送一个2kb的数据包给read fd</li>
<li>3.epoll_wait就绪（解除阻塞）并且返回对应的fd给应用程序</li>
<li>4.应用程序只读取了1kb的数据</li>
<li>5.由于事件未结束，因此下一次调用epoll_wait函数时也是就绪状态。</li>
</ul>
<h3 id="（2）epoll使用的结构体和系统调用"><a href="#（2）epoll使用的结构体和系统调用" class="headerlink" title="（2）epoll使用的结构体和系统调用"></a>（2）epoll使用的结构体和系统调用</h3><p>结构体：</p>
<ul>
<li>epoll_event：epoll适用的事件结构体，events属性表示具体事件类型，data又是一个结构体，fd就是该事件对应的socket</li>
</ul>
<p>函数：</p>
<ul>
<li><p>epoll_create：创建一个epoll实例，需要将其他socket与之关联在一起</p>
</li>
<li><p>epoll_create1：同epoll_create，去掉了size参数，加上了flags参数</p>
</li>
<li><p>epoll_ctl：对epoll_fd进行操作，op参数为操作类型，可以新增、删除、修改一个普通fd的绑定关系。</p>
</li>
<li><p>epoll_wait：等待与epoll_fd绑定的fd上的事件，当有事件发生时解除阻塞，并返回事件数量</p>
</li>
</ul>
<pre><code class="c++">struct epoll_event
&#123;
  uint32_t events;    /* Epoll events */
  epoll_data_t data;    /* User data variable */
&#125; __EPOLL_PACKED;

typedef union epoll_data
&#123;
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
&#125; epoll_data_t;

/* Creates an epoll instance.  Returns an fd for the new instance.
   The &quot;size&quot; parameter is a hint specifying the number of file
   descriptors to be associated with the new instance.  The fd
   returned by epoll_create() should be closed with close().  */
extern int epoll_create (int __size) __THROW;

/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE
   parameter has been dropped.  */
extern int epoll_create1 (int __flags) __THROW;

/* Manipulate an epoll instance &quot;epfd&quot;. Returns 0 in case of success,
   -1 in case of error ( the &quot;errno&quot; variable will contain the
   specific error code ) The &quot;op&quot; parameter is one of the EPOLL_CTL_*
   constants defined above. The &quot;fd&quot; parameter is the target of the
   operation. The &quot;event&quot; parameter describes which events the caller
   is interested in and any associated user data.  */
extern int epoll_ctl (int __epfd, int __op, int __fd,
              struct epoll_event *__event) __THROW;

/* Valid opcodes ( &quot;op&quot; parameter ) to issue to epoll_ctl().  */
#define EPOLL_CTL_ADD 1    /* Add a file descriptor to the interface.  */
#define EPOLL_CTL_DEL 2    /* Remove a file descriptor from the interface.  */
#define EPOLL_CTL_MOD 3    /* Change file descriptor epoll_event structure.  */

/* Wait for events on an epoll instance &quot;epfd&quot;. Returns the number of
   triggered events returned in &quot;events&quot; buffer. Or -1 in case of
   error with the &quot;errno&quot; variable set to the specific error code. The
   &quot;events&quot; parameter is a buffer that will contain triggered
   events. The &quot;maxevents&quot; is the maximum number of events to be
   returned ( usually size of &quot;events&quot; ). The &quot;timeout&quot; parameter
   specifies the maximum wait time in milliseconds (-1 == infinite).

   This function is a cancellation point and therefore not marked with
   __THROW.  */
extern int epoll_wait (int __epfd, struct epoll_event *__events,
               int __maxevents, int __timeout);
</code></pre>
<h3 id="（3）epoll代码流程"><a href="#（3）epoll代码流程" class="headerlink" title="（3）epoll代码流程"></a>（3）epoll代码流程</h3><p>1、创建welcome_socket，将welcome_socket设置为非阻塞</p>
<p>2、使用epoll_create1方法创建一个epoll_fd</p>
<p>3、将welcome_socket和epoll_fd绑定</p>
<p>4、调用epoll_wait方法，获取对应的时间数量nfds</p>
<p>5、0-nfds循环，对事件进行处理，若为welcome_socket则获取连接socket，设置为非阻塞，绑定epoll_fd；若为连接socket则执行IO</p>
<h3 id="（4）完整代码"><a href="#（4）完整代码" class="headerlink" title="（4）完整代码"></a>（4）完整代码</h3><pre><code class="c++">static int make_socket_non_blocking (int sfd)
&#123;
    int flags, s;

    flags = fcntl (sfd, F_GETFL, 0);
    if (flags == -1)
    &#123;
        perror (&quot;fcntl&quot;);
        return -1;
    &#125;

    flags |= O_NONBLOCK;
    s = fcntl (sfd, F_SETFL, flags);
    if (s == -1)
    &#123;
        perror (&quot;fcntl&quot;);
        return -1;
    &#125;

    return 0;
&#125;

int epoll_server(int port) &#123;
    int MAX_CONNECTION = 10;
    struct epoll_event ev&#123;&#125;;
    struct epoll_event *events;
    int conn_sock, nfds, epollfd;
    struct sockaddr_in addr&#123;&#125;;
    int addr_len = sizeof(addr);
    int count = 0;

    events = static_cast&lt;epoll_event *&gt;(calloc(MAX_CONNECTION, sizeof(ev)));
    int welcome_socket = create_welcome_socket(port);
    int s = make_socket_non_blocking(welcome_socket);
    if (s == -1)
        abort();

    epollfd = epoll_create1(0);
    if (epollfd == -1) &#123;
        perror(&quot;epoll_create1&quot;);
        exit(EXIT_FAILURE);
    &#125;

    ev.events = EPOLLIN;
    ev.data.fd = welcome_socket;
    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, welcome_socket, &amp;ev) == -1) &#123;
        perror(&quot;epoll_ctl: listen_sock&quot;);
        exit(EXIT_FAILURE);
    &#125;

    for (;;) &#123;
        nfds = epoll_wait(epollfd, events, MAX_CONNECTION, -1);
        if (nfds == -1) &#123;
            perror(&quot;epoll_wait&quot;);
            exit(EXIT_FAILURE);
        &#125;

        for (int i = 0; i &lt; nfds; ++i) &#123;
            if (events[i].data.fd == welcome_socket) &#123;
                conn_sock = accept(welcome_socket, (struct sockaddr *) &amp;addr, (socklen_t *)&amp;addr_len);
                if (conn_sock == -1) &#123;
                    perror(&quot;accept&quot;);
                    exit(EXIT_FAILURE);
                &#125;
                make_socket_non_blocking(conn_sock);
                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = conn_sock;
                if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &amp;ev) == -1) &#123;
                    perror(&quot;epoll_ctl: conn_sock&quot;);
                    exit(EXIT_FAILURE);
                &#125;
            &#125; else &#123;
                int done = 0;

                while (true)
                &#123;
                    ssize_t size;
                    char *buffer[1024];
                    getpeername(events[i].data.fd, (struct sockaddr *)&amp;addr, (socklen_t*)&amp;addr_len);
                    size = read (events[i].data.fd, buffer, sizeof(buffer));
                    if (size == -1)
                    &#123;
                        /* If errno == EAGAIN, that means we have read all
                           data. So go back to the main loop. */
                        if (errno != EAGAIN)
                        &#123;
                            perror (&quot;read&quot;);
                            done = 1;
                        &#125;
                        break;
                    &#125;
                    else if (size == 0)
                    &#123;
                        /* End of file. The remote has closed the
                           connection. */
                        done = 1;
                        break;
                    &#125;
                    printf(&quot;收到消息[%d] [ip:%s] [port:%d] - %s\n&quot;,
                           count++, inet_ntoa(addr.sin_addr) , ntohs(addr.sin_port), buffer);
                    /* Write the buffer to standard output */
                    s = send(events[i].data.fd, buffer, size, 0);
                    if (s == -1)
                    &#123;
                        perror (&quot;write&quot;);
                        abort ();
                    &#125;
                &#125;

                if (done)
                &#123;
                    printf (&quot;Closed connection on descriptor %d\n&quot;,
                            events[i].data.fd);

                    /* Closing the descriptor will make epoll remove it
                       from the set of descriptors which are monitored. */
                    close (events[i].data.fd);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>

</div>


    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
              <a href="/%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E7%AB%AF%E5%8F%A3%E5%8F%B7">
                
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>




<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>